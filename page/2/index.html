<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="天天的个人博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="天天的个人博客">
<meta property="article:author" content="tiantian">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>天天的个人博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">天天的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/numpy%20&%20pandas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiantian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天天的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/20/numpy%20&%20pandas/" itemprop="url">numpy & pandas</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-20T16:40:09+08:00">
                2020-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">神经网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="numpy-amp-pandas"><a href="#numpy-amp-pandas" class="headerlink" title="numpy &amp; pandas"></a>numpy &amp; pandas</h1><h2 id="why-numpy-amp-pandas"><a href="#why-numpy-amp-pandas" class="headerlink" title="why numpy &amp; pandas"></a>why numpy &amp; pandas</h2><ul>
<li>运算速度快：numpy 和 pandas 都是采用 C 语言编写, pandas 又是基于 numpy, 是 numpy 的升级版本。</li>
<li>消耗资源少：采用的是矩阵运算，会比 python 自带的字典或者列表快好多</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>

<h2 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li><code>ndim</code>：维度</li>
<li><code>shape</code>：行数和列数</li>
<li><code>size</code>：元素个数</li>
</ul>
<p>列表转化为矩阵：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])  <span class="comment">#列表转化为矩阵</span></span><br><span class="line">print(array)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1, 2, 3],</span></span><br><span class="line"><span class="string">       [2, 3, 4]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>接着我们看看这几种属性的结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'number of dim:'</span>,array.ndim)  <span class="comment"># 维度</span></span><br><span class="line"><span class="comment"># number of dim: 2</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'shape :'</span>,array.shape)    <span class="comment"># 行数和列数</span></span><br><span class="line"><span class="comment"># shape : (2, 3)</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'size:'</span>,array.size)   <span class="comment"># 元素个数</span></span><br><span class="line"><span class="comment"># size: 6</span></span><br></pre></td></tr></table></figure>

<h3 id="numpy-array"><a href="#numpy-array" class="headerlink" title="numpy.array"></a>numpy.array</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;numpy.org&#x2F;doc&#x2F;1.18&#x2F;reference&#x2F;generated&#x2F;numpy.array.html?highlight&#x3D;array#numpy.array</span><br></pre></td></tr></table></figure>

<p><strong>下面为例子</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">2</span>,<span class="number">23</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">32</span>,<span class="number">4</span>]])  <span class="comment"># 2d 矩阵 2行3列</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[ 2 23  4]</span></span><br><span class="line"><span class="string"> [ 2 32  4]]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>创建全零数组</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.zeros((<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 数据全为0，3行4列</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[ 0.,  0.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [ 0.,  0.,  0.,  0.],</span></span><br><span class="line"><span class="string">       [ 0.,  0.,  0.,  0.]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>创建全一数组, 同时也能指定这些特定数据的 <code>dtype</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = np.ones((<span class="number">3</span>,<span class="number">4</span>),dtype = np.int)   <span class="comment"># 数据为1，3行4列</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1, 1, 1, 1],</span></span><br><span class="line"><span class="string">       [1, 1, 1, 1],</span></span><br><span class="line"><span class="string">       [1, 1, 1, 1]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>创建全空数组, 其实每个值都是接近于零的数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = np.empty((<span class="number">3</span>,<span class="number">4</span>)) <span class="comment"># 数据为empty，3行4列</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[  0.00000000e+000,   4.94065646e-324,   9.88131292e-324,</span></span><br><span class="line"><span class="string">          1.48219694e-323],</span></span><br><span class="line"><span class="string">       [  1.97626258e-323,   2.47032823e-323,   2.96439388e-323,</span></span><br><span class="line"><span class="string">          3.45845952e-323],</span></span><br><span class="line"><span class="string">       [  3.95252517e-323,   4.44659081e-323,   4.94065646e-323,</span></span><br><span class="line"><span class="string">          5.43472210e-323]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>用 <code>arange</code> 创建连续数组:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>) <span class="comment"># 10-19 的数据，2步长</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([10, 12, 14, 16, 18])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>用 <code>linspace</code> 创建线段型数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">20</span>)    <span class="comment"># 开始端1，结束端10，且分割成20个数据，生成线段</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([  1.        ,   1.47368421,   1.94736842,   2.42105263,</span></span><br><span class="line"><span class="string">         2.89473684,   3.36842105,   3.84210526,   4.31578947,</span></span><br><span class="line"><span class="string">         4.78947368,   5.26315789,   5.73684211,   6.21052632,</span></span><br><span class="line"><span class="string">         6.68421053,   7.15789474,   7.63157895,   8.10526316,</span></span><br><span class="line"><span class="string">         8.57894737,   9.05263158,   9.52631579,  10.        ])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="numpy-reshape"><a href="#numpy-reshape" class="headerlink" title="numpy.reshape"></a>numpy.reshape</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;numpy.org&#x2F;doc&#x2F;1.18&#x2F;reference&#x2F;generated&#x2F;numpy.reshape.html?highlight&#x3D;reshape#numpy.reshape</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.arange(<span class="number">6</span>).reshape((<span class="number">3</span>, <span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure>

<h3 id="基础运算"><a href="#基础运算" class="headerlink" title="基础运算"></a>基础运算</h3><h4 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h4><p>让我们从一个脚本开始了解相应的计算以及表示形式 ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.array([<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>])   <span class="comment"># array([10, 20, 30, 40])</span></span><br><span class="line">b=np.arange(<span class="number">4</span>)              <span class="comment"># array([0, 1, 2, 3])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 减法</span></span><br><span class="line">c=a-b  <span class="comment"># array([10, 19, 28, 37])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加法</span></span><br><span class="line">c=a+b   <span class="comment"># array([10, 21, 32, 43])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 乘法</span></span><br><span class="line">c=a*b   <span class="comment"># array([  0,  20,  60, 120])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 乘方</span></span><br><span class="line">c=b**<span class="number">2</span>  <span class="comment"># array([0, 1, 4, 9])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 三角函数</span></span><br><span class="line">c=np.sin(a)  </span><br><span class="line"><span class="comment"># array([-0.54402111  0.91294525 -0.98803162  0.74511316])</span></span><br></pre></td></tr></table></figure>

<p>除了函数应用外，在脚本中对<code>print</code>函数进行一些修改可以进行逻辑判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(b&lt;<span class="number">3</span>)  </span><br><span class="line"><span class="comment"># [ True  True  True False]</span></span><br><span class="line"></span><br><span class="line">print(b==<span class="number">2</span>)</span><br><span class="line"><span class="comment"># [False False  True False]</span></span><br></pre></td></tr></table></figure>

<h4 id="二维或多维"><a href="#二维或多维" class="headerlink" title="二维或多维"></a>二维或多维</h4><p>上述运算均是建立在一维矩阵，即只有一行的矩阵上面的计算，如果我们想要对多行多维度的矩阵进行操作，需要对开始的脚本进行一些修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a=np.array([[<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b=np.arange(<span class="number">4</span>).reshape((<span class="number">2</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># array([[1, 1],</span></span><br><span class="line"><span class="comment">#       [0, 1]])</span></span><br><span class="line"></span><br><span class="line">print(b)</span><br><span class="line"><span class="comment"># array([[0, 1],</span></span><br><span class="line"><span class="comment">#       [2, 3]])</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 乘法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 逐个相乘</span></span><br><span class="line">c = a*b</span><br><span class="line"></span><br><span class="line"><span class="comment">#矩阵相乘</span></span><br><span class="line">c_dot = np.dot(a,b)</span><br><span class="line"><span class="comment"># array([[2, 4],</span></span><br><span class="line"><span class="comment">#       [2, 3]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 矩阵相乘另一种表示</span></span><br><span class="line">c_dot_2 = a.dot(b)</span><br><span class="line"><span class="comment"># array([[2, 4],</span></span><br><span class="line"><span class="comment">#       [2, 3]])</span></span><br></pre></td></tr></table></figure>

<p>下面我们将重新定义一个脚本, 来看看关于 <code>sum()</code>, <code>min()</code>, <code>max()</code>的使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a=np.random.random((<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># array([[ 0.94692159,  0.20821798,  0.35339414,  0.2805278 ],</span></span><br><span class="line"><span class="comment">#       [ 0.04836775,  0.04023552,  0.44091941,  0.21665268]])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在整个矩阵中查找/求和</span></span><br><span class="line">np.sum(a)   <span class="comment"># 4.4043622002745959</span></span><br><span class="line">np.min(a)   <span class="comment"># 0.23651223533671784</span></span><br><span class="line">np.max(a)   <span class="comment"># 0.90438450240606416</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以行或列作为查找单位</span></span><br><span class="line"><span class="comment"># 当axis的值为0的时候，将会以列作为查找单元</span></span><br><span class="line"><span class="comment"># 当axis的值为1的时候，将会以行作为查找单元</span></span><br><span class="line">np.sum(a, axis=<span class="number">1</span>)	<span class="comment"># sum = [ 1.96877324  2.43558896]</span></span><br><span class="line">np.min(a, axis=<span class="number">0</span>)	<span class="comment"># min = [ 0.23651224  0.41900661  0.36603285  0.46456022]</span></span><br><span class="line">np.max(a, axis=<span class="number">1</span>)	<span class="comment"># max = [ 0.84869417  0.9043845 ]</span></span><br></pre></td></tr></table></figure>

<p>然而在日常使用中，对应元素的索引也是非常重要的。依然，让我们先从一个脚本开始 ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">2</span>,<span class="number">14</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># array([[ 2, 3, 4, 5]</span></span><br><span class="line"><span class="comment">#        [ 6, 7, 8, 9]</span></span><br><span class="line"><span class="comment">#        [10,11,12,13]])</span></span><br><span class="line">         </span><br><span class="line"><span class="comment"># 求矩阵中最小元素和最大元素的索引</span></span><br><span class="line">print(np.argmin(A))    <span class="comment"># 0</span></span><br><span class="line">print(np.argmax(A))    <span class="comment"># 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 均值</span></span><br><span class="line">print(np.mean(A))        <span class="comment"># 7.5</span></span><br><span class="line">print(A.mean())          <span class="comment"># 7.5</span></span><br><span class="line">print(np.average(A))     <span class="comment"># 7.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 中位数</span></span><br><span class="line">print(A.median())        <span class="comment"># 7.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 累加</span></span><br><span class="line">print(np.cumsum(A)) 	 <span class="comment"># [2 5 9 14 20 27 35 44 54 65 77 90]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 累差</span></span><br><span class="line">print(np.diff(A))   </span><br><span class="line"><span class="comment"># [[1 1 1]</span></span><br><span class="line"><span class="comment">#  [1 1 1]</span></span><br><span class="line"><span class="comment">#  [1 1 1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出非0的数</span></span><br><span class="line">print(np.nonzero(A))    </span><br><span class="line"><span class="comment"># (array([0,0,0,0,1,1,1,1,2,2,2,2]),array([0,1,2,3,0,1,2,3,0,1,2,3]))</span></span><br><span class="line"><span class="comment"># 左边为行数，右边为列数</span></span><br></pre></td></tr></table></figure>

<p>同样的，我们可以对所有元素进行仿照列表一样的排序操作，但这里的排序函数仍然仅针对每一行进行从小到大排序操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">14</span>, <span class="number">2</span>, <span class="number">-1</span>).reshape((<span class="number">3</span>,<span class="number">4</span>)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># array([[14, 13, 12, 11],</span></span><br><span class="line"><span class="comment">#       [10,  9,  8,  7],</span></span><br><span class="line"><span class="comment">#       [ 6,  5,  4,  3]])</span></span><br><span class="line"></span><br><span class="line">print(np.sort(A))    </span><br><span class="line"></span><br><span class="line"><span class="comment"># array([[11,12,13,14]</span></span><br><span class="line"><span class="comment">#        [ 7, 8, 9,10]</span></span><br><span class="line"><span class="comment">#        [ 3, 4, 5, 6]])</span></span><br></pre></td></tr></table></figure>

<p>矩阵的转置有两种表示方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(np.transpose(A))    </span><br><span class="line">print(A.T)</span><br><span class="line"></span><br><span class="line"><span class="comment"># array([[14,10, 6]</span></span><br><span class="line"><span class="comment">#        [13, 9, 5]</span></span><br><span class="line"><span class="comment">#        [12, 8, 4]</span></span><br><span class="line"><span class="comment">#        [11, 7, 3]])</span></span><br><span class="line"><span class="comment"># array([[14,10, 6]</span></span><br><span class="line"><span class="comment">#        [13, 9, 5]</span></span><br><span class="line"><span class="comment">#        [12, 8, 4]</span></span><br><span class="line"><span class="comment">#        [11, 7, 3]])</span></span><br></pre></td></tr></table></figure>

<p>特别的，在Numpy中具有<code>clip()</code>函数，例子如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(A)</span><br><span class="line"><span class="comment"># array([[14,13,12,11]</span></span><br><span class="line"><span class="comment">#        [10, 9, 8, 7]</span></span><br><span class="line"><span class="comment">#        [ 6, 5, 4, 3]])</span></span><br><span class="line"></span><br><span class="line">print(np.clip(A,<span class="number">5</span>,<span class="number">9</span>))    </span><br><span class="line"><span class="comment"># array([[ 9, 9, 9, 9]</span></span><br><span class="line"><span class="comment">#        [ 9, 9, 8, 7]</span></span><br><span class="line"><span class="comment">#        [ 6, 5, 5, 5]])</span></span><br></pre></td></tr></table></figure>

<p>这个函数的格式是<code>clip(Array,Array_min,Array_max)</code>，顾名思义，<code>Array</code>指的是将要被执行用的矩阵，而后面的最小值最大值则用于让函数判断矩阵中元素是否有比最小值小的或者比最大值大的元素，并将这些指定的元素转换为最小值或者最大值。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>我们都知道，在元素列表或者数组中，我们可以用如同<code>a[2]</code>一样的表示方法，同样的，在Numpy中也有相对应的表示方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">3</span>,<span class="number">15</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># array([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])</span></span><br><span class="line"></span><br><span class="line">print(A[<span class="number">3</span>])    <span class="comment"># 6</span></span><br></pre></td></tr></table></figure>

<p>让我们将矩阵转换为二维的，此时进行同样的操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">3</span>,<span class="number">15</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[ 3,  4,  5,  6]</span></span><br><span class="line"><span class="string">       [ 7,  8,  9, 10]</span></span><br><span class="line"><span class="string">       [11, 12, 13, 14]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">         </span><br><span class="line">print(A[<span class="number">2</span>])         </span><br><span class="line"><span class="comment"># [11 12 13 14]</span></span><br></pre></td></tr></table></figure>

<p>实际上这时的<code>A[2]</code>对应的就是矩阵<code>A</code>中第三行(从0开始算第一行)的所有元素。</p>
<p>如果你想要表示具体的单个元素，可以仿照上述的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(A[<span class="number">1</span>][<span class="number">1</span>])      <span class="comment"># 8</span></span><br><span class="line"></span><br><span class="line">print(A[<span class="number">1</span>, <span class="number">1</span>])      <span class="comment"># 8</span></span><br></pre></td></tr></table></figure>

<p>在Python的 list 中，我们可以利用<code>:</code>对一定范围内的元素进行切片操作，在Numpy中我们依然可以给出相应的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(A[<span class="number">1</span>, <span class="number">1</span>:<span class="number">3</span>])    <span class="comment"># [8 9]</span></span><br></pre></td></tr></table></figure>

<p>这一表示形式即针对第二行中第2到第4列元素进行切片输出（不包含第4列）。 此时我们适当的利用for函数进行打印：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> A:</span><br><span class="line">    print(row)</span><br><span class="line"><span class="string">"""    </span></span><br><span class="line"><span class="string">[ 3,  4,  5, 6]</span></span><br><span class="line"><span class="string">[ 7,  8,  9, 10]</span></span><br><span class="line"><span class="string">[11, 12, 13, 14]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>此时它会逐行进行打印操作。如果想进行逐列打印，就需要稍稍变化一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> A.T:</span><br><span class="line">    print(column)</span><br><span class="line"><span class="string">"""  </span></span><br><span class="line"><span class="string">[ 3,  7,  11]</span></span><br><span class="line"><span class="string">[ 4,  8,  12]</span></span><br><span class="line"><span class="string">[ 5,  9,  13]</span></span><br><span class="line"><span class="string">[ 6, 10,  14]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>上述表示方法即对A进行转置，再将得到的矩阵逐行输出即可得到原矩阵的逐列输出。</p>
<p>最后依然说一些关于迭代输出的问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.arange(<span class="number">3</span>,<span class="number">15</span>).reshape((<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">         </span><br><span class="line">print(A.flatten())   </span><br><span class="line"><span class="comment"># array([3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> A.flat:</span><br><span class="line">    print(item)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line">……</span><br><span class="line"><span class="comment"># 14</span></span><br></pre></td></tr></table></figure>

<p>这一脚本中的<code>flatten</code>是一个展开性质的函数，将多维的矩阵进行展开成1行的数列。而<code>flat</code>是一个迭代器，本身是一个<code>object</code>属性。</p>
<h3 id="array合并"><a href="#array合并" class="headerlink" title="array合并"></a>array合并</h3><h4 id="np-vstack"><a href="#np-vstack" class="headerlink" title="np.vstack()"></a>np.vstack()</h4><p>对于一个<code>array</code>的合并，我们可以想到按行、按列等多种方式进行合并。首先先看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])</span><br><span class="line">B = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])</span><br><span class="line">         </span><br><span class="line">print(np.vstack((A,B)))    <span class="comment"># vertical stack</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1,1,1]</span></span><br><span class="line"><span class="string"> [2,2,2]]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p><code>vertical stack</code>本身属于一种上下合并，即对括号中的两个整体进行对应操作。此时我们对组合而成的矩阵进行属性探究：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C = np.vstack((A,B))      </span><br><span class="line">print(A.shape,C.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># (3,) (2,3)</span></span><br></pre></td></tr></table></figure>

<h4 id="np-hstack"><a href="#np-hstack" class="headerlink" title="np.hstack()"></a>np.hstack()</h4><p>利用<code>shape</code>函数可以让我们很容易地知道<code>A</code>和<code>C</code>的属性，从打印出的结果来看，<code>A</code>仅仅是一个拥有3项元素的数组（数列），而合并后得到的<code>C</code>是一个2行3列的矩阵。</p>
<p>介绍完了上下合并，我们来说说左右合并：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D = np.hstack((A,B))       <span class="comment"># horizontal stack</span></span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line"><span class="comment"># [1,1,1,2,2,2]</span></span><br><span class="line"></span><br><span class="line">print(A.shape,D.shape)</span><br><span class="line"><span class="comment"># (3,) (6,)</span></span><br></pre></td></tr></table></figure>

<p>通过打印出的结果可以看出：<code>D</code>本身来源于<code>A</code>，<code>B</code>两个数列的左右合并，而且新生成的<code>D</code>本身也是一个含有6项元素的序列。</p>
<h4 id="np-newaxis"><a href="#np-newaxis" class="headerlink" title="np.newaxis()"></a>np.newaxis()</h4><p>说完了<code>array</code>的合并，我们稍稍提及一下前一节中转置操作，如果面对如同前文所述的<code>A</code>序列， 转置操作便很有可能无法对其进行转置（因为<code>A</code>并不是矩阵的属性），此时就需要我们借助其他的函数操作进行转置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">print(A[np.newaxis,:]) <span class="comment"># 在行上加一个维度</span></span><br><span class="line"><span class="comment"># [[1 1 1]]</span></span><br><span class="line"></span><br><span class="line">print(A[:,np.newaxis]) <span class="comment"># 在列上加一个维度</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1]</span></span><br><span class="line"><span class="string">[1]</span></span><br><span class="line"><span class="string">[1]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(A[np.newaxis,:].shape)</span><br><span class="line"><span class="comment"># (1,3)</span></span><br><span class="line"></span><br><span class="line">print(A[:,np.newaxis].shape)</span><br><span class="line"><span class="comment"># (3,1)</span></span><br></pre></td></tr></table></figure>

<p>此时我们便将具有3个元素的<code>array</code>转换为了1行3列以及3行1列的矩阵了。</p>
<p>结合着上面的知识，我们把它综合起来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>])[:,np.newaxis]</span><br><span class="line">B = np.array([<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>])[:,np.newaxis]</span><br><span class="line">         </span><br><span class="line">C = np.vstack((A,B))   <span class="comment"># vertical stack</span></span><br><span class="line">D = np.hstack((A,B))   <span class="comment"># horizontal stack</span></span><br><span class="line"></span><br><span class="line">print(C)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1]</span></span><br><span class="line"><span class="string"> [1]</span></span><br><span class="line"><span class="string"> [1]</span></span><br><span class="line"><span class="string"> [2]</span></span><br><span class="line"><span class="string"> [2]</span></span><br><span class="line"><span class="string"> [2]]</span></span><br><span class="line"><span class="string"> """</span></span><br><span class="line">print(D)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[[1 2]</span></span><br><span class="line"><span class="string">[1 2]</span></span><br><span class="line"><span class="string">[1 2]]</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(A.shape,C.shape)</span><br><span class="line"><span class="comment"># (3, 1) (6, 1)</span></span><br><span class="line"></span><br><span class="line">print(A.shape,D.shape)</span><br><span class="line"><span class="comment"># (3,1) (3,2)</span></span><br></pre></td></tr></table></figure>

<h4 id="np-concatenate"><a href="#np-concatenate" class="headerlink" title="np.concatenate()"></a>np.concatenate()</h4><p>当你的合并操作需要针对多个矩阵或序列时，借助<code>concatenate</code>函数可能会让你使用起来比前述的函数更加方便：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">C = np.concatenate((A,B,B,A),axis=<span class="number">0</span>)	<span class="comment"># 纵向</span></span><br><span class="line"></span><br><span class="line">print(C)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [2],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1],</span></span><br><span class="line"><span class="string">       [1]])</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">D = np.concatenate((A,B,B,A),axis=<span class="number">1</span>)	<span class="comment"># 横向</span></span><br><span class="line"></span><br><span class="line">print(D)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1, 2, 2, 1],</span></span><br><span class="line"><span class="string">       [1, 2, 2, 1],</span></span><br><span class="line"><span class="string">       [1, 2, 2, 1]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p><code>axis</code>参数很好的控制了矩阵的纵向或是横向打印，相比较<code>vstack</code>和<code>hstack</code>函数显得更加方便。</p>
<h3 id="array分割"><a href="#array分割" class="headerlink" title="array分割"></a>array分割</h3><h4 id="创建数据"><a href="#创建数据" class="headerlink" title="创建数据"></a>创建数据</h4><p>建立3行4列的Array</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">A = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">print(A)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[ 0,  1,  2,  3],</span></span><br><span class="line"><span class="string">    [ 4,  5,  6,  7],</span></span><br><span class="line"><span class="string">    [ 8,  9, 10, 11]])</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="纵向分割"><a href="#纵向分割" class="headerlink" title="纵向分割"></a>纵向分割</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(np.split(A, <span class="number">2</span>, axis=<span class="number">1</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1],</span></span><br><span class="line"><span class="string">        [4, 5],</span></span><br><span class="line"><span class="string">        [8, 9]]), </span></span><br><span class="line"><span class="string"> array([[ 2,  3],</span></span><br><span class="line"><span class="string">        [ 6,  7],</span></span><br><span class="line"><span class="string">        [ 10, 11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="横向分割"><a href="#横向分割" class="headerlink" title="横向分割"></a>横向分割</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.split(A, <span class="number">3</span>, axis=<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span></span><br></pre></td></tr></table></figure>

<h4 id="错误的分割"><a href="#错误的分割" class="headerlink" title="错误的分割"></a>错误的分割</h4><p>范例的Array只有4列，只能等量对分，因此输入以上程序代码后Python就会报错。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(np.split(A, <span class="number">3</span>, axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># ValueError: array split does not result in an equal division</span></span><br></pre></td></tr></table></figure>

<p>为了解决这种情况, 我们会有下面这种方式.</p>
<h4 id="不等量的分割"><a href="#不等量的分割" class="headerlink" title="不等量的分割"></a>不等量的分割</h4><p>在机器学习时经常会需要将数据做不等量的分割，因此解决办法为<code>np.array_split()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(np.array_split(A, <span class="number">3</span>, axis=<span class="number">1</span>))</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1],</span></span><br><span class="line"><span class="string">        [4, 5],</span></span><br><span class="line"><span class="string">        [8, 9]]), </span></span><br><span class="line"><span class="string"> array([[ 2],</span></span><br><span class="line"><span class="string">        [ 6],</span></span><br><span class="line"><span class="string">        [10]]), </span></span><br><span class="line"><span class="string"> array([[ 3],</span></span><br><span class="line"><span class="string">        [ 7],</span></span><br><span class="line"><span class="string">        [11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="其他的分割方式"><a href="#其他的分割方式" class="headerlink" title="其他的分割方式"></a>其他的分割方式</h4><p>在Numpy里还有<code>np.vsplit()</code>与横<code>np.hsplit()</code>方式可用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">print(np.vsplit(A, <span class="number">3</span>)) <span class="comment">#等于 print(np.split(A, 3, axis=0))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># [array([[0, 1, 2, 3]]), array([[4, 5, 6, 7]]), array([[ 8,  9, 10, 11]])]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(np.hsplit(A, <span class="number">2</span>)) <span class="comment">#等于 print(np.split(A, 2, axis=1))</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[array([[0, 1],</span></span><br><span class="line"><span class="string">       [4, 5],</span></span><br><span class="line"><span class="string">       [8, 9]]), array([[ 2,  3],</span></span><br><span class="line"><span class="string">        [ 6,  7],</span></span><br><span class="line"><span class="string">        [10, 11]])]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>



<h3 id="Numpy-copy-amp-deep-copy"><a href="#Numpy-copy-amp-deep-copy" class="headerlink" title="Numpy copy &amp; deep copy"></a>Numpy copy &amp; deep copy</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="= 浅拷贝"></a>= 浅拷贝</h4><p>首先 <code>import numpy</code> 并建立变量, 给变量赋值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># array([0, 1, 2, 3])</span></span><br><span class="line"></span><br><span class="line">b = a</span><br><span class="line">c = a</span><br><span class="line">d = b</span><br></pre></td></tr></table></figure>

<p>改变<code>a</code>的第一个值，<code>b</code>、<code>c</code>、<code>d</code>的第一个值也会同时改变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># array([11,  1,  2,  3])</span></span><br></pre></td></tr></table></figure>

<p>确认<code>b</code>、<code>c</code>、<code>d</code>是否与<code>a</code>相同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b <span class="keyword">is</span> a  <span class="comment"># True</span></span><br><span class="line">c <span class="keyword">is</span> a  <span class="comment"># True</span></span><br><span class="line">d <span class="keyword">is</span> a  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>同样更改<code>d</code>的值，<code>a</code>、<code>b</code>、<code>c</code>也会改变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="number">1</span>:<span class="number">3</span>] = [<span class="number">22</span>, <span class="number">33</span>]   <span class="comment"># array([11, 22, 33,  3])</span></span><br><span class="line">print(a)            <span class="comment"># array([11, 22, 33,  3])</span></span><br><span class="line">print(b)            <span class="comment"># array([11, 22, 33,  3])</span></span><br><span class="line">print(c)            <span class="comment"># array([11, 22, 33,  3])</span></span><br></pre></td></tr></table></figure>

<h4 id="copy-深拷贝"><a href="#copy-深拷贝" class="headerlink" title="copy() 深拷贝"></a>copy() 深拷贝</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = a.copy()    <span class="comment"># deep copy</span></span><br><span class="line">print(b)        <span class="comment"># array([11, 22, 33,  3])</span></span><br><span class="line">a[<span class="number">3</span>] = <span class="number">44</span></span><br><span class="line">print(a)        <span class="comment"># array([11, 22, 33, 44])</span></span><br><span class="line">print(b)        <span class="comment"># array([11, 22, 33,  3])</span></span><br></pre></td></tr></table></figure>

<p>此时<code>a</code>与<code>b</code>已经没有关联。</p>
<h2 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>如果用 python 的列表和字典来作比较, 那么可以说 Numpy 是列表形式的，没有数值标签，而 Pandas 就是字典形式。Pandas是基于Numpy构建的，让Numpy为中心的应用变得更加简单。</p>
<h4 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,np.nan,<span class="number">44</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(s)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">0     1.0</span></span><br><span class="line"><span class="string">1     3.0</span></span><br><span class="line"><span class="string">2     6.0</span></span><br><span class="line"><span class="string">3     NaN</span></span><br><span class="line"><span class="string">4    44.0</span></span><br><span class="line"><span class="string">5     1.0</span></span><br><span class="line"><span class="string">dtype: float64</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p><code>Series</code>的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引。于是会自动创建一个0到N-1（N为长度）的整数型索引。</p>
<h4 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20160101'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>),index=dates,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line">print(df)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                   a         b         c         d</span></span><br><span class="line"><span class="string">2016-01-01 -0.253065 -2.071051 -0.640515  0.613663</span></span><br><span class="line"><span class="string">2016-01-02 -1.147178  1.532470  0.989255 -0.499761</span></span><br><span class="line"><span class="string">2016-01-03  1.221656 -2.390171  1.862914  0.778070</span></span><br><span class="line"><span class="string">2016-01-04  1.473877 -0.046419  0.610046  0.204672</span></span><br><span class="line"><span class="string">2016-01-05 -1.584752 -0.700592  1.487264 -1.778293</span></span><br><span class="line"><span class="string">2016-01-06  0.633675 -1.414157 -0.277066 -0.442545</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p><code>DataFrame</code>是一个表格型的数据结构，它包含有一组有序的列，每列可以是不同的值类型（数值，字符串，布尔值等）。<code>DataFrame</code>既有行索引也有列索引， 它可以被看做由<code>Series</code>组成的大字典。</p>
<p>我们可以根据每一个不同的索引来挑选数据, 比如挑选 <code>b</code> 的元素:</p>
<h4 id="DataFrame-的一些简单运用"><a href="#DataFrame-的一些简单运用" class="headerlink" title="DataFrame 的一些简单运用"></a>DataFrame 的一些简单运用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">print(df[<span class="string">'b'</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">2016-01-01   -2.071051</span></span><br><span class="line"><span class="string">2016-01-02    1.532470</span></span><br><span class="line"><span class="string">2016-01-03   -2.390171</span></span><br><span class="line"><span class="string">2016-01-04   -0.046419</span></span><br><span class="line"><span class="string">2016-01-05   -0.700592</span></span><br><span class="line"><span class="string">2016-01-06   -1.414157</span></span><br><span class="line"><span class="string">Freq: D, Name: b, dtype: float64</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>我们在创建一组没有给定行标签和列标签的数据 <code>df1</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">df1 &#x3D; pd.DataFrame(np.arange(12).reshape((3,4)))</span><br><span class="line">print(df1)</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">   0  1   2   3</span><br><span class="line">0  0  1   2   3</span><br><span class="line">1  4  5   6   7</span><br><span class="line">2  8  9  10  11</span><br><span class="line">&quot;&quot;&quot;</span><br></pre></td></tr></table></figure>

<p>这样,他就会采取默认的从0开始 index. 还有一种生成 <code>df</code> 的方法, 如下 <code>df2</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'A'</span> : <span class="number">1.</span>,</span><br><span class="line">                    <span class="string">'B'</span> : pd.Timestamp(<span class="string">'20130102'</span>),</span><br><span class="line">                    <span class="string">'C'</span> : pd.Series(<span class="number">1</span>,index=list(range(<span class="number">4</span>)),dtype=<span class="string">'float32'</span>),</span><br><span class="line">                    <span class="string">'D'</span> : np.array([<span class="number">3</span>] * <span class="number">4</span>,dtype=<span class="string">'int32'</span>),</span><br><span class="line">                    <span class="string">'E'</span> : pd.Categorical([<span class="string">"test"</span>,<span class="string">"train"</span>,<span class="string">"test"</span>,<span class="string">"train"</span>]),</span><br><span class="line">                    <span class="string">'F'</span> : <span class="string">'foo'</span>&#125;)</span><br><span class="line">                    </span><br><span class="line">print(df2)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     A          B    C  D      E    F</span></span><br><span class="line"><span class="string">0  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">1  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">2  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">3  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>这种方法能对每一列的数据进行特殊对待. 如果想要查看数据中的类型, 我们可以用 <code>dtype</code> 这个属性:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(df2.dtypes)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">df2.dtypes</span></span><br><span class="line"><span class="string">A           float64</span></span><br><span class="line"><span class="string">B    datetime64[ns]</span></span><br><span class="line"><span class="string">C           float32</span></span><br><span class="line"><span class="string">D             int32</span></span><br><span class="line"><span class="string">E          category</span></span><br><span class="line"><span class="string">F            object</span></span><br><span class="line"><span class="string">dtype: object</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>如果想看对列的序号:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(df2.index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Int64Index([0, 1, 2, 3], dtype='int64')</span></span><br></pre></td></tr></table></figure>

<p>同样, 每种数据的名称也能看到:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(df2.columns)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Index(['A', 'B', 'C', 'D', 'E', 'F'], dtype='object')</span></span><br></pre></td></tr></table></figure>

<p>如果只想看所有<code>df2</code>的值:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(df2.values)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">array([[1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'test', 'foo'],</span></span><br><span class="line"><span class="string">       [1.0, Timestamp('2013-01-02 00:00:00'), 1.0, 3, 'train', 'foo']], dtype=object)</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>想知道数据的总结, 可以用 <code>describe()</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">df2.describe()</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">         A    C    D</span></span><br><span class="line"><span class="string">count  4.0  4.0  4.0</span></span><br><span class="line"><span class="string">mean   1.0  1.0  3.0</span></span><br><span class="line"><span class="string">std    0.0  0.0  0.0</span></span><br><span class="line"><span class="string">min    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">25%    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">50%    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">75%    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">max    1.0  1.0  3.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>如果想翻转数据, <code>transpose</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">print(df2.T)</span><br><span class="line"></span><br><span class="line"><span class="string">"""                   </span></span><br><span class="line"><span class="string">0                    1                    2  \</span></span><br><span class="line"><span class="string">A                    1                    1                    1   </span></span><br><span class="line"><span class="string">B  2013-01-02 00:00:00  2013-01-02 00:00:00  2013-01-02 00:00:00   </span></span><br><span class="line"><span class="string">C                    1                    1                    1   </span></span><br><span class="line"><span class="string">D                    3                    3                    3   </span></span><br><span class="line"><span class="string">E                 test                train                 test   </span></span><br><span class="line"><span class="string">F                  foo                  foo                  foo   </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                     3  </span></span><br><span class="line"><span class="string">A                    1  </span></span><br><span class="line"><span class="string">B  2013-01-02 00:00:00  </span></span><br><span class="line"><span class="string">C                    1  </span></span><br><span class="line"><span class="string">D                    3  </span></span><br><span class="line"><span class="string">E                train  </span></span><br><span class="line"><span class="string">F                  foo  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>如果想对数据的 <code>index</code> 进行排序并输出:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(df2.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     F      E  D    C          B    A</span></span><br><span class="line"><span class="string">0  foo   test  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">1  foo  train  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">2  foo   test  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">3  foo  train  3  1.0 2013-01-02  1.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>如果是对数据 值 排序输出:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(df2.sort_values(by=<span class="string">'B'</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     A          B    C  D      E    F</span></span><br><span class="line"><span class="string">0  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">1  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">2  1.0 2013-01-02  1.0  3   test  foo</span></span><br><span class="line"><span class="string">3  1.0 2013-01-02  1.0  3  train  foo</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h3 id="选择数据"><a href="#选择数据" class="headerlink" title="选择数据"></a>选择数据</h3><p>我们建立了一个 6X4 的矩阵数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20130101'</span>, periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates, columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B   C   D</span></span><br><span class="line"><span class="string">2013-01-01   0   1   2   3</span></span><br><span class="line"><span class="string">2013-01-02   4   5   6   7</span></span><br><span class="line"><span class="string">2013-01-03   8   9  10  11</span></span><br><span class="line"><span class="string">2013-01-04  12  13  14  15</span></span><br><span class="line"><span class="string">2013-01-05  16  17  18  19</span></span><br><span class="line"><span class="string">2013-01-06  20  21  22  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="简单的筛选"><a href="#简单的筛选" class="headerlink" title="简单的筛选"></a>简单的筛选</h4><p>如果我们想选取<code>DataFrame</code>中的数据，下面描述了两种途径, 他们都能达到同一个目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(df[<span class="string">'A'</span>])</span><br><span class="line">print(df.A)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">2013-01-01     0</span></span><br><span class="line"><span class="string">2013-01-02     4</span></span><br><span class="line"><span class="string">2013-01-03     8</span></span><br><span class="line"><span class="string">2013-01-04    12</span></span><br><span class="line"><span class="string">2013-01-05    16</span></span><br><span class="line"><span class="string">2013-01-06    20</span></span><br><span class="line"><span class="string">Freq: D, Name: A, dtype: int64</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>让选择跨越多行或多列:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">print(df[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"> </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            A  B   C   D</span></span><br><span class="line"><span class="string">2013-01-01  0  1   2   3</span></span><br><span class="line"><span class="string">2013-01-02  4  5   6   7</span></span><br><span class="line"><span class="string">2013-01-03  8  9  10  11</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(df[<span class="string">'20130102'</span>:<span class="string">'20130104'</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A   B   C   D</span></span><br><span class="line"><span class="string">2013-01-02   4   5   6   7</span></span><br><span class="line"><span class="string">2013-01-03   8   9  10  11</span></span><br><span class="line"><span class="string">2013-01-04  12  13  14  15</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>如果<code>df[3:3]</code>将会是一个空对象。后者选择<code>20130102</code>到<code>20130104</code>标签之间的数据，并且包括这两个标签。</p>
<h4 id="根据标签-loc"><a href="#根据标签-loc" class="headerlink" title="根据标签 loc"></a>根据标签 loc</h4><p>同样我们可以使用<strong>标签</strong>来选择数据 <code>loc</code>, 本例子主要通过标签名字选择某一行数据， 或者通过选择某行或者所有行（<code>:</code>代表所有行）然后选其中某一列或几列数据。:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">print(df.loc[<span class="string">'20130102'</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A    4</span></span><br><span class="line"><span class="string">B    5</span></span><br><span class="line"><span class="string">C    6</span></span><br><span class="line"><span class="string">D    7</span></span><br><span class="line"><span class="string">Name: 2013-01-02 00:00:00, dtype: int64</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(df.loc[:,[<span class="string">'A'</span>,<span class="string">'B'</span>]]) </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B</span></span><br><span class="line"><span class="string">2013-01-01   0   1</span></span><br><span class="line"><span class="string">2013-01-02   4   5</span></span><br><span class="line"><span class="string">2013-01-03   8   9</span></span><br><span class="line"><span class="string">2013-01-04  12  13</span></span><br><span class="line"><span class="string">2013-01-05  16  17</span></span><br><span class="line"><span class="string">2013-01-06  20  21</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">print(df.loc[<span class="string">'20130102'</span>,[<span class="string">'A'</span>,<span class="string">'B'</span>]])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">A    4</span></span><br><span class="line"><span class="string">B    5</span></span><br><span class="line"><span class="string">Name: 2013-01-02 00:00:00, dtype: int64</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="根据序列-iloc"><a href="#根据序列-iloc" class="headerlink" title="根据序列 iloc"></a>根据序列 iloc</h4><p>另外我们可以采用<strong>位置</strong>进行选择 <code>iloc</code>, 在这里我们可以通过位置选择在不同情况下所需要的数据例如选某一个，连续选或者跨行选等操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第3行第1位</span></span><br><span class="line">print(df.iloc[<span class="number">3</span>,<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 13</span></span><br><span class="line"></span><br><span class="line">print(df.iloc[<span class="number">3</span>:<span class="number">5</span>,<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             B   C</span></span><br><span class="line"><span class="string">2013-01-04  13  14</span></span><br><span class="line"><span class="string">2013-01-05  17  18</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不连续的筛选</span></span><br><span class="line">print(df.iloc[[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>],<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             B   C</span></span><br><span class="line"><span class="string">2013-01-02   5   6</span></span><br><span class="line"><span class="string">2013-01-04  13  14</span></span><br><span class="line"><span class="string">2013-01-06  21  22</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>在这里我们可以通过位置选择在不同情况下所需要的数据, 例如选某一个，连续选或者跨行选等操作。</p>
<h4 id="根据混合的这两种-ix"><a href="#根据混合的这两种-ix" class="headerlink" title="根据混合的这两种 ix"></a>根据混合的这两种 ix</h4><p>当然我们可以采用<strong>混合</strong>选择 <code>ix</code>, 其中选择’A’和’C’的两列，并选择前三行的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新版中已弃用</span></span><br><span class="line">print(df.ix[:<span class="number">3</span>,[<span class="string">'A'</span>,<span class="string">'C'</span>]])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            A   C</span></span><br><span class="line"><span class="string">2013-01-01  0   2</span></span><br><span class="line"><span class="string">2013-01-02  4   6</span></span><br><span class="line"><span class="string">2013-01-03  8  10</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="通过判断的筛选"><a href="#通过判断的筛选" class="headerlink" title="通过判断的筛选"></a>通过判断的筛选</h4><p>最后我们可以采用判断指令 (Boolean indexing) 进行选择. 我们可以约束某项条件然后选择出当前所有数据.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">print(df[df.A&gt;<span class="number">8</span>])</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B   C   D</span></span><br><span class="line"><span class="string">2013-01-04  12  13  14  15</span></span><br><span class="line"><span class="string">2013-01-05  16  17  18  19</span></span><br><span class="line"><span class="string">2013-01-06  20  21  22  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>下节我们将会讲到Pandas中如何设置值。</p>
<h3 id="pandas设置值"><a href="#pandas设置值" class="headerlink" title="pandas设置值"></a>pandas设置值</h3><h4 id="创建数据-1"><a href="#创建数据-1" class="headerlink" title="创建数据"></a>创建数据</h4><p>我们可以根据自己的需求, 用 pandas 进行更改数据里面的值, 或者加上一些空的,或者有数值的列.</p>
<p>首先建立了一个 6X4 的矩阵数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20130101'</span>, periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates, columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A   B   C   D</span></span><br><span class="line"><span class="string">2013-01-01   0   1   2   3</span></span><br><span class="line"><span class="string">2013-01-02   4   5   6   7</span></span><br><span class="line"><span class="string">2013-01-03   8   9  10  11</span></span><br><span class="line"><span class="string">2013-01-04  12  13  14  15</span></span><br><span class="line"><span class="string">2013-01-05  16  17  18  19</span></span><br><span class="line"><span class="string">2013-01-06  20  21  22  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="根据位置设置-loc-和-iloc"><a href="#根据位置设置-loc-和-iloc" class="headerlink" title="根据位置设置 loc 和 iloc"></a>根据位置设置 loc 和 iloc</h4><p>我们可以利用<strong>索引</strong>或者<strong>标签</strong>确定需要修改值的位置。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df.iloc[<span class="number">2</span>,<span class="number">2</span>] = <span class="number">1111</span></span><br><span class="line">df.loc[<span class="string">'20130101'</span>,<span class="string">'B'</span>] = <span class="number">2222</span></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A     B     C   D</span></span><br><span class="line"><span class="string">2013-01-01   0  2222     2   3</span></span><br><span class="line"><span class="string">2013-01-02   4     5     6   7</span></span><br><span class="line"><span class="string">2013-01-03   8     9  1111  11</span></span><br><span class="line"><span class="string">2013-01-04  12    13    14  15</span></span><br><span class="line"><span class="string">2013-01-05  16    17    18  19</span></span><br><span class="line"><span class="string">2013-01-06  20    21    22  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="根据条件设置"><a href="#根据条件设置" class="headerlink" title="根据条件设置"></a>根据条件设置</h4><p>如果现在的判断条件是这样, 我们想要更改<code>B</code>中的数, 而更改的位置是取决于 <code>A</code> 的. 对于<code>A</code>大于4的位置. 更改<code>B</code>在相应位置上的数为0.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">df[df.A&gt;<span class="number">16</span>] = <span class="number">0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A     B     C   D</span></span><br><span class="line"><span class="string">2013-01-01   0  2222     2   3</span></span><br><span class="line"><span class="string">2013-01-02   4     5     6   7</span></span><br><span class="line"><span class="string">2013-01-03   8     9  1111  11</span></span><br><span class="line"><span class="string">2013-01-04  12    13    14  15</span></span><br><span class="line"><span class="string">2013-01-05  16    17    18  19</span></span><br><span class="line"><span class="string">2013-01-06   0     0     0   0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">df.B[df.A&gt;<span class="number">4</span>] = <span class="number">0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                A     B     C   D</span></span><br><span class="line"><span class="string">2013-01-01   0  2222     2   3</span></span><br><span class="line"><span class="string">2013-01-02   4     5     6   7</span></span><br><span class="line"><span class="string">2013-01-03   8     0  1111  11</span></span><br><span class="line"><span class="string">2013-01-04  12     0    14  15</span></span><br><span class="line"><span class="string">2013-01-05  16     0    18  19</span></span><br><span class="line"><span class="string">2013-01-06  20     0    22  23 </span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="按行或列设置"><a href="#按行或列设置" class="headerlink" title="按行或列设置"></a>按行或列设置</h4><p>如果对整列做批处理, 加上一列 ‘F’, 并将 <code>F</code> 列全改为 <code>NaN</code>, 如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'F'</span>] = np.nan</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A     B     C   D   F</span></span><br><span class="line"><span class="string">2013-01-01   0  2222     2   3 NaN</span></span><br><span class="line"><span class="string">2013-01-02   4     5     6   7 NaN</span></span><br><span class="line"><span class="string">2013-01-03   8     0  1111  11 NaN</span></span><br><span class="line"><span class="string">2013-01-04  12     0    14  15 NaN</span></span><br><span class="line"><span class="string">2013-01-05  16     0    18  19 NaN</span></span><br><span class="line"><span class="string">2013-01-06  20     0    22  23 NaN</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h4><p>用上面的方法也可以加上 <code>Series</code> 序列（但是长度必须对齐）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df[<span class="string">'E'</span>] = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], index=pd.date_range(<span class="string">'20130101'</span>,periods=<span class="number">6</span>)) </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A     B     C   D   F  E</span></span><br><span class="line"><span class="string">2013-01-01   0  2222     2   3 NaN  1</span></span><br><span class="line"><span class="string">2013-01-02   4     5     6   7 NaN  2</span></span><br><span class="line"><span class="string">2013-01-03   8     0  1111  11 NaN  3</span></span><br><span class="line"><span class="string">2013-01-04  12     0    14  15 NaN  4</span></span><br><span class="line"><span class="string">2013-01-05  16     0    18  19 NaN  5</span></span><br><span class="line"><span class="string">2013-01-06  20     0    22  23 NaN  6</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>这样我们大概学会了如何对<code>DataFrame</code>中在自己想要的地方赋值或者增加数据。 下次课会将pandas如何处理丢失数据的过程。</p>
<h3 id="Pandas-处理丢失数据"><a href="#Pandas-处理丢失数据" class="headerlink" title="Pandas 处理丢失数据"></a>Pandas 处理丢失数据</h3><h4 id="创建含-NaN-的矩阵"><a href="#创建含-NaN-的矩阵" class="headerlink" title="创建含 NaN 的矩阵"></a>创建含 NaN 的矩阵</h4><p>有时候我们导入或处理数据, 会产生一些空的或者是 <code>NaN</code> 数据,如何删除或者是填补这些 <code>NaN</code> 数据就是我们今天所要提到的内容.</p>
<p>建立了一个6X4的矩阵数据并且把两个位置置为空.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20130101'</span>, periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.arange(<span class="number">24</span>).reshape((<span class="number">6</span>,<span class="number">4</span>)),index=dates, columns=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>])</span><br><span class="line">df.iloc[<span class="number">0</span>,<span class="number">1</span>] = np.nan</span><br><span class="line">df.iloc[<span class="number">1</span>,<span class="number">2</span>] = np.nan</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A     B     C   D</span></span><br><span class="line"><span class="string">2013-01-01   0   NaN   2.0   3</span></span><br><span class="line"><span class="string">2013-01-02   4   5.0   NaN   7</span></span><br><span class="line"><span class="string">2013-01-03   8   9.0  10.0  11</span></span><br><span class="line"><span class="string">2013-01-04  12  13.0  14.0  15</span></span><br><span class="line"><span class="string">2013-01-05  16  17.0  18.0  19</span></span><br><span class="line"><span class="string">2013-01-06  20  21.0  22.0  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="pd-dropna"><a href="#pd-dropna" class="headerlink" title="pd.dropna()"></a>pd.dropna()</h4><p>如果想直接去掉有 <code>NaN</code> 的行或列, 可以使用 <code>dropna</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">df.dropna(</span><br><span class="line">    axis=<span class="number">0</span>,     <span class="comment"># 0: 对行进行操作; 1: 对列进行操作</span></span><br><span class="line">    how=<span class="string">'any'</span>   <span class="comment"># 'any': 只要存在 NaN 就 drop 掉; 'all': 必须全部是 NaN 才 drop </span></span><br><span class="line">    ) </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A     B     C   D</span></span><br><span class="line"><span class="string">2013-01-03   8   9.0  10.0  11</span></span><br><span class="line"><span class="string">2013-01-04  12  13.0  14.0  15</span></span><br><span class="line"><span class="string">2013-01-05  16  17.0  18.0  19</span></span><br><span class="line"><span class="string">2013-01-06  20  21.0  22.0  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="pd-fillna"><a href="#pd-fillna" class="headerlink" title="pd.fillna()"></a>pd.fillna()</h4><p>如果是将 <code>NaN</code> 的值用其他值代替, 比如代替成 <code>0</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(value=<span class="number">0</span>)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">             A     B     C   D</span></span><br><span class="line"><span class="string">2013-01-01   0   0.0   2.0   3</span></span><br><span class="line"><span class="string">2013-01-02   4   5.0   0.0   7</span></span><br><span class="line"><span class="string">2013-01-03   8   9.0  10.0  11</span></span><br><span class="line"><span class="string">2013-01-04  12  13.0  14.0  15</span></span><br><span class="line"><span class="string">2013-01-05  16  17.0  18.0  19</span></span><br><span class="line"><span class="string">2013-01-06  20  21.0  22.0  23</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h4 id="pd-isnull"><a href="#pd-isnull" class="headerlink" title="pd.isnull()"></a>pd.isnull()</h4><p>判断是否有缺失数据 <code>NaN</code>, 为 <code>True</code> 表示缺失数据:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df.isnull() </span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">                A      B      C      D</span></span><br><span class="line"><span class="string">2013-01-01  False   True  False  False</span></span><br><span class="line"><span class="string">2013-01-02  False  False   True  False</span></span><br><span class="line"><span class="string">2013-01-03  False  False  False  False</span></span><br><span class="line"><span class="string">2013-01-04  False  False  False  False</span></span><br><span class="line"><span class="string">2013-01-05  False  False  False  False</span></span><br><span class="line"><span class="string">2013-01-06  False  False  False  False</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>检测在数据中是否存在 <code>NaN</code>, 如果存在就返回 <code>True</code>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.any(df.isnull()) == <span class="literal">True</span>  </span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="Pandas-导入导出"><a href="#Pandas-导入导出" class="headerlink" title="Pandas 导入导出"></a>Pandas 导入导出</h3><p><code>pandas</code>可以读取与存取的资料格式有很多种，像<code>csv</code>、<code>excel</code>、<code>json</code>、<code>html</code>与<code>pickle</code>等…， 详细请看<a href="http://pandas.pydata.org/pandas-docs/stable/io.html" target="_blank" rel="noopener">官方说明文件</a></p>
<h4 id="读取csv"><a href="#读取csv" class="headerlink" title="读取csv"></a>读取csv</h4><p>示范档案下载 - <a href="https://github.com/MorvanZhou/tutorials/blob/master/numpy%26pandas/15_read_to/student.csv" target="_blank" rel="noopener">student.csv</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd <span class="comment">#加载模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取csv</span></span><br><span class="line">data = pd.read_csv(<span class="string">'student.csv'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印出data</span></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure>



<h4 id="将资料存取成pickle"><a href="#将资料存取成pickle" class="headerlink" title="将资料存取成pickle"></a>将资料存取成pickle</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.to_pickle(<span class="string">'student.pickle'</span>)</span><br></pre></td></tr></table></figure>



<h3 id="Pandas-合并-concat"><a href="#Pandas-合并-concat" class="headerlink" title="Pandas 合并 concat"></a>Pandas 合并 concat</h3><p><code>pandas</code>处理多组数据的时候往往会要用到数据的合并处理,使用 <code>concat</code>是一种基本的合并方式.而且<code>concat</code>中有很多参数可以调整,合并成你想要的数据形式.</p>
<h4 id="axis-合并方向"><a href="#axis-合并方向" class="headerlink" title="axis (合并方向)"></a>axis (合并方向)</h4><p><code>axis=0</code>是预设值，因此未设定任何参数时，函数默认<code>axis=0</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义资料集</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">2</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#concat纵向合并</span></span><br><span class="line">res = pd.concat([df1, df2, df3], axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印结果</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     a    b    c    d</span></span><br><span class="line"><span class="comment"># 0  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 1  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 2  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 0  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 1  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 2  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 0  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="comment"># 1  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="comment"># 2  2.0  2.0  2.0  2.0</span></span><br></pre></td></tr></table></figure>

<p>仔细观察会发现结果的<code>index</code>是0, 1, 2, 0, 1, 2, 0, 1, 2，若要将<code>index</code>重置，请看<strong>例子二</strong>。</p>
<h4 id="ignore-index-重置-index"><a href="#ignore-index-重置-index" class="headerlink" title="ignore_index (重置 index)"></a>ignore_index (重置 index)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#承上一个例子，并将index_ignore设定为True</span></span><br><span class="line">res = pd.concat([df1, df2, df3], axis=<span class="number">0</span>, ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印结果</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     a    b    c    d</span></span><br><span class="line"><span class="comment"># 0  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 1  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 2  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 3  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 4  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 5  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 6  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="comment"># 7  2.0  2.0  2.0  2.0</span></span><br><span class="line"><span class="comment"># 8  2.0  2.0  2.0  2.0</span></span><br></pre></td></tr></table></figure>

<p>结果的<code>index</code>变0, 1, 2, 3, 4, 5, 6, 7, 8。</p>
<h4 id="join-合并方式"><a href="#join-合并方式" class="headerlink" title="join (合并方式)"></a>join (合并方式)</h4><p><code>join=&#39;outer&#39;</code>为预设值，因此未设定任何参数时，函数默认<code>join=&#39;outer&#39;</code>。此方式是依照<code>column</code>来做纵向合并，有相同的<code>column</code>上下合并在一起，其他独自的<code>column</code>个自成列，原本没有值的位置皆以<code>NaN</code>填充。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义资料集</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>], index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>], index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#纵向"外"合并df1与df2</span></span><br><span class="line">res = pd.concat([df1, df2], axis=<span class="number">0</span>, join=<span class="string">'outer'</span>)</span><br><span class="line"><span class="comment"># join是outer时会将不同的部分填充成NAN</span></span><br><span class="line"><span class="comment">#join是inner时会将不同的部分裁剪掉</span></span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     a    b    c    d    e</span></span><br><span class="line"><span class="comment"># 1  0.0  0.0  0.0  0.0  NaN</span></span><br><span class="line"><span class="comment"># 2  0.0  0.0  0.0  0.0  NaN</span></span><br><span class="line"><span class="comment"># 3  0.0  0.0  0.0  0.0  NaN</span></span><br><span class="line"><span class="comment"># 2  NaN  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 3  NaN  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 4  NaN  1.0  1.0  1.0  1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#纵向"内"合并df1与df2</span></span><br><span class="line"><span class="comment">#重置index并打印结果</span></span><br><span class="line">res = pd.concat([df1, df2], axis=<span class="number">0</span>, join=<span class="string">'inner'</span>, ignore_index=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     b    c    d</span></span><br><span class="line"><span class="comment"># 0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 1  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 2  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 3  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 4  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 5  1.0  1.0  1.0</span></span><br></pre></td></tr></table></figure>

<h4 id="join-axes-依照-axes-合并"><a href="#join-axes-依照-axes-合并" class="headerlink" title="join_axes (依照 axes 合并)"></a>join_axes (依照 axes 合并)</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义资料集</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>], index=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>], index=[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#依照`df1.index`进行横向合并</span></span><br><span class="line">res = pd.concat([df1, df2], axis=<span class="number">1</span>, join_axes=[df1.index])</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印结果</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     a    b    c    d    b    c    d    e</span></span><br><span class="line"><span class="comment"># 1  0.0  0.0  0.0  0.0  NaN  NaN  NaN  NaN</span></span><br><span class="line"><span class="comment"># 2  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 3  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#移除join_axes，并打印结果</span></span><br><span class="line">res = pd.concat([df1, df2], axis=<span class="number">1</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     a    b    c    d    b    c    d    e</span></span><br><span class="line"><span class="comment"># 1  0.0  0.0  0.0  0.0  NaN  NaN  NaN  NaN</span></span><br><span class="line"><span class="comment"># 2  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 3  0.0  0.0  0.0  0.0  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 4  NaN  NaN  NaN  NaN  1.0  1.0  1.0  1.0</span></span><br></pre></td></tr></table></figure>

<h4 id="append-添加数据"><a href="#append-添加数据" class="headerlink" title="append (添加数据)"></a>append (添加数据)</h4><p><code>append</code>只有纵向合并，没有横向合并。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义资料集</span></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">0</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">3</span>,<span class="number">4</span>))*<span class="number">1</span>, columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">s1 = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>], index=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#将df2合并到df1的下面，以及重置index，并打印出结果</span></span><br><span class="line">res = df1.append(df2, ignore_index=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     a    b    c    d</span></span><br><span class="line"><span class="comment"># 0  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 1  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 2  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 3  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 4  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 5  1.0  1.0  1.0  1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#合并多个df，将df2与df3合并至df1的下面，以及重置index，并打印出结果</span></span><br><span class="line">res = df1.append([df2, df3], ignore_index=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     a    b    c    d</span></span><br><span class="line"><span class="comment"># 0  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 1  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 2  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 3  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 4  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 5  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 6  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 7  1.0  1.0  1.0  1.0</span></span><br><span class="line"><span class="comment"># 8  1.0  1.0  1.0  1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#合并series，将s1合并至df1，以及重置index，并打印出结果</span></span><br><span class="line">res = df1.append(s1, ignore_index=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     a    b    c    d</span></span><br><span class="line"><span class="comment"># 0  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 1  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 2  0.0  0.0  0.0  0.0</span></span><br><span class="line"><span class="comment"># 3  1.0  2.0  3.0  4.0</span></span><br></pre></td></tr></table></figure>

<h3 id="Pandas-合并-merge"><a href="#Pandas-合并-merge" class="headerlink" title="Pandas 合并 merge"></a>Pandas 合并 merge</h3><p><code>pandas</code>中的<code>merge</code>和<code>concat</code>类似,但主要是用于<strong>两组有key column的数据</strong>,统一索引的数据. 通常也被用在Database的处理当中.</p>
<h4 id="依据一组key合并"><a href="#依据一组key合并" class="headerlink" title="依据一组key合并"></a>依据一组key合并</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义资料集并打印出</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>],</span><br><span class="line">                             <span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                             <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>],</span><br><span class="line">                              <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                              <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;)</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line"><span class="comment">#    A   B key</span></span><br><span class="line"><span class="comment"># 0  A0  B0  K0</span></span><br><span class="line"><span class="comment"># 1  A1  B1  K1</span></span><br><span class="line"><span class="comment"># 2  A2  B2  K2</span></span><br><span class="line"><span class="comment"># 3  A3  B3  K3</span></span><br><span class="line"></span><br><span class="line">print(right)</span><br><span class="line"><span class="comment">#    C   D key</span></span><br><span class="line"><span class="comment"># 0  C0  D0  K0</span></span><br><span class="line"><span class="comment"># 1  C1  D1  K1</span></span><br><span class="line"><span class="comment"># 2  C2  D2  K2</span></span><br><span class="line"><span class="comment"># 3  C3  D3  K3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#依据key column合并，并打印出</span></span><br><span class="line">res = pd.merge(left, right, on=<span class="string">'key'</span>)</span><br><span class="line"></span><br><span class="line">print(res)</span><br><span class="line">     A   B key   C   D</span><br><span class="line"><span class="comment"># 0  A0  B0  K0  C0  D0</span></span><br><span class="line"><span class="comment"># 1  A1  B1  K1  C1  D1</span></span><br><span class="line"><span class="comment"># 2  A2  B2  K2  C2  D2</span></span><br><span class="line"><span class="comment"># 3  A3  B3  K3  C3  D3</span></span><br></pre></td></tr></table></figure>



<h4 id="依据两组key合并"><a href="#依据两组key合并" class="headerlink" title="依据两组key合并"></a>依据两组key合并</h4><p>合并时有4种方法<code>how = [&#39;left&#39;, &#39;right&#39;, &#39;outer&#39;, &#39;inner&#39;]</code>，预设值<code>how=&#39;inner&#39;</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义资料集并打印出</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>],</span><br><span class="line">                      <span class="string">'key2'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K0'</span>, <span class="string">'K1'</span>],</span><br><span class="line">                      <span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>, <span class="string">'A3'</span>],</span><br><span class="line">                      <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>, <span class="string">'B3'</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>],</span><br><span class="line">                       <span class="string">'key2'</span>: [<span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K0'</span>],</span><br><span class="line">                       <span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C1'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                       <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D1'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;)</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line"><span class="comment">#    A   B key1 key2</span></span><br><span class="line"><span class="comment"># 0  A0  B0   K0   K0</span></span><br><span class="line"><span class="comment"># 1  A1  B1   K0   K1</span></span><br><span class="line"><span class="comment"># 2  A2  B2   K1   K0</span></span><br><span class="line"><span class="comment"># 3  A3  B3   K2   K1</span></span><br><span class="line"></span><br><span class="line">print(right)</span><br><span class="line"><span class="comment">#    C   D key1 key2</span></span><br><span class="line"><span class="comment"># 0  C0  D0   K0   K0</span></span><br><span class="line"><span class="comment"># 1  C1  D1   K1   K0</span></span><br><span class="line"><span class="comment"># 2  C2  D2   K1   K0</span></span><br><span class="line"><span class="comment"># 3  C3  D3   K2   K0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#依据key1与key2 columns进行合并，并打印出四种结果['left', 'right', 'outer', 'inner']</span></span><br><span class="line">res = pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'inner'</span>) <span class="comment"># 默认为inner</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#    A   B key1 key2   C   D</span></span><br><span class="line"><span class="comment"># 0  A0  B0   K0   K0  C0  D0</span></span><br><span class="line"><span class="comment"># 1  A2  B2   K1   K0  C1  D1</span></span><br><span class="line"><span class="comment"># 2  A2  B2   K1   K0  C2  D2</span></span><br><span class="line"></span><br><span class="line">res = pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'outer'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     A    B key1 key2    C    D</span></span><br><span class="line"><span class="comment"># 0   A0   B0   K0   K0   C0   D0</span></span><br><span class="line"><span class="comment"># 1   A1   B1   K0   K1  NaN  NaN</span></span><br><span class="line"><span class="comment"># 2   A2   B2   K1   K0   C1   D1</span></span><br><span class="line"><span class="comment"># 3   A2   B2   K1   K0   C2   D2</span></span><br><span class="line"><span class="comment"># 4   A3   B3   K2   K1  NaN  NaN</span></span><br><span class="line"><span class="comment"># 5  NaN  NaN   K2   K0   C3   D3</span></span><br><span class="line"></span><br><span class="line">res = pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'left'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#    A   B key1 key2    C    D</span></span><br><span class="line"><span class="comment"># 0  A0  B0   K0   K0   C0   D0</span></span><br><span class="line"><span class="comment"># 1  A1  B1   K0   K1  NaN  NaN</span></span><br><span class="line"><span class="comment"># 2  A2  B2   K1   K0   C1   D1</span></span><br><span class="line"><span class="comment"># 3  A2  B2   K1   K0   C2   D2</span></span><br><span class="line"><span class="comment"># 4  A3  B3   K2   K1  NaN  NaN</span></span><br><span class="line"></span><br><span class="line">res = pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'right'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     A    B key1 key2   C   D</span></span><br><span class="line"><span class="comment"># 0   A0   B0   K0   K0  C0  D0</span></span><br><span class="line"><span class="comment"># 1   A2   B2   K1   K0  C1  D1</span></span><br><span class="line"><span class="comment"># 2   A2   B2   K1   K0  C2  D2</span></span><br><span class="line"><span class="comment"># 3  NaN  NaN   K2   K0  C3  D3</span></span><br></pre></td></tr></table></figure>

<h4 id="Indicator"><a href="#Indicator" class="headerlink" title="Indicator"></a>Indicator</h4><p><code>indicator=True</code>会将合并的记录放在新的一列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义资料集并打印出</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">0</span>,<span class="number">1</span>], <span class="string">'col_left'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>]&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'col1'</span>:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>],<span class="string">'col_right'</span>:[<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>]&#125;)</span><br><span class="line"></span><br><span class="line">print(df1)</span><br><span class="line"><span class="comment">#   col1 col_left</span></span><br><span class="line"><span class="comment"># 0     0        a</span></span><br><span class="line"><span class="comment"># 1     1        b</span></span><br><span class="line"></span><br><span class="line">print(df2)</span><br><span class="line"><span class="comment">#   col1  col_right</span></span><br><span class="line"><span class="comment"># 0     1          2</span></span><br><span class="line"><span class="comment"># 1     2          2</span></span><br><span class="line"><span class="comment"># 2     2          2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依据col1进行合并，并启用indicator=True，最后打印出</span></span><br><span class="line">res = pd.merge(df1, df2, on=<span class="string">'col1'</span>, how=<span class="string">'outer'</span>, indicator=<span class="literal">True</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#   col1 col_left  col_right      _merge</span></span><br><span class="line"><span class="comment"># 0   0.0        a        NaN   left_only</span></span><br><span class="line"><span class="comment"># 1   1.0        b        2.0        both</span></span><br><span class="line"><span class="comment"># 2   2.0      NaN        2.0  right_only</span></span><br><span class="line"><span class="comment"># 3   2.0      NaN        2.0  right_only</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定indicator column的名称，并打印出</span></span><br><span class="line">res = pd.merge(df1, df2, on=<span class="string">'col1'</span>, how=<span class="string">'outer'</span>, indicator=<span class="string">'indicator_column'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#   col1 col_left  col_right indicator_column</span></span><br><span class="line"><span class="comment"># 0   0.0        a        NaN        left_only</span></span><br><span class="line"><span class="comment"># 1   1.0        b        2.0             both</span></span><br><span class="line"><span class="comment"># 2   2.0      NaN        2.0       right_only</span></span><br><span class="line"><span class="comment"># 3   2.0      NaN        2.0       right_only</span></span><br></pre></td></tr></table></figure>

<h4 id="依据index合并"><a href="#依据index合并" class="headerlink" title="依据index合并"></a>依据index合并</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义资料集并打印出</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'A'</span>: [<span class="string">'A0'</span>, <span class="string">'A1'</span>, <span class="string">'A2'</span>],</span><br><span class="line">                     <span class="string">'B'</span>: [<span class="string">'B0'</span>, <span class="string">'B1'</span>, <span class="string">'B2'</span>]&#125;,</span><br><span class="line">                     index=[<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>])</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'C'</span>: [<span class="string">'C0'</span>, <span class="string">'C2'</span>, <span class="string">'C3'</span>],</span><br><span class="line">                      <span class="string">'D'</span>: [<span class="string">'D0'</span>, <span class="string">'D2'</span>, <span class="string">'D3'</span>]&#125;,</span><br><span class="line">                     index=[<span class="string">'K0'</span>, <span class="string">'K2'</span>, <span class="string">'K3'</span>])</span><br><span class="line"></span><br><span class="line">print(left)</span><br><span class="line"><span class="comment">#     A   B</span></span><br><span class="line"><span class="comment"># K0  A0  B0</span></span><br><span class="line"><span class="comment"># K1  A1  B1</span></span><br><span class="line"><span class="comment"># K2  A2  B2</span></span><br><span class="line"></span><br><span class="line">print(right)</span><br><span class="line"><span class="comment">#     C   D</span></span><br><span class="line"><span class="comment"># K0  C0  D0</span></span><br><span class="line"><span class="comment"># K2  C2  D2</span></span><br><span class="line"><span class="comment"># K3  C3  D3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#依据左右资料集的index进行合并，how='outer',并打印出</span></span><br><span class="line">res = pd.merge(left, right, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>, how=<span class="string">'outer'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#      A    B    C    D</span></span><br><span class="line"><span class="comment"># K0   A0   B0   C0   D0</span></span><br><span class="line"><span class="comment"># K1   A1   B1  NaN  NaN</span></span><br><span class="line"><span class="comment"># K2   A2   B2   C2   D2</span></span><br><span class="line"><span class="comment"># K3  NaN  NaN   C3   D3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#依据左右资料集的index进行合并，how='inner',并打印出</span></span><br><span class="line">res = pd.merge(left, right, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>, how=<span class="string">'inner'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#     A   B   C   D</span></span><br><span class="line"><span class="comment"># K0  A0  B0  C0  D0</span></span><br><span class="line"><span class="comment"># K2  A2  B2  C2  D2</span></span><br></pre></td></tr></table></figure>

<h4 id="解决overlapping的问题"><a href="#解决overlapping的问题" class="headerlink" title="解决overlapping的问题"></a>解决overlapping的问题</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd </span><br><span class="line"></span><br><span class="line"><span class="comment">#定义资料集</span></span><br><span class="line">boys = pd.DataFrame(&#123;<span class="string">'k'</span>: [<span class="string">'K0'</span>, <span class="string">'K1'</span>, <span class="string">'K2'</span>], <span class="string">'age'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">girls = pd.DataFrame(&#123;<span class="string">'k'</span>: [<span class="string">'K0'</span>, <span class="string">'K0'</span>, <span class="string">'K3'</span>], <span class="string">'age'</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用suffixes解决overlapping的问题</span></span><br><span class="line">res = pd.merge(boys, girls, on=<span class="string">'k'</span>, suffixes=[<span class="string">'_boy'</span>, <span class="string">'_girl'</span>], how=<span class="string">'inner'</span>)</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#    age_boy   k  age_girl</span></span><br><span class="line"><span class="comment"># 0        1  K0         4</span></span><br><span class="line"><span class="comment"># 1        1  K0         5</span></span><br></pre></td></tr></table></figure>



<h3 id="pandas-plot"><a href="#pandas-plot" class="headerlink" title="pandas plot"></a>pandas plot</h3><p>这次我们讲如何将数据可视化. 首先<code>import</code>我们需要用到的模块，除了 pandas，我们也需要使用 numpy 生成一些数据，这节里使用的 matplotlib 仅仅是用来 show 图片的, 即 <code>plt.show()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure>

<p>今天我们主要是学习如何 plot data</p>
<h4 id="创建一个Series"><a href="#创建一个Series" class="headerlink" title="创建一个Series"></a>创建一个Series</h4><p>这是一个线性的数据，我们随机生成1000个数据，<code>Series</code> 默认的 <code>index</code> 就是从0开始的整数，但是这里我显式赋值以便让大家看的更清楚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 随机生成1000个数据</span><br><span class="line">data &#x3D; pd.Series(np.random.randn(1000),index&#x3D;np.arange(1000))</span><br><span class="line"></span><br><span class="line"># 为了方便观看效果, 我们累加这个数据</span><br><span class="line">data.cumsum()</span><br><span class="line"></span><br><span class="line"># pandas 数据可以直接观看其可视化形式</span><br><span class="line">data.plot()</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>就这么简单，熟悉 matplotlib 的朋友知道如果需要<code>plot</code>一个数据，我们可以使用 <code>plt.plot(x=, y=)</code>，把<code>x</code>,<code>y</code>的数据作为参数存进去，但是<code>data</code>本来就是一个数据，所以我们可以直接<code>plot</code>。 生成的结果就是下图：</p>
<p><a href="https://morvanzhou.github.io/static/results/np-pd/3-8-1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/np-pd/3-8-1.png" alt="Pandas plot 出图"></a></p>
<h4 id="Dataframe-可视化"><a href="#Dataframe-可视化" class="headerlink" title="Dataframe 可视化"></a>Dataframe 可视化</h4><p>我们生成一个1000*4 的<code>DataFrame</code>，并对他们累加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data &#x3D; pd.DataFrame(</span><br><span class="line">    np.random.randn(1000,4),</span><br><span class="line">    index&#x3D;np.arange(1000),</span><br><span class="line">    columns&#x3D;list(&quot;ABCD&quot;)</span><br><span class="line">    )</span><br><span class="line">data.cumsum()</span><br><span class="line">data.plot()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/np-pd/3-8-2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/np-pd/3-8-2.png" alt="Pandas plot 出图"></a></p>
<p>这个就是我们刚刚生成的4个<code>column</code>的数据，因为有4组数据，所以4组数据会分别<code>plot</code>出来。<code>plot</code> 可以指定很多参数，具体的用法大家可以自己查一下<a href="http://pandas.pydata.org/pandas-docs/version/0.18.1/visualization.html" target="_blank" rel="noopener">这里</a></p>
<p>除了<code>plot</code>，我经常会用到还有<code>scatter</code>，这个会显示散点图，首先给大家说一下在 pandas 中有多少种方法</p>
<ul>
<li>bar</li>
<li>hist</li>
<li>box</li>
<li>kde</li>
<li>area</li>
<li>scatter</li>
<li>hexbin</li>
</ul>
<p>但是我们今天不会一一介绍，主要说一下 <code>plot</code> 和 <code>scatter</code>. 因为<code>scatter</code>只有<code>x</code>，<code>y</code>两个属性，我们我们就可以分别给<code>x</code>, <code>y</code>指定数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax &#x3D; data.plot.scatter(x&#x3D;&#39;A&#39;,y&#x3D;&#39;B&#39;,color&#x3D;&#39;DarkBlue&#39;,label&#x3D;&#39;Class1&#39;)</span><br></pre></td></tr></table></figure>

<p>然后我们在可以再画一个在同一个<code>ax</code>上面，选择不一样的数据列，不同的 <code>color</code> 和 <code>label</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 将之下这个 data 画在上一个 ax 上面</span><br><span class="line">data.plot.scatter(x&#x3D;&#39;A&#39;,y&#x3D;&#39;C&#39;,color&#x3D;&#39;LightGreen&#39;,label&#x3D;&#39;Class2&#39;,ax&#x3D;ax)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>下面就是我<code>plot</code>出来的图片</p>
<p><a href="https://morvanzhou.github.io/static/results/np-pd/3-8-3.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/np-pd/3-8-3.png" alt="Pandas plot 出图"></a></p>
<p>这就是我们今天讲的两种呈现方式，一种是线性的方式，一种是散点图。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E8%8E%AB%E7%83%A6%20Matplotlib/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiantian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天天的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/20/%E8%8E%AB%E7%83%A6%20Matplotlib/" itemprop="url">莫烦 Matplotlib</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-20T16:39:09+08:00">
                2020-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">神经网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="莫烦-Matplotlib"><a href="#莫烦-Matplotlib" class="headerlink" title="莫烦 Matplotlib"></a>莫烦 Matplotlib</h1><p>在学习了numpy&amp;pandas后</p>
<p>如果某天你发现自己要学习 Matplotlib, 很可能是因为:</p>
<ol>
<li>Matplotlib 是一个非常强大的 Python 画图工具;</li>
<li>手中有很多数据, 可是不知道该怎么呈现这些数据.</li>
</ol>
<p>所以就找到了 Matplotlib. 它能帮你画出美丽的:</p>
<ul>
<li><p>线图;</p>
</li>
<li><p>散点图;</p>
</li>
<li><p>等高线图;</p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4></li>
<li><p>条形图;</p>
</li>
<li><p>柱状图;</p>
</li>
<li><p>3D 图形,</p>
</li>
<li><p>甚至是图形动画等等.</p>
</li>
</ul>
<h2 id="Matplotlib安装"><a href="#Matplotlib安装" class="headerlink" title="Matplotlib安装"></a>Matplotlib安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>打开 Terminal 窗口, 输入以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># python 3+ 请复制以下在 terminal 中执行</span><br><span class="line">$ sudo apt-get install python3-matplotlib</span><br><span class="line"></span><br><span class="line"># python 2+ 请复制以下在 terminal 中执行</span><br><span class="line">$ sudo apt-get install python-matplotlib</span><br></pre></td></tr></table></figure>

<h3 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h3><p>打开 Terminal 窗口, 输入以下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># python 3+ 请复制以下在 terminal 中执行</span><br><span class="line">$ pip3 install matplotlib</span><br><span class="line"></span><br><span class="line"># python 2+ 请复制以下在 terminal 中执行</span><br><span class="line">$ pip install matplotlib</span><br></pre></td></tr></table></figure>

<h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install matplotlib</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用<code>import</code>导入模块<code>matplotlib.pyplot</code>，并简写成<code>plt</code> 使用<code>import</code>导入模块<code>numpy</code>，并简写成<code>np</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>

<p>使用<code>np.linspace</code>定义x：范围是(-3,3);   个数是50. </p>
<p>仿真一维数据组(<code>x</code> ,<code>y1</code>)表示曲线1. 仿真一维数据组(<code>x</code> ,<code>y2</code>)表示曲线2.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span>*x + <span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="figure图像"><a href="#figure图像" class="headerlink" title="figure图像"></a>figure图像</h3><p>使用<code>plt.figure</code>定义一个图像窗口. </p>
<p>使用<code>plt.plot</code>画(<code>x</code> ,<code>y2</code>)曲线. </p>
<p>使用<code>plt.plot</code>画(<code>x</code> ,<code>y1</code>)曲线，曲线的颜色属性(<code>color</code>)为红色;  曲线的宽度(<code>linewidth</code>)为1.0；曲线的类型(<code>linestyle</code>)为虚线.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y2)</span><br><span class="line">plt.plot(x, y1, color=<span class="string">'red'</span>, linewidth=<span class="number">1.0</span>, linestyle=<span class="string">'--'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://morvanzhou.github.io/static/results/plt/2_2_2.png" alt="figure 图像"></p>
<h3 id="设置坐标轴1"><a href="#设置坐标轴1" class="headerlink" title="设置坐标轴1"></a>设置坐标轴1</h3><p>使用<code>plt.xlim</code>设置x坐标轴范围：(-1, 2)；</p>
<p>使用<code>plt.ylim</code>设置y坐标轴范围：(-2, 3)； </p>
<p>使用<code>plt.xlabel</code>设置x坐标轴名称：’I am x’； </p>
<p>使用<code>plt.ylabel</code>设置y坐标轴名称：’I am y’；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.xlim((<span class="number">-1</span>, <span class="number">2</span>))</span><br><span class="line">plt.ylim((<span class="number">-2</span>, <span class="number">3</span>))</span><br><span class="line">plt.xlabel(<span class="string">'I am x'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'I am y'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/2_3_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/2_3_1.png" alt="设置坐标轴1"></a></p>
<p>使用<code>np.linspace</code>定义范围以及个数：范围是(-1,2);个数是5. </p>
<p>使用<code>print</code>打印出新定义的范围. 使用<code>plt.xticks</code>设置x轴刻度：范围是(-1,2);  个数是5.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_ticks = np.linspace(<span class="number">-1</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">print(new_ticks)</span><br><span class="line">plt.xticks(new_ticks)</span><br></pre></td></tr></table></figure>

<p>使用<code>plt.yticks</code>设置y轴刻度以及名称：刻度为[-2, -1.8, -1, 1.22, 3]；对应刻度的名称为[‘really bad’,’bad’,’normal’,’good’, ‘really good’]. 使用<code>plt.show</code>显示图像.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.yticks([<span class="number">-2</span>, <span class="number">-1.8</span>, <span class="number">-1</span>, <span class="number">1.22</span>, <span class="number">3</span>],[<span class="string">r'$really\ bad$'</span>, <span class="string">r'$bad$'</span>, <span class="string">r'$normal$'</span>, <span class="string">r'$good$'</span>, <span class="string">r'$really\ good$'</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/2_3_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/2_3_2.png" alt="设置坐标轴1"></a></p>
<p>使用<code>plt.gca</code>获取当前坐标轴信息. </p>
<p>使用<code>.spines</code>设置边框：右侧边框；</p>
<p>使用<code>.set_color</code>设置边框颜色：默认白色； </p>
<p>使用<code>.spines</code>设置边框：上边框；</p>
<p>使用<code>.set_color</code>设置边框颜色：默认白色；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[<span class="string">'right'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.spines[<span class="string">'top'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/2_4_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/2_4_1.png" alt="设置坐标轴2"></a></p>
<h3 id="设置坐标轴2"><a href="#设置坐标轴2" class="headerlink" title="设置坐标轴2"></a>设置坐标轴2</h3><p>使用<code>.xaxis.set_ticks_position</code>设置x坐标刻度数字或名称的位置：<code>bottom</code>.（所有位置：<code>top</code>，<code>bottom</code>，<code>both</code>，<code>default</code>，<code>none</code>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.xaxis.set_ticks_position(<span class="string">'bottom'</span>)</span><br></pre></td></tr></table></figure>

<p>使用<code>.spines</code>设置边框：x轴；使用<code>.set_position</code>设置边框位置：y=0的位置；（位置所有属性：<code>outward</code>，<code>axes</code>，<code>data</code>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax.spines[<span class="string">'bottom'</span>].set_position((<span class="string">'data'</span>, <span class="number">0</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/2_4_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/2_4_2.png" alt="设置坐标轴2"></a></p>
<p>使用<code>.yaxis.set_ticks_position</code>设置y坐标刻度数字或名称的位置：<code>left</code>.（所有位置：<code>left</code>，<code>right</code>，<code>both</code>，<code>default</code>，<code>none</code>）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.yaxis.set_ticks_position(<span class="string">'left'</span>)</span><br></pre></td></tr></table></figure>

<p>使用<code>.spines</code>设置边框：y轴；使用<code>.set_position</code>设置边框位置：x=0的位置；（位置所有属性：<code>outward</code>，<code>axes</code>，<code>data</code>） 使用<code>plt.show</code>显示图像.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ax.spines[<span class="string">'left'</span>].set_position((<span class="string">'data'</span>,<span class="number">0</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://morvanzhou.github.io/static/results/plt/2_4_3.png" alt="设置坐标轴2"></p>
<h3 id="Legend图例"><a href="#Legend图例" class="headerlink" title="Legend图例"></a>Legend图例</h3><h4 id="添加图例"><a href="#添加图例" class="headerlink" title="添加图例"></a>添加图例</h4><p>本节中我们将对图中的两条线绘制图例，首先我们设置两条线的类型等信息（蓝色实线与红色虚线).</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># set line syles</span></span><br><span class="line">l1, = plt.plot(x, y1, label=<span class="string">'linear line'</span>)</span><br><span class="line">l2, = plt.plot(x, y2, color=<span class="string">'red'</span>, linewidth=<span class="number">1.0</span>, linestyle=<span class="string">'--'</span>, label=<span class="string">'square line'</span>)</span><br></pre></td></tr></table></figure>

<p><code>legend</code>将要显示的信息来自于上面代码中的 <code>label</code>. 所以我们只需要简单写下一下代码, plt 就能自动的为我们添加图例.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.legend(loc=<span class="string">'upper right'</span>)</span><br></pre></td></tr></table></figure>

<p>参数 <code>loc=&#39;upper right&#39;</code> 表示图例将添加在图中的右上角.</p>
<p><img src="https://morvanzhou.github.io/static/results/plt/2_5_1.png" alt="Legend 图例"></p>
<h4 id="调整位置和名称"><a href="#调整位置和名称" class="headerlink" title="调整位置和名称"></a>调整位置和名称</h4><p>如果我们想单独修改之前的 <code>label</code> 信息, 给不同类型的线条设置图例信息. </p>
<p>我们可以在 <code>plt.legend</code> 输入更多参数. 如果以下面这种形式添加 legend, 我们需要确保, 在上面的代码 <code>plt.plot(x, y2, label=&#39;linear line&#39;)</code> 和 <code>plt.plot(x, y1, label=&#39;square line&#39;)</code> 中有用变量 <code>l1</code> 和 <code>l2</code> 分别存储起来. 而且需要注意的是 <code>l1,</code> <code>l2,</code>要以逗号结尾, 因为<code>plt.plot()</code> 返回的是一个列表.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.legend(handles=[l1, l2], labels=[<span class="string">'up'</span>, <span class="string">'down'</span>],  loc=<span class="string">'best'</span>)</span><br></pre></td></tr></table></figure>

<p>这样我们就能分别重新设置线条对应的 <code>label</code> 了.</p>
<p>最后我们得到带有图例信息的图片.</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/2_5_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/2_5_2.png" alt="Legend 图例"></a></p>
<p>其中’loc’参数有多种，’best’表示自动分配最佳位置，其余的如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'best'</span> : <span class="number">0</span>,          </span><br><span class="line"><span class="string">'upper right'</span>  : <span class="number">1</span>,</span><br><span class="line"><span class="string">'upper left'</span>   : <span class="number">2</span>,</span><br><span class="line"><span class="string">'lower left'</span>   : <span class="number">3</span>,</span><br><span class="line"><span class="string">'lower right'</span>  : <span class="number">4</span>,</span><br><span class="line"><span class="string">'right'</span>        : <span class="number">5</span>,</span><br><span class="line"><span class="string">'center left'</span>  : <span class="number">6</span>,</span><br><span class="line"><span class="string">'center right'</span> : <span class="number">7</span>,</span><br><span class="line"><span class="string">'lower center'</span> : <span class="number">8</span>,</span><br><span class="line"><span class="string">'upper center'</span> : <span class="number">9</span>,</span><br><span class="line"><span class="string">'center'</span>       : <span class="number">10</span>,</span><br></pre></td></tr></table></figure>



<h3 id="Annotation-标注"><a href="#Annotation-标注" class="headerlink" title="Annotation 标注"></a>Annotation 标注</h3><h4 id="画出基本图"><a href="#画出基本图" class="headerlink" title="画出基本图"></a>画出基本图</h4><p>当图线中某些特殊地方需要标注时，我们可以使用 <code>annotation</code>. matplotlib 中的 <code>annotation</code> 有两种方法， 一种是用 plt 里面的 <code>annotate</code>，一种是直接用 plt 里面的 <code>text</code> 来写标注.</p>
<p>首先，我们在坐标轴中绘制一条直线.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">50</span>)</span><br><span class="line">y = <span class="number">2</span>*x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">plt.figure(num=<span class="number">1</span>, figsize=(<span class="number">8</span>, <span class="number">5</span>),)</span><br><span class="line">plt.plot(x, y,)</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/2_6_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/2_6_1.png" alt="Annotation 标注"></a></p>
<h4 id="移动坐标"><a href="#移动坐标" class="headerlink" title="移动坐标"></a>移动坐标</h4><p>然后我们挪动坐标轴的位置.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[<span class="string">'right'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.spines[<span class="string">'top'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.spines[<span class="string">'top'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">'bottom'</span>)</span><br><span class="line">ax.spines[<span class="string">'bottom'</span>].set_position((<span class="string">'data'</span>, <span class="number">0</span>))</span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">'left'</span>)</span><br><span class="line">ax.spines[<span class="string">'left'</span>].set_position((<span class="string">'data'</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/2_6_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/2_6_2.png" alt="Annotation 标注"></a></p>
<p>然后标注出点<code>(x0, y0)</code>的位置信息. 用<code>plt.plot([x0, x0,], [0, y0,], &#39;k--&#39;, linewidth=2.5)</code> 画出一条垂直于x轴的虚线.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x0 = <span class="number">1</span></span><br><span class="line">y0 = <span class="number">2</span>*x0 + <span class="number">1</span></span><br><span class="line">plt.plot([x0, x0,], [<span class="number">0</span>, y0,], <span class="string">'k--'</span>, linewidth=<span class="number">2.5</span>)</span><br><span class="line"><span class="comment"># set dot styles</span></span><br><span class="line">plt.scatter([x0, ], [y0, ], s=<span class="number">50</span>, color=<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/2_6_3.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/2_6_3.png" alt="Annotation 标注"></a></p>
<h4 id="添加注释-annotate"><a href="#添加注释-annotate" class="headerlink" title="添加注释 annotate"></a>添加注释 annotate</h4><p>接下来我们就对<code>(x0, y0)</code>这个点进行标注.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.annotate(<span class="string">r'$2x+1=%s$'</span> % y0, xy=(x0, y0), xycoords=<span class="string">'data'</span>, xytext=(+<span class="number">30</span>, <span class="number">-30</span>),</span><br><span class="line">             textcoords=<span class="string">'offset points'</span>, fontsize=<span class="number">16</span>,</span><br><span class="line">             arrowprops=dict(arrowstyle=<span class="string">'-&gt;'</span>, connectionstyle=<span class="string">"arc3,rad=.2"</span>))</span><br></pre></td></tr></table></figure>

<p>其中参数<code>xycoords=&#39;data&#39;</code> 是说基于数据的值来选位置, <code>xytext=(+30, -30)</code> 和 <code>textcoords=&#39;offset points&#39;</code> 对于标注位置的描述 和 xy 偏差值, <code>arrowprops</code>是对图中箭头类型的一些设置.</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/2_6_4.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/2_6_4.png" alt="Annotation 标注"></a></p>
<h4 id="添加注释-text"><a href="#添加注释-text" class="headerlink" title="添加注释 text"></a>添加注释 text</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.text(<span class="number">-3.7</span>, <span class="number">3</span>, <span class="string">r'$This\ is\ the\ some\ text. \mu\ \sigma_i\ \alpha_t$'</span>,</span><br><span class="line">         fontdict=&#123;<span class="string">'size'</span>: <span class="number">16</span>, <span class="string">'color'</span>: <span class="string">'r'</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>其中<code>-3.7, 3,</code>是选取text的位置, 空格需要用到转字符<code>\</code>,<code>fontdict</code>设置文本字体.</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/2_6_5.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/2_6_5.png" alt="Annotation 标注"></a></p>
<h3 id="tick-能见度"><a href="#tick-能见度" class="headerlink" title="tick 能见度"></a>tick 能见度</h3><h4 id="生成图形"><a href="#生成图形" class="headerlink" title="生成图形"></a>生成图形</h4><p>当图片中的内容较多，相互遮盖时，我们可以通过设置相关内容的透明度来使图片更易于观察，也即是通过本节中的<code>bbox</code>参数设置来调节图像信息.</p>
<p>首先参考之前的例子, 我们先绘制图像基本信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, <span class="number">50</span>)</span><br><span class="line">y = <span class="number">0.1</span>*x</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># 在 plt 2.0.2 或更高的版本中, 设置 zorder 给 plot 在 z 轴方向排序</span></span><br><span class="line">plt.plot(x, y, linewidth=<span class="number">10</span>, zorder=<span class="number">1</span>)</span><br><span class="line">plt.ylim(<span class="number">-2</span>, <span class="number">2</span>)</span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[<span class="string">'right'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.spines[<span class="string">'top'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.spines[<span class="string">'top'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">'bottom'</span>)</span><br><span class="line">ax.spines[<span class="string">'bottom'</span>].set_position((<span class="string">'data'</span>, <span class="number">0</span>))</span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">'left'</span>)</span><br><span class="line">ax.spines[<span class="string">'left'</span>].set_position((<span class="string">'data'</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/2_7_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/2_7_1.png" alt="tick 能见度"></a></p>
<h4 id="调整坐标"><a href="#调整坐标" class="headerlink" title="调整坐标"></a>调整坐标</h4><p>然后对被遮挡的图像调节相关透明度，本例中设置 x轴 和 y轴 的刻度数字进行透明度设置</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> ax.get_xticklabels() + ax.get_yticklabels():</span><br><span class="line">    label.set_fontsize(<span class="number">12</span>)</span><br><span class="line">    <span class="comment"># 在 plt 2.0.2 或更高的版本中, 设置 zorder 给 plot 在 z 轴方向排序</span></span><br><span class="line">    label.set_bbox(dict(facecolor=<span class="string">'white'</span>, edgecolor=<span class="string">'None'</span>, alpha=<span class="number">0.7</span>, zorder=<span class="number">2</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>其中<code>label.set_fontsize(12)</code>重新调节字体大小，<code>bbox</code>设置目的内容的透明度相关参，<code>facecolor</code>调节 <code>box</code> 前景色，<code>edgecolor</code> 设置边框， 本处设置边框为无，<code>alpha</code>设置透明度. 最终结果如下:</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/2_7_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/2_7_2.png" alt="tick 能见度"></a></p>
<h2 id="画图种类"><a href="#画图种类" class="headerlink" title="画图种类"></a>画图种类</h2><h3 id="Scatter-散点图"><a href="#Scatter-散点图" class="headerlink" title="Scatter 散点图"></a>Scatter 散点图</h3><h4 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h4><p>首先，先引入<code>matplotlib.pyplot</code>简写作<code>plt</code>,再引入模块<code>numpy</code>用来产生一些随机数据。生成1024个呈<a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83" target="_blank" rel="noopener">标准正态分布</a>的二维数据组 (平均数是0，方差为1) 作为一个数据集，并图像化这个数据集。每一个点的颜色值用<code>T</code>来表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">n = <span class="number">1024</span>    <span class="comment"># data size</span></span><br><span class="line">X = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n) <span class="comment"># 每一个点的X值</span></span><br><span class="line">Y = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n) <span class="comment"># 每一个点的Y值</span></span><br><span class="line">T = np.arctan2(Y,X) <span class="comment"># for color value</span></span><br></pre></td></tr></table></figure>

<p>数据集生成完毕，现在来用<code>scatter</code>plot这个点集，鼠标点上去，可以看到这个函数的各个parameter的描述，如下图：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_1_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_1_2.png" alt="Scatter 散点图"></a></p>
<p>输入<code>X</code>和<code>Y</code>作为location，<code>size=75</code>，颜色为<code>T</code>，<code>color map</code>用默认值，透明度<code>alpha</code> 为 50%。 x轴显示范围定位(-1.5，1.5)，并用<code>xtick()</code>函数来隐藏x坐标轴，y轴同理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.scatter(X, Y, s=<span class="number">75</span>, c=T, alpha=<span class="number">.5</span>)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-1.5</span>, <span class="number">1.5</span>)</span><br><span class="line">plt.xticks(())  <span class="comment"># ignore xticks</span></span><br><span class="line">plt.ylim(<span class="number">-1.5</span>, <span class="number">1.5</span>)</span><br><span class="line">plt.yticks(())  <span class="comment"># ignore yticks</span></span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><img src="https://morvanzhou.github.io/static/results/plt/3_1_1.png" alt="Scatter 散点图"></p>
<h3 id="Bar-柱状图"><a href="#Bar-柱状图" class="headerlink" title="Bar 柱状图"></a>Bar 柱状图</h3><h4 id="生成基本图形"><a href="#生成基本图形" class="headerlink" title="生成基本图形"></a>生成基本图形</h4><p>向上向下分别生成12个数据，X为 0 到 11 的整数 ，Y是相应的<a href="https://en.wikipedia.org/wiki/Uniform_distribution" target="_blank" rel="noopener">均匀分布</a>的随机数据。 使用的函数是<code>plt.bar</code>，参数为X和Y：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">n = <span class="number">12</span></span><br><span class="line">X = np.arange(n)</span><br><span class="line">Y1 = (<span class="number">1</span> - X / float(n)) * np.random.uniform(<span class="number">0.5</span>, <span class="number">1.0</span>, n)</span><br><span class="line">Y2 = (<span class="number">1</span> - X / float(n)) * np.random.uniform(<span class="number">0.5</span>, <span class="number">1.0</span>, n)</span><br><span class="line"></span><br><span class="line">plt.bar(X, +Y1)</span><br><span class="line">plt.bar(X, -Y2)</span><br><span class="line"></span><br><span class="line">plt.xlim(<span class="number">-.5</span>, n)</span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.ylim(<span class="number">-1.25</span>, <span class="number">1.25</span>)</span><br><span class="line">plt.yticks(())</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>这样我们就生成了下图所示的柱状图基本框架：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_2_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_2_2.png" alt="Bar 柱状图"></a></p>
<h4 id="加颜色和数据"><a href="#加颜色和数据" class="headerlink" title="加颜色和数据"></a>加颜色和数据</h4><p>下面我们就颜色和数值进行优化。 用<code>facecolor</code>设置主体颜色，<code>edgecolor</code>设置边框颜色为白色，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.bar(X, +Y1, facecolor=<span class="string">'#9999ff'</span>, edgecolor=<span class="string">'white'</span>)</span><br><span class="line">plt.bar(X, -Y2, facecolor=<span class="string">'#ff9999'</span>, edgecolor=<span class="string">'white'</span>)</span><br></pre></td></tr></table></figure>

<p>现在的结果呈现：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_2_3.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_2_3.png" alt="Bar 柱状图"></a></p>
<p>接下来我们用函数<code>plt.text</code>分别在柱体上方（下方）加上数值，用<code>%.2f</code>保留两位小数，横向居中对齐<code>ha=&#39;center&#39;</code>，纵向底部（顶部）对齐<code>va=&#39;bottom&#39;</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(X, Y1):</span><br><span class="line">    <span class="comment"># ha: horizontal alignment</span></span><br><span class="line">    <span class="comment"># va: vertical alignment</span></span><br><span class="line">    plt.text(x + <span class="number">0.4</span>, y + <span class="number">0.05</span>, <span class="string">'%.2f'</span> % y, ha=<span class="string">'center'</span>, va=<span class="string">'bottom'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(X, Y2):</span><br><span class="line">    <span class="comment"># ha: horizontal alignment</span></span><br><span class="line">    <span class="comment"># va: vertical alignment</span></span><br><span class="line">    plt.text(x + <span class="number">0.4</span>, -y - <span class="number">0.05</span>, <span class="string">'%.2f'</span> % y, ha=<span class="string">'center'</span>, va=<span class="string">'top'</span>)</span><br></pre></td></tr></table></figure>

<p>最终的结果就像开始一样：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_2_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_2_1.png" alt="Bar 柱状图"></a></p>
<h3 id="Contours-等高线图"><a href="#Contours-等高线图" class="headerlink" title="Contours 等高线图"></a>Contours 等高线图</h3><h4 id="画等高线"><a href="#画等高线" class="headerlink" title="画等高线"></a>画等高线</h4><p>数据集即三维点 (x,y) 和对应的高度值，共有256个点。高度值使用一个 height function <code>f(x,y)</code> 生成。 x, y 分别是在区间 [-3,3] 中均匀分布的256个值，并用<code>meshgrid</code>在二维平面中将每一个x和每一个y分别对应起来，编织成栅格:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="comment"># the height function</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - x / <span class="number">2</span> + x**<span class="number">5</span> + y**<span class="number">3</span>) * np.exp(-x**<span class="number">2</span> -y**<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">256</span></span><br><span class="line">x = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, n)</span><br><span class="line">y = np.linspace(<span class="number">-3</span>, <span class="number">3</span>, n)</span><br><span class="line">X,Y = np.meshgrid(x, y)</span><br></pre></td></tr></table></figure>

<p>接下来进行颜色填充。使用函数<code>plt.contourf</code>把颜色加进去，位置参数分别为：X, Y, f(X,Y)。透明度0.75，并将 f(X,Y) 的值对应到color map的暖色组中寻找对应颜色。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># use plt.contourf to filling contours</span></span><br><span class="line"><span class="comment"># X, Y and value for (X,Y) point</span></span><br><span class="line">plt.contourf(X, Y, f(X, Y), <span class="number">8</span>, alpha=<span class="number">.75</span>, cmap=plt.cm.hot)</span><br></pre></td></tr></table></figure>

<p>接下来进行等高线绘制。使用<code>plt.contour</code>函数划线。位置参数为：X, Y, f(X,Y)。颜色选黑色，线条宽度选0.5。现在的结果如下图所示，只有颜色和线条，还没有数值Label：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># use plt.contour to add contour lines</span></span><br><span class="line">C = plt.contour(X, Y, f(X, Y), <span class="number">8</span>, colors=<span class="string">'black'</span>, linewidth=<span class="number">.5</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/3_3_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_3_2.png" alt="Contours 等高线图"></a></p>
<h4 id="添加高度数字"><a href="#添加高度数字" class="headerlink" title="添加高度数字"></a>添加高度数字</h4><p>其中，8代表等高线的密集程度，这里被分为10个部分。如果是0，则图像被一分为二。</p>
<p>最后加入Label，<code>inline</code>控制是否将Label画在线里面，字体大小为10。并将坐标轴隐藏：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.clabel(C, inline=<span class="literal">True</span>, fontsize=<span class="number">10</span>)</span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br></pre></td></tr></table></figure>

<p>最终结果即：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_3_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_3_1.png" alt="Contours 等高线图"></a></p>
<h3 id="Image-图片"><a href="#Image-图片" class="headerlink" title="Image 图片"></a>Image 图片</h3><h4 id="随机矩阵画图"><a href="#随机矩阵画图" class="headerlink" title="随机矩阵画图"></a>随机矩阵画图</h4><p>这一节我们讲解怎样在<strong>matplotlib</strong>中打印出图像。这里我们打印出的是纯粹的数字，而非自然图像。 我们今天用这样 3x3 的 2D-array 来表示点的颜色，每一个点就是一个pixel。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">0.313660827978</span>, <span class="number">0.365348418405</span>, <span class="number">0.423733120134</span>,</span><br><span class="line">              <span class="number">0.365348418405</span>, <span class="number">0.439599930621</span>, <span class="number">0.525083754405</span>,</span><br><span class="line">              <span class="number">0.423733120134</span>, <span class="number">0.525083754405</span>, <span class="number">0.651536351379</span>]).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>今天做出的图像就是这个样子：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_4_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_4_1.png" alt="Image 图片"></a></p>
<p>三行三列的格子，<strong>a</strong>代表每一个值，图像右边有一个注释，白色代表值最大的地方，颜色越深值越小。</p>
<p>下面我们来看代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.imshow(a, interpolation=<span class="string">'nearest'</span>, cmap=<span class="string">'bone'</span>, origin=<span class="string">'lower'</span>)</span><br></pre></td></tr></table></figure>

<p>我们之前选cmap的参数时用的是：<code>cmap=plt.cmap.bone</code>，而现在，我们可以直接用单引号传入参数。 <code>origin=&#39;lower&#39;</code>代表的就是选择的原点的位置。</p>
<h4 id="出图方式"><a href="#出图方式" class="headerlink" title="出图方式"></a>出图方式</h4><p>我们在这个<a href="http://matplotlib.org/examples/images_contours_and_fields/interpolation_methods.html" target="_blank" rel="noopener">链接</a> 可以看到<strong>matplotlib</strong>官网上对于内插法的不同方法的描述。下图是一个示例：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_4_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_4_2.png" alt="Image 图片"></a></p>
<p>这里我们使用的是内插法中的 <a href="https://en.wikipedia.org/wiki/Nearest-neighbor_interpolation" target="_blank" rel="noopener">Nearest-neighbor</a> 的方法，其他的方式也都可以随意取选。</p>
<h4 id="colorbar"><a href="#colorbar" class="headerlink" title="colorbar"></a>colorbar</h4><p>下面我们添加一个<code>colorbar</code> ，其中我们添加一个<code>shrink</code>参数，使<code>colorbar</code>的长度变短为原来的92%：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.colorbar(shrink=<span class="number">.92</span>)</span><br><span class="line"></span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>这样我们2D图像就创建完毕了。</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_4_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_4_1.png" alt="Image 图片"></a></p>
<h3 id="3D-数据"><a href="#3D-数据" class="headerlink" title="3D 数据"></a>3D 数据</h3><h4 id="3D-图"><a href="#3D-图" class="headerlink" title="3D 图"></a>3D 图</h4><p>首先在进行 <code>3D Plot</code> 时除了导入 <code>matplotlib</code> ，还要额外添加一个模块，即 <code>Axes 3D</code> 3D 坐标轴显示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br></pre></td></tr></table></figure>

<p>之后要先定义一个图像窗口，在窗口上添加3D坐标轴，显示成下图：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fig = plt.figure()</span><br><span class="line">ax = Axes3D(fig)</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/3_5_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_5_2.png" alt="3D 数据"></a></p>
<p>接下来给进 X 和 Y 值，并将 X 和 Y 编织成栅格。每一个（X, Y）点对应的高度值我们用下面这个函数来计算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># X, Y value</span></span><br><span class="line">X = np.arange(<span class="number">-4</span>, <span class="number">4</span>, <span class="number">0.25</span>)</span><br><span class="line">Y = np.arange(<span class="number">-4</span>, <span class="number">4</span>, <span class="number">0.25</span>)</span><br><span class="line">X, Y = np.meshgrid(X, Y)    <span class="comment"># x-y 平面的网格</span></span><br><span class="line">R = np.sqrt(X ** <span class="number">2</span> + Y ** <span class="number">2</span>)</span><br><span class="line"><span class="comment"># height value</span></span><br><span class="line">Z = np.sin(R)</span><br></pre></td></tr></table></figure>

<p>今天的结果是这样的：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_5_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_5_1.png" alt="3D 数据"></a></p>
<p>做出一个三维曲面，并将一个 <code>colormap rainbow</code> 填充颜色，之后将三维图像投影到 XY 平面上做一个等高线图。 plot 3D 图像：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.plot_surface(X, Y, Z, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>, cmap=plt.get_cmap(<span class="string">'rainbow'</span>))</span><br></pre></td></tr></table></figure>

<p>其中，<code>rstride</code> 和 <code>cstride</code> 分别代表 row 和 column 的跨度。</p>
<p>下面两个图分别是跨度为1 和 5 的效果：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_5_3.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_5_3.png" alt="3D 数据"></a></p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_5_4.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_5_4.png" alt="3D 数据"></a></p>
<h4 id="投影"><a href="#投影" class="headerlink" title="投影"></a>投影</h4><p>下面添加 XY 平面的等高线：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax.contourf(X, Y, Z, zdir=<span class="string">'z'</span>, offset=<span class="number">-2</span>, cmap=plt.get_cmap(<span class="string">'rainbow'</span>))</span><br></pre></td></tr></table></figure>

<p>如果 <code>zdir</code> 选择了x，那么效果将会是对于 XZ 平面的投影，效果如下：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_5_5.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_5_5.png" alt="3D 数据"></a></p>
<p>最终我们的结果如下图：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/3_5_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/3_5_1.png" alt="3D 数据"></a></p>
<h2 id="多图合并显示"><a href="#多图合并显示" class="headerlink" title="多图合并显示"></a>多图合并显示</h2><h3 id="Subplot-多合一显示"><a href="#Subplot-多合一显示" class="headerlink" title="Subplot 多合一显示"></a>Subplot 多合一显示</h3><h4 id="均匀图中图"><a href="#均匀图中图" class="headerlink" title="均匀图中图"></a>均匀图中图</h4><p>matplotlib 是可以组合许多的小图, 放在一张大图里面显示的. 使用到的方法叫作 subplot.</p>
<p>使用<code>import</code>导入<code>matplotlib.pyplot</code>模块, 并简写成<code>plt</code>. 使用<code>plt.figure</code>创建一个图像窗口.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br></pre></td></tr></table></figure>

<p>使用<code>plt.subplot</code>来创建小图. <code>plt.subplot(2,2,1)</code>表示将整个图像窗口分为2行2列, 当前位置为1. 使用<code>plt.plot([0,1],[0,1])</code>在第1个位置创建一个小图.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p><code>plt.subplot(2,2,2)</code>表示将整个图像窗口分为2行2列, 当前位置为2. 使用<code>plt.plot([0,1],[0,2])</code>在第2个位置创建一个小图.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><code>plt.subplot(2,2,3)</code>表示将整个图像窗口分为2行2列,当前位置为3. <code>plt.subplot(2,2,3)</code>可以简写成<code>plt.subplot(223)</code>, matplotlib同样可以识别. 使用<code>plt.plot([0,1],[0,3])</code>在第3个位置创建一个小图.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p><code>plt.subplot(224)</code>表示将整个图像窗口分为2行2列, 当前位置为4. 使用<code>plt.plot([0,1],[0,4])</code>在第4个位置创建一个小图.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">plt.show()  <span class="comment"># 展示</span></span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/4_1_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/4_1_1.png" alt="Subplot 多合一显示"></a></p>
<h4 id="不均匀图中图"><a href="#不均匀图中图" class="headerlink" title="不均匀图中图"></a>不均匀图中图</h4><p>如果希望展示的小图的大小不相同, 应该怎么做呢? 以上面的4个小图为例, 如果把第1个小图放到第一行, 而剩下的3个小图都放到第二行.</p>
<p>使用<code>plt.subplot(2,1,1)</code>将整个图像窗口分为2行1列, 当前位置为1. 使用<code>plt.plot([0,1],[0,1])</code>在第1个位置创建一个小图.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>使用<code>plt.subplot(2,3,4)</code>将整个图像窗口分为2行3列, 当前位置为4. 使用<code>plt.plot([0,1],[0,2])</code>在第4个位置创建一个小图.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>这里需要解释一下为什么第4个位置放第2个小图. 上一步中使用<code>plt.subplot(2,1,1)</code>将整个图像窗口分为2行1列, 第1个小图占用了第1个位置, 也就是整个第1行. 这一步中使用<code>plt.subplot(2,3,4)</code>将整个图像窗口分为2行3列, 于是整个图像窗口的第1行就变成了3列, 也就是成了3个位置, 于是第2行的第1个位置是整个图像窗口的第4个位置.</p>
<p>使用<code>plt.subplot(235)</code>将整个图像窗口分为2行3列,当前位置为5. 使用<code>plt.plot([0,1],[0,3])</code>在第5个位置创建一个小图. 同上, 再创建<code>plt.subplot(236)</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">235</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">236</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">plt.show()  <span class="comment"># 展示</span></span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/4_1_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/4_1_2.png" alt="Subplot 多合一显示"></a></p>
<h3 id="Subplot-分格显示"><a href="#Subplot-分格显示" class="headerlink" title="Subplot 分格显示"></a>Subplot 分格显示</h3><p>matplotlib 的 subplot 还可以是分格的,这里介绍三种方法.</p>
<h4 id="subplot2grid"><a href="#subplot2grid" class="headerlink" title="subplot2grid"></a>subplot2grid</h4><p>使用<code>import</code>导入<code>matplotlib.pyplot</code>模块, 并简写成<code>plt</code>. 使用<code>plt.figure()</code>创建一个图像窗口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br></pre></td></tr></table></figure>

<p>使用<code>plt.subplot2grid</code>来创建第1个小图, <code>(3,3)</code>表示将整个图像窗口分成3行3列, <code>(0,0)</code>表示从第0行第0列开始作图，<code>colspan=3</code>表示列的跨度为3, <code>rowspan=1</code>表示行的跨度为1. <code>colspan</code>和<code>rowspan</code>缺省, 默认跨度为1.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax1 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">0</span>), colspan=<span class="number">3</span>)</span><br><span class="line">ax1.plot([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">2</span>])    <span class="comment"># 画小图</span></span><br><span class="line">ax1.set_title(<span class="string">'ax1_title'</span>)  <span class="comment"># 设置小图的标题</span></span><br></pre></td></tr></table></figure>

<p>使用<code>plt.subplot2grid</code>来创建第2个小图, <code>(3,3)</code>表示将整个图像窗口分成3行3列, <code>(1,0)</code>表示从第1行第0列开始作图，<code>colspan=2</code>表示列的跨度为2. 同上画出 <code>ax3</code>, <code>(1,2)</code>表示从第1行第2列开始作图，<code>rowspan=2</code>表示行的跨度为2. 再画一个 <code>ax4</code> 和 <code>ax5</code>, 使用默认 <code>colspan, rowspan</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ax2 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">0</span>), colspan=<span class="number">2</span>)</span><br><span class="line">ax3 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>), rowspan=<span class="number">2</span>)</span><br><span class="line">ax4 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">0</span>))</span><br><span class="line">ax5 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<p>使用<code>ax4.scatter</code>创建一个散点图, 使用<code>ax4.set_xlabel</code>和<code>ax4.set_ylabel</code>来对x轴和y轴命名.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax4.scatter([<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">2</span>])</span><br><span class="line">ax4.set_xlabel(<span class="string">'ax4_x'</span>)</span><br><span class="line">ax4.set_ylabel(<span class="string">'ax4_y'</span>)</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/4_2_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/4_2_1.png" alt="Subplot 分格显示"></a></p>
<h4 id="gridspec"><a href="#gridspec" class="headerlink" title="gridspec"></a>gridspec</h4><p>使用<code>import</code>导入<code>matplotlib.pyplot</code>模块, 并简写成<code>plt</code>. 使用<code>import</code>导入<code>matplotlib.gridspec</code>, 并简写成<code>gridspec</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br></pre></td></tr></table></figure>

<p>使用<code>plt.figure()</code>创建一个图像窗口, 使用<code>gridspec.GridSpec</code>将整个图像窗口分成3行3列.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">gs = gridspec.GridSpec(<span class="number">3</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>使用<code>plt.subplot</code>来作图, <code>gs[0, :]</code>表示这个图占第0行和所有列, <code>gs[1, :2]</code>表示这个图占第1行和第2列前的所有列, <code>gs[1:, 2]</code>表示这个图占第1行后的所有行和第2列, <code>gs[-1, 0]</code>表示这个图占倒数第1行和第0列, <code>gs[-1, -2]</code>表示这个图占倒数第1行和倒数第2列.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ax6 = plt.subplot(gs[<span class="number">0</span>, :])</span><br><span class="line">ax7 = plt.subplot(gs[<span class="number">1</span>, :<span class="number">2</span>])</span><br><span class="line">ax8 = plt.subplot(gs[<span class="number">1</span>:, <span class="number">2</span>])</span><br><span class="line">ax9 = plt.subplot(gs[<span class="number">-1</span>, <span class="number">0</span>])</span><br><span class="line">ax10 = plt.subplot(gs[<span class="number">-1</span>, <span class="number">-2</span>])</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/4_2_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/4_2_2.png" alt="Subplot 分格显示"></a></p>
<h4 id="subplots"><a href="#subplots" class="headerlink" title="subplots"></a>subplots</h4><p>使用<code>plt.subplots</code>建立一个2行2列的图像窗口，<code>sharex=True</code>表示共享x轴坐标, <code>sharey=True</code>表示共享y轴坐标. <code>((ax11, ax12), (ax13, ax14))</code>表示第1行从左至右依次放<code>ax11</code>和<code>ax12</code>, 第2行从左至右依次放<code>ax13</code>和<code>ax14</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f, ((ax11, ax12), (ax13, ax14)) = plt.subplots(<span class="number">2</span>, <span class="number">2</span>, sharex=<span class="literal">True</span>, sharey=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>使用<code>ax11.scatter</code>创建一个散点图.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax11.scatter([<span class="number">1</span>,<span class="number">2</span>], [<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p><code>plt.tight_layout()</code>表示紧凑显示图像, <code>plt.show()</code>表示显示图像.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/4_2_3.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/4_2_3.png" alt="Subplot 分格显示"></a></p>
<h3 id="图中图"><a href="#图中图" class="headerlink" title="图中图"></a>图中图</h3><p>这次我们来讲matplotlib里一个很有意思的功能，叫做图中图(plot in plot)，最后的效果如下：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/4_3_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/4_3_1.png" alt="图中图"></a></p>
<p>可以看到，整个Figure 1包含了三个图，其中两个小图<code>title inside 1</code>和<code>title inside 2</code>又出现在大图<code>title</code>中。这是如何做到的呢？</p>
<h4 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h4><p>首先是一些准备工作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入pyplot模块</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化figure</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure>



<h4 id="大图"><a href="#大图" class="headerlink" title="大图"></a>大图</h4><p>接着，我们来绘制大图。首先确定大图左下角的位置以及宽高：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">left, bottom, width, height = <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.8</span></span><br></pre></td></tr></table></figure>

<p>注意，4个值都是占整个<code>figure</code>坐标系的百分比。在这里，假设<code>figure</code>的大小是10x10，那么大图就被包含在由(1, 1)开始，宽8，高8的坐标系内。</p>
<p>将大图坐标系添加到<code>figure</code>中，颜色为r(red)，取名为title：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ax1 = fig.add_axes([left, bottom, width, height])</span><br><span class="line">ax1.plot(x, y, <span class="string">'r'</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line">ax1.set_title(<span class="string">'title'</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/4_3_2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/4_3_2.png" alt="图中图"></a></p>
<h4 id="小图"><a href="#小图" class="headerlink" title="小图"></a>小图</h4><p>接着，我们来绘制左上角的小图，步骤和绘制大图一样，注意坐标系位置和大小的改变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">left, bottom, width, height = <span class="number">0.2</span>, <span class="number">0.6</span>, <span class="number">0.25</span>, <span class="number">0.25</span></span><br><span class="line">ax2 = fig.add_axes([left, bottom, width, height])</span><br><span class="line">ax2.plot(y, x, <span class="string">'b'</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">'x'</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">'y'</span>)</span><br><span class="line">ax2.set_title(<span class="string">'title inside 1'</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><a href="https://morvanzhou.github.io/static/results/plt/4_3_3.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/4_3_3.png" alt="图中图"></a></p>
<p>最后，我们来绘制右下角的小图。这里我们采用一种更简单方法，即直接往plt里添加新的坐标系：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.axes([<span class="number">0.6</span>, <span class="number">0.2</span>, <span class="number">0.25</span>, <span class="number">0.25</span>])</span><br><span class="line">plt.plot(y[::<span class="number">-1</span>], x, <span class="string">'g'</span>) <span class="comment"># 注意对y进行了逆序处理</span></span><br><span class="line">plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'y'</span>)</span><br><span class="line">plt.title(<span class="string">'title inside 2'</span>)</span><br></pre></td></tr></table></figure>

<p>最后显示图像：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/4_3_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/4_3_1.png" alt="图中图"></a></p>
<h3 id="次坐标轴"><a href="#次坐标轴" class="headerlink" title="次坐标轴"></a>次坐标轴</h3><p> 第一个y坐标 </p>
<p>有时候我们会用到次坐标轴，即在同个图上有第2个y轴存在。同样可以用matplotlib做到，而且很简单。</p>
<p>首先，我们做一些准备工作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">y1 = <span class="number">0.05</span> * x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">y2 = <span class="number">-1</span> * y1</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>y2</code>和<code>y1</code>是互相倒置的。接着，获取figure默认的坐标系 <code>ax1</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fig, ax1 = plt.subplots()</span><br></pre></td></tr></table></figure>



<h4 id="第二个y坐标"><a href="#第二个y坐标" class="headerlink" title="第二个y坐标"></a>第二个y坐标</h4><p>对<code>ax1</code>调用<code>twinx()</code>方法，生成如同镜面效果后的<code>ax2</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ax2 = ax1.twinx()</span><br></pre></td></tr></table></figure>

<p>接着进行绘图, 将 <code>y1</code>, <code>y2</code> 分别画在 <code>ax1</code>, <code>ax2</code> 上：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ax1.plot(x, y1, <span class="string">'g-'</span>)   <span class="comment"># green, solid line</span></span><br><span class="line"></span><br><span class="line">ax1.set_xlabel(<span class="string">'X data'</span>)</span><br><span class="line"></span><br><span class="line">ax1.set_ylabel(<span class="string">'Y1 data'</span>, color=<span class="string">'g'</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot(x, y2, <span class="string">'b-'</span>) <span class="comment"># blue</span></span><br><span class="line"></span><br><span class="line">ax2.set_ylabel(<span class="string">'Y2 data'</span>, color=<span class="string">'b'</span>)</span><br></pre></td></tr></table></figure>

<p>显示图像：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/4_4_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/4_4_1.png" alt="次坐标轴"></a></p>
<h2 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h2><h3 id="Animation-动画"><a href="#Animation-动画" class="headerlink" title="Animation 动画"></a>Animation 动画</h3><h4 id="定义方程"><a href="#定义方程" class="headerlink" title="定义方程"></a>定义方程</h4><p>使用matplotlib做动画也是可以的，我们使用其中一种方式，function animation来说说， 具体可参考<a href="http://matplotlib.sourceforge.net/api/animation_api.html" target="_blank" rel="noopener">matplotlib animation api</a>。首先，我们做一些准备工作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">fig, ax = plt.subplots()</span><br></pre></td></tr></table></figure>

<p>我们的数据是一个0~2π内的正弦曲线：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">0.01</span>)</span><br><span class="line">line, = ax.plot(x, np.sin(x))</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/plt/5_1_1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/plt/5_1_1.png" alt="Animation 动画"></a></p>
<p>接着，构造自定义动画函数<code>animate</code>，用来更新每一帧上各个<code>x</code>对应的<code>y</code>坐标值，参数表示第i帧：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">animate</span><span class="params">(i)</span>:</span></span><br><span class="line">    line.set_ydata(np.sin(x + i/<span class="number">10.0</span>))</span><br><span class="line">    <span class="keyword">return</span> line,</span><br></pre></td></tr></table></figure>

<p>然后，构造开始帧函数<code>init</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">()</span>:</span></span><br><span class="line">    line.set_ydata(np.sin(x))</span><br><span class="line">    <span class="keyword">return</span> line,</span><br></pre></td></tr></table></figure>



<h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><p>接下来，我们调用<code>FuncAnimation</code>函数生成动画。参数说明：</p>
<ol>
<li><code>fig</code> 进行动画绘制的figure</li>
<li><code>func</code> 自定义动画函数，即传入刚定义的函数<code>animate</code></li>
<li><code>frames</code> 动画长度，一次循环包含的帧数</li>
<li><code>init_func</code> 自定义开始帧，即传入刚定义的函数<code>init</code></li>
<li><code>interval</code> 更新频率，以ms计</li>
<li><code>blit</code> 选择更新所有点，还是仅更新产生变化的点。应选择<code>True</code>，但mac用户请选择<code>False</code>，否则无法显示动画</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ani = animation.FuncAnimation(fig=fig,</span><br><span class="line">                              func=animate,</span><br><span class="line">                              frames=<span class="number">100</span>,</span><br><span class="line">                              init_func=init,</span><br><span class="line">                              interval=<span class="number">20</span>,</span><br><span class="line">                              blit=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>显示动画：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>当然，你也可以将动画以mp4格式保存下来，但首先要保证你已经安装了<code>ffmpeg</code> 或者<code>mencoder</code>， 更多信息参考<a href="http://matplotlib.sourceforge.net/api/animation_api.html" target="_blank" rel="noopener">matplotlib animation api</a>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ani.save(<span class="string">'basic_animation.mp4'</span>, fps=<span class="number">30</span>, extra_args=[<span class="string">'-vcodec'</span>, <span class="string">'libx264'</span>])</span><br></pre></td></tr></table></figure>








          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiantian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天天的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/20/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CCNN/" itemprop="url">卷积神经网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-20T16:38:09+08:00">
                2020-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">神经网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="卷积神经网络"><a href="#卷积神经网络" class="headerlink" title="卷积神经网络"></a>卷积神经网络</h1><h2 id="卷积层（Convolutional-layer）"><a href="#卷积层（Convolutional-layer）" class="headerlink" title="卷积层（Convolutional layer）"></a>卷积层（Convolutional layer）</h2><p>卷积层是卷积神经网络的核心基石。</p>
<p><strong>作用是提取图像特征</strong></p>
<p>重要特性：</p>
<ul>
<li>局部连接</li>
<li>权重共享</li>
</ul>
<p>卷积层的计算过程</p>
<p><img src="F:%5Cworkspace%5Cpython%5C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%5CKeras&%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%5Cimages%5Cdl_3_12.gif" alt="dl_3_12"></p>
<p>滑动步长：stride</p>
<p>滤波器（卷积核）：filter（高度必须与输入特征图一致,在一层卷积操作里可以有多个filter，他们是尺寸必须相同）</p>
<p>在图像外围加0的圈数：+pad n（加n圈0）</p>
<ul>
<li>目的主要是使卷积后的图像大小与原图像大小相同</li>
</ul>
<p>一次卷积后的输出特征的尺寸是多少呢？</p>
<p>$ h_{out}=\frac{h_{in}-Filter+2*Pad}{Stride}+1​$</p>
<p>$w_{out}=\frac{w_{in}-Filter+2*Pad}{Stride}+1​$</p>
<h2 id="激励层（ReLU-）"><a href="#激励层（ReLU-）" class="headerlink" title="激励层（ReLU ）"></a>激励层（ReLU ）</h2><p>把所有负数变成0</p>
<p><img src="/images%5C1093303-20170430194958725-2144325242.png" alt="1093303-20170430194958725-2144325242"></p>
<h2 id="池化层（Pooling-layer）"><a href="#池化层（Pooling-layer）" class="headerlink" title="池化层（Pooling layer）"></a>池化层（Pooling layer）</h2><p>池化（pool）即下采样（downsamples），目的是为了减少特征图，主要作用是通过减少网络的参数来减小计算量，并且能够在一定程度上控制过拟合。</p>
<p>池化操作对每个深度切片独立，规模一般为 2＊2，相对于卷积层进行卷积运算</p>
<p>池化层进行的运算一般有以下几种： </p>
<ul>
<li><p>最大池化（Max Pooling）。取4个点的最大值。这是最常用的池化 方法。 </p>
</li>
<li><p>均值池化（Mean Pooling）。取4个点的均值。 </p>
</li>
<li><p>高斯池化。借鉴高斯模糊的方法。不常用。 </p>
</li>
<li><p>可训练池化。训练函数 ff ，接受4个点为输入，出入1个点。不常用。</p>
<p>池化操作将保存深度大小不变。如果池化层的输入单元大小不是二的整数倍，一般采取边缘补零（zero-padding）的方式补成2的倍数，然后再池化。</p>
</li>
</ul>
<h2 id="全连接层（-Fully-Connected-layer）"><a href="#全连接层（-Fully-Connected-layer）" class="headerlink" title="全连接层（ Fully-Connected layer）"></a>全连接层（ Fully-Connected layer）</h2><p>识别目标部分</p>
<h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><h2 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h2><p>卷积——激活——卷积——激活——池化——……——池化——全连接——分类或回归</p>
<h2 id="典型CNN"><a href="#典型CNN" class="headerlink" title="典型CNN"></a>典型CNN</h2><p>卷积神经网络之典型CNN<br>　　• LeNet，这是最早用于数字识别的CNN<br>　　• AlexNet， 2012 ILSVRC比赛远超第2名的CNN，比<br>　　• LeNet更深，用多层小卷积层叠加替换单大卷积层。<br>　　• ZF Net， 2013 ILSVRC比赛冠军<br>　　• GoogLeNet， 2014 ILSVRC比赛冠军<br>　　• VGGNet， 2014 ILSVRC比赛中的模型，图像识别略差于GoogLeNet，但是在很多图像转化学习问题(比如object detection)上效果奇好</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/Keras/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiantian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天天的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/20/Keras/" itemprop="url">Keras</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-20T16:37:09+08:00">
                2020-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index">
                    <span itemprop="name">神经网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#Keras</p>
<h2 id="兼容backend"><a href="#兼容backend" class="headerlink" title="兼容backend"></a>兼容backend</h2><p>我们来介绍 Keras 的两个 Backend，也就是Keras基于什么东西来做运算。</p>
<p>Keras 可以基于两个Backend，一个是 Theano，一个是 Tensorflow。如果我们选择Theano作为Keras的Backend， 那么Keras就用 Theano 在底层搭建你需要的神经网络；同样，如果选择 Tensorflow 的话呢，Keras 就使用 Tensorflow 在底层搭建神经网络。</p>
<h3 id="查看Backend"><a href="#查看Backend" class="headerlink" title="查看Backend"></a>查看Backend</h3><p>每次当我们<code>import keras</code>的时候，就会看到屏幕显示当前使用的 Backend</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Using TensorFlow backend.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>

<h3 id="修改Backend"><a href="#修改Backend" class="headerlink" title="修改Backend"></a>修改Backend</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python2+输入:</span></span><br><span class="line">KERAS_BACKEND=tensorflow python -c <span class="string">"from keras import backend"</span></span><br><span class="line"><span class="comment"># python3+输入:</span></span><br><span class="line">KERAS_BACKEND=tensorflow python3 -c <span class="string">"from keras import backend"</span></span><br></pre></td></tr></table></figure>





<h2 id="Regressor-回归"><a href="#Regressor-回归" class="headerlink" title="Regressor 回归"></a>Regressor 回归</h2><p>神经网络可以用来模拟回归问题 (regression)，例如给下面一组数据，用一条线来对数据进行拟合，并可以预测新输入 <code>x</code> 的输出值。</p>
<h2 id="导入模块并创建数据"><a href="#导入模块并创建数据" class="headerlink" title="导入模块并创建数据"></a>导入模块并创建数据</h2><p><code>models.Sequential</code>，用来一层一层一层的去建立神经层； <code>layers.Dense</code> 意思是这个神经层是全连接层。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">np.random.seed(<span class="number">1337</span>)  <span class="comment"># for reproducibility</span></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential	<span class="comment"># 按顺序建立模型</span></span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense	<span class="comment"># 全连接层</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt <span class="comment"># 可视化模块</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create some data</span></span><br><span class="line">X = np.linspace(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">200</span>)</span><br><span class="line">np.random.shuffle(X)    <span class="comment"># randomize the data</span></span><br><span class="line">Y = <span class="number">0.5</span> * X + <span class="number">2</span> + np.random.normal(<span class="number">0</span>, <span class="number">0.05</span>, (<span class="number">200</span>, ))</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot data</span></span><br><span class="line">plt.scatter(X, Y)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">X_train, Y_train = X[:<span class="number">160</span>], Y[:<span class="number">160</span>]     <span class="comment"># train 前 160 data points</span></span><br><span class="line">X_test, Y_test = X[<span class="number">160</span>:], Y[<span class="number">160</span>:]       <span class="comment"># test 后 40 data points</span></span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/keras/2-1-1.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/keras/2-1-1.png" alt="Regressor 回归"></a></p>
<h2 id="建立模型"><a href="#建立模型" class="headerlink" title="建立模型"></a>建立模型</h2><p>然后用 <code>Sequential</code> 建立 <code>model</code>， 再用 <code>model.add</code> 添加神经层，添加的是 <code>Dense</code> 全连接神经层。</p>
<p>参数有两个，一个是输入数据和输出数据的维度，本代码的例子中 <code>x</code> 和 <code>y</code> 是一维的。</p>
<p>如果需要添加下一个神经层的时候，不用再定义输入的纬度，因为它默认就把前一层的输出作为当前层的输入。在这个例子里，只需要一层就够了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(output_dim=<span class="number">1</span>, input_dim=<span class="number">1</span>))</span><br></pre></td></tr></table></figure>



<h2 id="激活模型"><a href="#激活模型" class="headerlink" title="激活模型"></a>激活模型</h2><p>接下来要激活神经网络，上一步只是定义模型。</p>
<p>参数中，误差函数用的是 <code>mse</code> 均方误差；优化器用的是 <code>sgd</code> 随机梯度下降法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># choose loss function and optimizing method</span></span><br><span class="line">model.compile(loss=<span class="string">'mse'</span>, optimizer=<span class="string">'sgd'</span>)</span><br></pre></td></tr></table></figure>

<p>以上三行就构建好了一个神经网络，它比 Tensorflow 要少了很多代码，很简单。</p>
<h2 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h2><p>训练的时候用 <code>model.train_on_batch</code> 一批一批的训练 <code>X_train</code>, <code>Y_train</code>。默认的返回值是 <code>cost</code>，每100步输出一下结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># training</span></span><br><span class="line">print(<span class="string">'Training -----------'</span>)</span><br><span class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">301</span>):</span><br><span class="line">    cost = model.train_on_batch(X_train, Y_train)</span><br><span class="line">    <span class="keyword">if</span> step % <span class="number">100</span> == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'train cost: '</span>, cost)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Training -----------</span></span><br><span class="line"><span class="string">train cost:  4.111329555511475</span></span><br><span class="line"><span class="string">train cost:  0.08777070790529251</span></span><br><span class="line"><span class="string">train cost:  0.007415373809635639</span></span><br><span class="line"><span class="string">train cost:  0.003544030711054802</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h2 id="检验模型"><a href="#检验模型" class="headerlink" title="检验模型"></a>检验模型</h2><p>用到的函数是 <code>model.evaluate</code>，输入测试集的<code>x</code>和<code>y</code>， 输出 <code>cost</code>，<code>weights</code> 和 <code>biases</code>。其中 <code>weights</code> 和 <code>biases</code> 是取在模型的第一层 <code>model.layers[0]</code> 学习到的参数。从学习到的结果你可以看到, weights 比较接近0.5，bias 接近 2。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test</span></span><br><span class="line">print(<span class="string">'\nTesting ------------'</span>)</span><br><span class="line">cost = model.evaluate(X_test, Y_test, batch_size=<span class="number">40</span>)</span><br><span class="line">print(<span class="string">'test cost:'</span>, cost)</span><br><span class="line">W, b = model.layers[<span class="number">0</span>].get_weights()</span><br><span class="line">print(<span class="string">'Weights='</span>, W, <span class="string">'\nbiases='</span>, b)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Testing ------------</span></span><br><span class="line"><span class="string">40/40 [==============================] - 0s</span></span><br><span class="line"><span class="string">test cost: 0.004269329831</span></span><br><span class="line"><span class="string">Weights= [[ 0.54246825]] </span></span><br><span class="line"><span class="string">biases= [ 2.00056005]</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<h2 id="可视化结果"><a href="#可视化结果" class="headerlink" title="可视化结果"></a>可视化结果</h2><p>最后可以画出预测结果，与测试集的值进行对比。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># plotting the prediction</span></span><br><span class="line">Y_pred = model.predict(X_test)</span><br><span class="line">plt.scatter(X_test, Y_test)</span><br><span class="line">plt.plot(X_test, Y_pred)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p><a href="https://morvanzhou.github.io/static/results/keras/2-1-2.png" target="_blank" rel="noopener"><img src="https://morvanzhou.github.io/static/results/keras/2-1-2.png" alt="Regressor 回归"></a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E6%B1%87%E7%BC%96%EF%BC%88%E4%BA%8C%EF%BC%898086%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiantian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天天的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/20/%E6%B1%87%E7%BC%96%EF%BC%88%E4%BA%8C%EF%BC%898086%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" itemprop="url">汇编（二）8086的指令系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-20T16:35:09+08:00">
                2020-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index">
                    <span itemprop="name">汇编</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><span id="目录"></span></p>
<h1 id="第二章-8086的指令系统"><a href="#第二章-8086的指令系统" class="headerlink" title="第二章 8086的指令系统"></a>第二章 8086的指令系统</h1><p><strong>imm 立即数</strong></p>
<p><strong>reg 寄存器</strong></p>
<p><strong>mem 内存</strong></p>
<p><strong>seg 段寄存器</strong></p>
<p><a href="#目录">返回目录</a></p>
<h2 id="学习指令的注意事项"><a href="#学习指令的注意事项" class="headerlink" title="学习指令的注意事项"></a>学习指令的注意事项</h2><ul>
<li>指令的功能<ul>
<li>该指令能够实现何种操作。通常指令助记符就是指令功能的英文单词或其缩写形式</li>
</ul>
</li>
<li>指令支持的寻址方式<ul>
<li>该指令中的操作数可以采用何种寻址方式</li>
</ul>
</li>
<li>指令对标志的影响<ul>
<li>该指令执行后是否对各个标志位有影响，以及如何影响</li>
</ul>
</li>
<li>其他方面<ul>
<li>该指令其他需要特别注意的地方，如指令执行时的约定设置、必须预置的参数、隐含使用的寄存器等</li>
</ul>
</li>
</ul>
<h2 id="2-1-数据传送类指令"><a href="#2-1-数据传送类指令" class="headerlink" title="2.1 数据传送类指令"></a>2.1 数据传送类指令</h2><p><a href="#通用传送类指令">通用传送类指令</a></p>
<p><a href="#栈堆操作指令">栈堆操作指令</a></p>
<p><a href="#标志传送指令">标志传送指令</a></p>
<p><a href="#地址传送指令">地址传送指令</a></p>
<h3 id="2-1-1-通用数据传送类指令"><a href="#2-1-1-通用数据传送类指令" class="headerlink" title="2.1.1 通用数据传送类指令"></a>2.1.1 <span id="通用传送类指令">通用数据传送类指令</span></h3><p>除标志寄存器传送指令外，均不影响标志位</p>
<p><a href="#MOV">传送指令MOV</a>   <a href="#XCHG">交换指令XCHG</a>  <a href="#XLAT">换码指令XLAT</a></p>
<h4 id="传送指令MOV"><a href="#传送指令MOV" class="headerlink" title="传送指令MOV"></a><span id="MOV">传送指令MOV</span></h4><p>把一个字节或字的操作数从源地址传送至目的地址</p>
<p><strong>1、立即数传送</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al,4				；al←04h，字节传送</span><br><span class="line">mov cx,0ffh				；cx←00ffh，字传送</span><br><span class="line">mov si,200h				；si←0200h，字传送</span><br><span class="line">mov byte ptr [si],0ah   ；byte ptr 说明是字节操作</span><br><span class="line">mov word ptr [si+2],0bh ；word ptr 说明是字操作</span><br></pre></td></tr></table></figure>

<p><strong>2、寄存器传送</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx	；ax←bx，字传送</span><br><span class="line">mov ah,al	；ah←al，字节传送</span><br><span class="line">mov ds,ax	；ds←ax，字传送</span><br><span class="line">mov [bx],al	；[bx]←al，字节传送</span><br></pre></td></tr></table></figure>

<p><strong>3：存储器(内存)传送</strong></p>
<p>小端对齐</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,[bx]</span><br><span class="line">mov dx,[bp]	；dx←ss:[bp]</span><br><span class="line">mov es,[si]	；es←ds:[si]</span><br></pre></td></tr></table></figure>

<p>不存在存储器向存储器的传送指令! （类型无法确定）</p>
<p><strong>4：段寄存器传送</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov [si],ds</span><br><span class="line"></span><br><span class="line">mov ax,es	；ax←es</span><br><span class="line">mov ds,ax	；ds←ax←es</span><br></pre></td></tr></table></figure>

<p>对段寄存器的操作有一些限制，不允许段寄存器之间的直接数据传送</p>
<p><img src="images/1583808043805.png" alt="1583808043805"></p>
<p><strong>注意：</strong></p>
<ul>
<li>MOV并非任意传送</li>
<li>绝大多数双操作数指令，除非特别说明，目的操作数与源操作数必须类型一致，否则为非法指令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV AL,050AH    ；非法指令：050Ah为字，而AL为字节</span><br></pre></td></tr></table></figure>

<ul>
<li>寄存器有明确的字节或字类型，<strong>有寄存器参与的指令其操作数类型就是寄存器的类型</strong></li>
<li>对于<strong>存储器单元与立即数同时作为操作数</strong>的情况，必须显式指明；byte ptr指示字节类型，word ptr指示字类型</li>
<li>8086指令系统不允许两个操作数都是存储单元（除串操作指令），要实现这种传送，可通过寄存器间接实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,buffer1  ；ax←buffer1（将buffer1内容送ax）</span><br><span class="line">mov buffer2,ax  ；buffer2←ax</span><br><span class="line">&#x2F;&#x2F;buffer1和buffer2是两个字变量；实际表示直接寻址方式</span><br></pre></td></tr></table></figure>

<ul>
<li>不允许立即数传送给段寄存器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV DS,100H  ；非法指令：立即数不能传送段寄存器</span><br></pre></td></tr></table></figure>

<ul>
<li>不允许直接改变CS值，<a href="#jump">改变CS/IP的指令</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV CS,[SI]	；不允许使用的指令</span><br></pre></td></tr></table></figure>

<ul>
<li>不允许段寄存器之间的直接数据传送</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV DS,ES    ；非法指令：不允许段寄存器间传送</span><br></pre></td></tr></table></figure>

<p><img src="images/1583808373302.png" alt="1583808373302"></p>
<h4 id="交换指令XCHG（exchange）"><a href="#交换指令XCHG（exchange）" class="headerlink" title="交换指令XCHG（exchange）"></a><span id="XCHG">交换指令XCHG（exchange）</span></h4><p>把两个地方的数据进行互换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XCHG reg,reg&#x2F;mem   ；reg &lt;-&gt; reg&#x2F;mem</span><br></pre></td></tr></table></figure>



<p>寄存器与寄存器之间对换数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1234h      ；ax&#x3D;1234h</span><br><span class="line">mov bx,5678h      ；bx&#x3D;5678h</span><br><span class="line">xchg ax,bx        ；ax&#x3D;5678h，bx&#x3D;1234h</span><br><span class="line">xchg ah,al        ；ax&#x3D;7856h</span><br></pre></td></tr></table></figure>

<p>寄存器与存储器之间对换数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xchg ax,[2000h]		；字交换等同于 xchg [2000h],ax</span><br><span class="line">xchg al,[2000h] 	；字节交换等同于 xchg [2000h],al</span><br></pre></td></tr></table></figure>

<p>不能在存储器与存储器之间对换数据</p>
<p>原因和mov指令中的原因相同，无法确定存储器的大小（格式）</p>
<h4 id="换码指令XLAT（translate）"><a href="#换码指令XLAT（translate）" class="headerlink" title="换码指令XLAT（translate）"></a><span id="XLAT">换码指令XLAT（translate）</span></h4><p>将BX指定的缓冲区中、AL指定的位移处的<strong>一个字节数</strong>据取出赋给AL</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XLAT	；al←ds:[bx+al]</span><br></pre></td></tr></table></figure>

<ul>
<li>换码指令执行前：<ul>
<li>主存建立一个字节量表格，含要转换成的目的代码</li>
<li>表格首地址存放于<strong>BX</strong>，<strong>AL</strong>存放相对表格首的位移量</li>
</ul>
</li>
<li>换码指令执行后：将<strong>AL</strong>寄存器的内容转换为目标代码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,100h</span><br><span class="line">mov al,03h</span><br><span class="line">xlat</span><br></pre></td></tr></table></figure>

<p>换码指令没有显式的操作数，但使用了BX和AL；因为换码指令使用了隐含寻址方式(采用默认操作数)</p>
<h3 id="2-1-2-堆栈操作指令"><a href="#2-1-2-堆栈操作指令" class="headerlink" title="2.1.2 堆栈操作指令"></a>2.1.2 <span id="栈堆操作指令">堆栈操作指令</span></h3><p>堆栈：具有特殊访问方式的存储空间；特殊之处：按照后进先出(LIFO)的原则组织（堆栈:LIFO，队列:FIFO）</p>
<p><strong>SS</strong>段寄存器记录其<strong>段地址</strong>；用堆栈指针寄存器<strong>SP</strong>指定<strong>栈顶</strong>（唯一出口）</p>
<p>堆栈只有两种基本操作：<strong>进栈(PUSH)和出栈(POP)</strong></p>
<p>栈顶为低位，栈底为高位，每个字占两位</p>
<p><strong>PUSH；</strong>进栈指令先使堆栈指针SP减2，然后把一个字操作数存入堆栈顶部</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PUSH  r16&#x2F;m16&#x2F;seg  ；r16&#x2F;m16&#x2F;seg：一个16位的寄存器  或者段寄存器或者内存单元</span><br><span class="line"> 1) SP← SP－2</span><br><span class="line"> 2) SS:[SP]←r16&#x2F;m16&#x2F;seg</span><br></pre></td></tr></table></figure>

<p><strong>POP；</strong>出栈指令把栈顶的一个字传送至指定的目的操作数，然后堆栈指针SP加2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POP r16&#x2F;m16&#x2F;seg</span><br><span class="line"> 1) r16&#x2F;m16&#x2F;seg←SS:[SP]</span><br><span class="line"> 2) SP←SP＋2</span><br></pre></td></tr></table></figure>

<p><strong>堆栈的特点</strong></p>
<ul>
<li><p>堆栈操作的<strong>单位是字</strong>，进栈和出栈只对字量</p>
</li>
<li><p>字量数据从栈顶压入和弹出时，都是低<strong>地址字节送低字节，高地址字节送高字节</strong></p>
</li>
<li><p>堆栈操作遵循先进后出原则，但<strong>可用存储器寻址方式随机存取堆栈中的数据</strong></p>
</li>
<li><p>堆栈常用来</p>
<ul>
<li>临时存放数据</li>
<li>传递参数</li>
<li>保存和恢复寄存器</li>
</ul>
</li>
</ul>
<h3 id="2-1-3-标志传送指令"><a href="#2-1-3-标志传送指令" class="headerlink" title="2.1.3 标志传送指令"></a>2.1.3 <span id="标志传送指令">标志传送指令</span></h3><p>标志寄存器传送指令用来传送标志寄存器FLAGS的内容，方便进行对各个标志位的直接操作</p>
<p><strong>有2对4条指令</strong></p>
<ul>
<li>低8位传送：LAHF和SAHF</li>
<li>16位传送：PUSHF和POPF</li>
</ul>
<p>标志位操作指令直接对CF、DF、IF标志进行复位或置位</p>
<p><strong>标志位：</strong></p>
<ul>
<li>状态标志:CF,OF,ZF,SF,PF,AF</li>
<li>控制标志:DF,IF,TF</li>
</ul>
<h4 id="标志低字节进出AH指令"><a href="#标志低字节进出AH指令" class="headerlink" title="标志低字节进出AH指令"></a>标志低字节进出AH指令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LAHF 	；AH←FLAGS的低字节</span><br><span class="line">将标志寄存器的低字节送寄存器AH</span><br><span class="line">SF&#x2F;ZF&#x2F;AF&#x2F;PF&#x2F;CF状态标志位分别送入AH的第7&#x2F;6&#x2F;4&#x2F;2&#x2F;0位，而AH的第5&#x2F;3&#x2F;1位任意</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SAHF	；FLAGS的低字节←AH</span><br><span class="line">SAHF将AH寄存器内容送FLAGS的低字节</span><br><span class="line">用AH的第7&#x2F;6&#x2F;4&#x2F;2&#x2F;0位相应设置SF&#x2F;ZF&#x2F;AF&#x2F; PF&#x2F;CF标志</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUSHF	</span><br><span class="line">；SP←SP－2</span><br><span class="line">；SS:[SP]←FLAGS</span><br><span class="line">PUSHF指令将标志寄存器的内容压入堆栈，同时栈顶指针SP减2</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POPF	</span><br><span class="line">；FLAGS←SS:[SP]</span><br><span class="line">；SP←SP＋2</span><br><span class="line">POPF指令将栈顶字单元内容送标志寄存器，同时栈顶指针SP加2</span><br></pre></td></tr></table></figure>

<p>例：置位单步标志  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pushf		；保存全部标志到堆栈</span><br><span class="line">pop ax		；堆栈中取出全部标志</span><br><span class="line">or ax,0100h	；设置D8&#x3D;TF&#x3D;1，</span><br><span class="line">			；ax其他位不变</span><br><span class="line">push ax		；将ax压入堆栈</span><br><span class="line">popf		；FLAGS←AX</span><br><span class="line">			；将堆栈内容取到标志寄存器</span><br></pre></td></tr></table></figure>

<ul>
<li>标志寄存器传送指令：传送标志寄存器FLAGS的内容，方便进行对各个标志位的直接操作<ul>
<li>低8位传送：LAHF和SAHF</li>
<li>16位传送：PUSHF和POPF</li>
</ul>
</li>
<li>标志位操作指令：直接对CF、DF、IF标志进行复位或置位，常用于特定的情况(不影响其他标志)</li>
<li>对标志位进行设置的指令<ul>
<li>CLC    STC    CMC</li>
<li>CLD    STD</li>
<li>CLI      STI</li>
</ul>
</li>
</ul>
<p><strong>进位标志操作指令,用于任意设置进位标志</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CLC	；复位进位标志：CF←0</span><br><span class="line">STC	；置位进位标志：CF←1</span><br><span class="line">CMC	；求反进位标志：CF←～CF</span><br></pre></td></tr></table></figure>

<p>方向标志操作指令,串操作指令中需要使用  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLD	；复位方向标志：DF←0</span><br><span class="line">STD	；置位方向标志：DF←1</span><br></pre></td></tr></table></figure>

<p>中断标志操作指令,在编写中断服务程序时，需要控制可屏蔽中断的允许和禁止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CLI	；复位中断标志：IF←0</span><br><span class="line">STI	；置位中断标志：IF←1</span><br></pre></td></tr></table></figure>



<h3 id="2-1-4-地址传送指令"><a href="#2-1-4-地址传送指令" class="headerlink" title="2.1.4 地址传送指令"></a>2.1.4 <span id="地址传送指令">地址传送指令</span></h3><p>地址传送指令将存储器单元的逻辑地址送至指定的寄存器</p>
<ul>
<li>有效地址传送指令  LEA</li>
<li>指针传送指令  LDS和LES</li>
</ul>
<p>注意不是获取存储器单元的内容</p>
<h4 id="有效地址传送指令LEA（load-EA）"><a href="#有效地址传送指令LEA（load-EA）" class="headerlink" title="有效地址传送指令LEA（load EA）"></a>有效地址传送指令LEA（load EA）</h4><p>将存储器操作数的有效地址传送至指定的16位寄存器中</p>
<blockquote>
<p> <strong>LEA r16,mem  ；r16 ← mem的有效地址EA（偏移地址）</strong></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">mov bx,0400h</span><br><span class="line">mov si,3ch</span><br><span class="line">lea bx,[bx+si+0f62h]</span><br><span class="line">；BX＝0400h＋003ch＋0f62h＝139EH</span><br><span class="line"></span><br><span class="line">lea:获得主存单元的有效地址；不是物理地址，也不是该单元的内容,可以实现计算功能</span><br></pre></td></tr></table></figure>

<h4 id="指针传送指令"><a href="#指针传送指令" class="headerlink" title="指针传送指令"></a>指针传送指令</h4><p><strong>LDS指令</strong>将主存中mem指定的字送至r16，并将mem的下一字送<strong>DS寄存器</strong></p>
<blockquote>
<p>LDS r16,mem<br>；r16←mem，<br>；DS←mem+2</p>
</blockquote>
<p><strong>LES指令</strong>将主存中mem指定的字送至r16，并将mem的下一字送<strong>ES寄存器</strong></p>
<blockquote>
<p>LES r16,mem<br>；r16←mem，<br>；ES←mem+2</p>
</blockquote>
<p>例:地址指针传送</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr [3060h],0100h</span><br><span class="line">mov word ptr [3062h],1450h</span><br><span class="line">les di,[3060h]；es&#x3D;1450h，di&#x3D;0100h</span><br><span class="line">lds si,[3060h]；ds&#x3D;1450h，si&#x3D;0100h</span><br></pre></td></tr></table></figure>

<p>mem指定主存的连续4个字节作为逻辑地址（32位的地址指针），送入DS:r16或ES:r16</p>
<h2 id="2-2-算术运算指令"><a href="#2-2-算术运算指令" class="headerlink" title="2.2 算术运算指令"></a>2.2 算术运算指令</h2><p>加法指令ADD</p>
<p>减法指令</p>
<p>乘法指令</p>
<p>除法指令</p>
<p>符号扩展指令</p>
<p>十进制/BCD码调整指令</p>
<h3 id="2-2-1-加法指令"><a href="#2-2-1-加法指令" class="headerlink" title="2.2.1 加法指令"></a>2.2.1 加法指令</h3><h4 id="加法指令ADD"><a href="#加法指令ADD" class="headerlink" title="加法指令ADD"></a>加法指令ADD</h4><p>ADD指令将源与目的操作数相加，结果送到目的操作数</p>
<p>ADD指令按状态标志的定义相应设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ADD reg,imm&#x2F;reg&#x2F;mem	；reg←reg＋imm&#x2F;reg&#x2F;mem</span><br><span class="line">ADD mem,imm&#x2F;reg   	；mem←mem＋imm&#x2F;reg</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al,0fbh	                            ；al&#x3D;0fbh</span><br><span class="line">add al,07h	                            ；al&#x3D;02h</span><br><span class="line">mov word ptr [200h],4652h    			；[200h]&#x3D;4652h</span><br><span class="line">mov bx,1feh	                            ；bx&#x3D;1feh</span><br><span class="line">add al,bl	                            ；al&#x3D;00h</span><br><span class="line">add word ptr [bx+2],0f0f0h     			；[200h]&#x3D;3742h</span><br><span class="line"># 可以调试看看各标志位的情况</span><br></pre></td></tr></table></figure>

<h4 id="带进位加法指令ADC"><a href="#带进位加法指令ADC" class="headerlink" title="带进位加法指令ADC"></a>带进位加法指令ADC</h4><p>ADC指令将源与目的操作数相加，再加上进位CF标志，结果送到目的操作数</p>
<p>ADC指令按状态标志的定义相应设置</p>
<p>ADC指令主要与ADD配合，实现<strong>多字节加法运算</strong></p>
<blockquote>
<p>ADC reg,imm/reg/mem    ；reg←reg＋imm/reg/mem＋CF<br>ADC mem,imm/reg         ；mem←mem＋imm/reg＋CF</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 例</span><br><span class="line">mov ax,4652h	；ax&#x3D;4652h</span><br><span class="line">add ax,0f0f0h	；ax&#x3D;3742h，CF&#x3D;1</span><br><span class="line">mov dx,0234h	；dx&#x3D;0234h，CF&#x3D;1</span><br><span class="line">adc dx,0f0f0h	；dx&#x3D;f325h，CF&#x3D;0</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>多字节相加</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DH&#x3D;0002H    AX&#x3D;0F356H</span><br><span class="line">BX&#x3D;0005H    CX&#x3D;0E024H</span><br><span class="line"></span><br><span class="line">ADD  AX, CX	;执行后，AX&#x3D; 0D389H   CF&#x3D;1</span><br><span class="line">ADC  DX, BX	;执行后，DX&#x3D; 0008H    CF&#x3D;0</span><br></pre></td></tr></table></figure>

<img src="images/1584075787952.png" width=50%>
</blockquote>
<h4 id="增量指令INC（increment）"><a href="#增量指令INC（increment）" class="headerlink" title="增量指令INC（increment）"></a>增量指令INC（increment）</h4><p>INC指令对操作数加1（增量）</p>
<p>INC指令不影响进位CF标志，按定义设置其他状态标志</p>
<blockquote>
<p>INC reg/mem           ；reg/mem←reg/mem＋1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 例</span><br><span class="line">inc bx</span><br><span class="line">inc byte ptr [bx]</span><br></pre></td></tr></table></figure>



<h3 id="2-2-2-减法指令"><a href="#2-2-2-减法指令" class="headerlink" title="2.2.2 减法指令"></a>2.2.2 减法指令</h3><h4 id="减法指令SUB（subtract）"><a href="#减法指令SUB（subtract）" class="headerlink" title="减法指令SUB（subtract）"></a>减法指令SUB（subtract）</h4><p>SUB指令将目的操作数减去源操作数，结果送到目的操作数</p>
<p>SUB指令按照定义相应设置状态标志</p>
<blockquote>
<p>SUB reg,imm/reg/mem    ；reg←reg－imm/reg/mem<br>SUB mem,imm/reg        ；mem←mem－imm/reg</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov al,0fbh                	    ；al&#x3D;0fbh</span><br><span class="line">sub al,07h	                    ；al&#x3D;0f4h，CF＝0</span><br><span class="line">mov word ptr [200h],4652h       ；[200h]&#x3D;4652h</span><br><span class="line">mov bx,1feh	                    ；bx&#x3D;1feh</span><br><span class="line">sub al,bl	                    ；al&#x3D;0f6h</span><br><span class="line">sub word ptr [bx+2],0f0f0h      ；[200h]&#x3D;5562h，CF＝1</span><br></pre></td></tr></table></figure>



<h4 id="带借位减法指令SBB"><a href="#带借位减法指令SBB" class="headerlink" title="带借位减法指令SBB"></a>带借位减法指令SBB</h4><p>SBB指令将目的操作数减去源操作数，再减去借位CF（进位），结果送到目的操作数。</p>
<p>SBB指令按照定义相应设置状态标志</p>
<p>SBB指令主要与SUB配合，实现多精度减法运算</p>
<blockquote>
<p>SBB reg,imm/reg/mem   ；reg←reg－imm/reg/mem－CF<br>SBB mem,imm/reg         ；mem←mem－imm/reg－CF</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4652h	；ax&#x3D;4652h</span><br><span class="line">sub ax,0f0f0h	；ax&#x3D;5562h，CF&#x3D;1</span><br><span class="line"></span><br><span class="line">mov dx,0234h	；dx&#x3D;0234h</span><br><span class="line">sbb dx,0f0f0h	；dx&#x3D;1143h，CF&#x3D;1</span><br></pre></td></tr></table></figure>



<h4 id="减量指令DEC（decrement）"><a href="#减量指令DEC（decrement）" class="headerlink" title="减量指令DEC（decrement）"></a>减量指令DEC（decrement）</h4><p>DEC指令对操作数减1（减量）</p>
<p>DEC指令不影响进位CF标志，按定义设置其他状态标志</p>
<p>INC指令和DEC指令都是单操作数指令，主要用于对计数器和地址指针的调整</p>
<blockquote>
<p>DEC reg/mem   ；reg/mem←reg/mem－1</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dec cx</span><br><span class="line">dec word ptr [si]</span><br></pre></td></tr></table></figure>

<h4 id="求补指令NEG（negative）"><a href="#求补指令NEG（negative）" class="headerlink" title="求补指令NEG（negative）"></a>求补指令NEG（negative）</h4><p>NEG指令对操作数执行求补运算：用零减去操作数，然后结果返回操作数，也可以表达成：<strong>将操作数按位取反后加1</strong></p>
<p>NEG指令对标志的影响与用零作减法的SUB指令一样</p>
<blockquote>
<p>NEG reg/mem；reg/mem←0－reg/mem</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0ff64h</span><br><span class="line">neg al          ；ax&#x3D;ff9ch，OF&#x3D;0、SF&#x3D;1、ZF&#x3D;0、PF&#x3D;1、CF&#x3D;1</span><br><span class="line">sub al,9dh 		；ax&#x3D;ffffh，OF&#x3D;0、SF&#x3D;1、ZF&#x3D;0、PF&#x3D;1、CF&#x3D;1</span><br><span class="line">neg ax        	；ax&#x3D;0001h，OF&#x3D;0、SF&#x3D;0、ZF&#x3D;0、PF&#x3D;0、CF&#x3D;1</span><br><span class="line">dec al         	；ax&#x3D;0000h，OF&#x3D;0、SF&#x3D;0、ZF&#x3D;1、PF&#x3D;1、CF&#x3D;1</span><br><span class="line">neg ax        	；ax&#x3D;0000h，OF&#x3D;0、SF&#x3D;0、ZF&#x3D;1、PF&#x3D;1、CF&#x3D;0</span><br></pre></td></tr></table></figure>

<h4 id="比较指令CMP（compare）"><a href="#比较指令CMP（compare）" class="headerlink" title="比较指令CMP（compare）"></a>比较指令CMP（compare）</h4><p>MP指令执行的功能与SUB指令，但<strong>结果不回送目的操作数</strong></p>
<p>CMP指令将目的操作数减去源操作数，执行CMP之后，可以<strong>根据标志位判断</strong>两个数是否相等、大小关系等</p>
<blockquote>
<p>CMP reg, imm/reg/mem    ；reg－imm/reg/mem<br>CMP mem, imm/reg           ；mem－imm/reg</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 比较AL与100</span><br><span class="line">	cmp al,100	；al-100</span><br><span class="line">	jb below	；al&lt;100，跳转到below执行</span><br><span class="line">	sub al,100	；al≥100，al←al-100</span><br><span class="line">	inc ah	    ；ah←ah+1</span><br><span class="line">below:	...</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">习题</span><br><span class="line">例：x、y、z均为双精度无符号数，分别存放在地址为X, X+2；Y, Y+2；Z, Z+2的存储单元中，用指令序列实现w &lt;-- x+y+24-z ，并用W, W+2单元存放w。</span><br></pre></td></tr></table></figure>



<h3 id="2-2-3-乘法指令"><a href="#2-2-3-乘法指令" class="headerlink" title="2.2.3 乘法指令"></a>2.2.3 乘法指令</h3><p>乘法指令分无符号和有符号乘法指令</p>
<h4 id="无符号乘法"><a href="#无符号乘法" class="headerlink" title="无符号乘法"></a>无符号乘法</h4><blockquote>
<p><strong>MUL r8/m8</strong><br>；无符号字节乘法<br>；AX←AL×r8/m8<br><strong>MUL r16/m16</strong><br>；无符号字乘法<br>；DX.AX←AX×r16/m16</p>
</blockquote>
<h4 id="有符号乘法"><a href="#有符号乘法" class="headerlink" title="有符号乘法"></a>有符号乘法</h4><blockquote>
<p><strong>IMUL r8/m8</strong><br>；有符号字节乘法<br>；AX←AL×r8/m8<br><strong>IMUL r16/m16</strong><br>；有符号字乘法<br>；DX.AX←AX×r16/m16 </p>
</blockquote>
<p><font color=red>功能</font></p>
<p>乘法指令的源操作数显式给出，隐含使用另一个操作数AX和DX</p>
<ul>
<li>字节量相乘：AL与r8/m8相乘，得到16位的结果，<strong>存入AX</strong></li>
<li>字量相乘：AX与r16/m16相乘，得到32位的结果，<strong>其高字存入DX，低字存入AX</strong></li>
</ul>
<p>乘法指令利用OF和CF判断乘积的高一半是否具有有效数值</p>
<p><font color=red>乘法指令对标志的影响</font></p>
<p>乘法指令如下影响OF和CF标志：</p>
<blockquote>
<p><strong>MUL指令——若乘积的高一半（AH或DX）为0，则OF=CF=0；否则OF=CF=1</strong></p>
<p><strong>IMUL指令——若乘积的高一半是低一半的符号扩展，则OF=CF=0；否则均为1</strong></p>
</blockquote>
<p>乘法指令对其他状态标志<strong>没有定义</strong></p>
<blockquote>
<p>对标志没有定义：指令执行后这些标志是任意的、不可预测（就是谁也不知道是0还是1）<br> 对标志没有影响：指令执行不改变标志状态</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">例：(AX) &#x3D; 16A5H，(BX) &#x3D; 0611H</span><br><span class="line">   </span><br><span class="line">  (1) IMUL BL    ;(AX) &lt;-- (AL) * (BL)</span><br><span class="line">                 ;A5*11 &#x3D;&#x3D;&gt; 5B*11&#x3D; 060B &#x3D;&#x3D;&gt; F9F5</span><br><span class="line">                 # 因为A5是负数，所以运算时要取补</span><br><span class="line">                 ;(AX) &#x3D; 0F9F5H</span><br><span class="line"></span><br><span class="line">  (2) MUL  BX    ;(DX, AX)&lt;--(AX) * (BX)</span><br><span class="line">                 ;  16A5*0611&#x3D;0089 5EF5</span><br><span class="line">                 ;  (DX) &#x3D; 0089H  (AX) &#x3D; 5EF5H</span><br></pre></td></tr></table></figure>



<h3 id="2-2-4-除法指令"><a href="#2-2-4-除法指令" class="headerlink" title="2.2.4 除法指令"></a>2.2.4 除法指令</h3><p>除法指令分无符号和有符号除法指令</p>
<h4 id="无符号除法"><a href="#无符号除法" class="headerlink" title="无符号除法"></a>无符号除法</h4><blockquote>
<p>DIV r8/m8      ；无符号字节除法：<br>AL←AX÷r8/m8的商，Ah←AX÷r8/m8的余数<br>DIV r16/m16      ；无符号字除法：<br>；AX←DX.AX÷r16/m16的商，DX←DX.AX÷r16/m16的余数</p>
</blockquote>
<h4 id="有符号除法"><a href="#有符号除法" class="headerlink" title="有符号除法"></a>有符号除法</h4><blockquote>
<p>IDIV r8/m8      ；有符号字节除法：<br>AL←AX÷r8/m8的商，Ah←AX÷r8/m8的余数<br>IDIV r16/m16       ；有符号字除法：<br>；AX←DX.AX÷r16/m16的商，DX←DX.AX÷r16/m16的余数</p>
</blockquote>
<p><font color=red>功能</font></p>
<p>除法指令的除数显式给出，隐含使用另一个操作数<strong>AX和DX作为被除数</strong></p>
<ul>
<li>字节量除法：AX除以r8/m8，8位商存入AL，8位余数存入AH</li>
<li>字量除法：DX.AX除以r16/m16，16位商存入AX，16位余数存入DX</li>
</ul>
<p>除法指令对标志没有定义</p>
<p>除法指令会产生结果溢出</p>
<p><font color=red>除法错中断</font></p>
<p>当被除数远大于除数时，所得的商就有可能超出它所能表达的范围。如果存放商的寄存器AL/AX不能表达，便产生溢出，8086CPU中就产生编号为0的内部中断——<strong>除法错中断</strong></p>
<blockquote>
<p>DIV指令：除数为0，在字节除时商超过8位，或者在字除时商超过16位<br>IDIV指令：除数为0，在字节除时商不在-128～127范围内或者在字除时商不在-32768～32767范围内</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0400h	；ax&#x3D;400h&#x3D;1024</span><br><span class="line">mov bl,0b4h		；bl&#x3D;b4h&#x3D;180</span><br><span class="line">div bl			；商al＝05h＝5</span><br><span class="line">				；余数ah＝7ch＝124</span><br><span class="line">				</span><br><span class="line">mov ax,0400h	；ax&#x3D;400h&#x3D;1024</span><br><span class="line">mov bl,0b4h		；bl&#x3D;b4h&#x3D;－76</span><br><span class="line">idiv bl			；商al＝f3h＝－13</span><br><span class="line">				；余数ah＝24h＝36</span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-符号扩展指令"><a href="#2-2-5-符号扩展指令" class="headerlink" title="2.2.5 符号扩展指令"></a>2.2.5 符号扩展指令</h3><p>符号扩展指令常用于获得倍长的数据</p>
<blockquote>
<p><strong>CBW（Byte-Word）        ；AL的符号扩展至AH</strong><br>；如AL的最高有效位是0，则AH＝00<br>；AL的最高有效位为1，则AH＝FFH。AL不变</p>
</blockquote>
<blockquote>
<p><strong>CWD（Word-Dword）        ；AX的符号扩展至DX</strong><br>；如AX的最高有效位是0，则DX＝00<br>；AX的最高有效位为1，则DX＝FFFFH。AX不变</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,80h	；al&#x3D;80h</span><br><span class="line">cbw			；ax&#x3D;ff80h</span><br><span class="line">add al,255	；al&#x3D;7fh</span><br><span class="line">cbw			；ax&#x3D;007fh</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例：AX÷BX</span><br><span class="line">cwd			；DX.AX←AX</span><br><span class="line">idiv bx		；AX←DX.AX÷BX</span><br></pre></td></tr></table></figure>

<p><font color=red>保险起见</font></p>
<p>对有符号数除法：可以利用符号扩展指令得到倍长于除数的被除数</p>
<p>对无符号数除法：<strong>采用直接使高8位或高16位清0，获得倍长的被除数。这就是零位扩展</strong></p>
<h3 id="2-2-6-十进制-BCD码调整指令"><a href="#2-2-6-十进制-BCD码调整指令" class="headerlink" title="2.2.6 十进制/BCD码调整指令"></a>2.2.6 十进制/BCD码调整指令</h3><p>十进制数调整指令对二进制运算的结果进行十进制调整，以得到十进制的运算结果</p>
<p>分成压缩BCD码和非压缩BCD码调整</p>
<blockquote>
<p><strong>压缩BCD码</strong>就是通常的8421码；<br>它用4个二进制位表示一个十进制位，一个字节可以表示两个十进制位，即00～99</p>
</blockquote>
<blockquote>
<p><strong>非压缩BCD码</strong><br>用8个二进制位表示一个十进制位，只用低4个二进制位表示一个十进制位0～9，高4位任意，通常默认为0</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">真值</th>
<th align="center">8d</th>
<th align="center">64d</th>
</tr>
</thead>
<tbody><tr>
<td align="center">二进制编码</td>
<td align="center">08H</td>
<td align="center">40H</td>
</tr>
<tr>
<td align="center">压缩BCD码</td>
<td align="center">08H</td>
<td align="center">64H</td>
</tr>
<tr>
<td align="center">非压缩BCD码</td>
<td align="center">08H</td>
<td align="center">0604H</td>
</tr>
</tbody></table>
<p><font color=red>调整指令</font></p>
<p><strong>压缩BCD码调整指令：DAA/DAS</strong></p>
<ul>
<li>“DAA”和“DAS”指令必须紧跟在相应的加法指令和减法指令后面</li>
<li>调整的数据只能是<strong>AL</strong>中的内容</li>
<li>DAA和DAS指令对OF标志无定义，按结果影响其他标志，例如CF反映压缩BCD码相加或减的进位或借位状态</li>
</ul>
<p><strong>非压缩BCD码调整指令</strong></p>
<ul>
<li>AAA（ASCII Adjust for Addition）</li>
<li>AAS（ASCII Adjust for Subtraction）</li>
<li>AAM（ASCII Adjust for Multiplication）</li>
<li>AAD（ASCII Adjust for Division）</li>
</ul>
<h4 id="DAA"><a href="#DAA" class="headerlink" title="DAA"></a>DAA</h4><p><font color=red>格式</font></p>
<blockquote>
<p>ADD BCD1,BCD2<br>DAA</p>
</blockquote>
<p><font color=red>算法</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (al 低4位 &gt;9  ||  AF&#x3D;1) &#x2F;&#x2F;非法的BCD码出现</span><br><span class="line">&#123;</span><br><span class="line">    al +&#x3D; 6H;</span><br><span class="line">    AF &#x3D; 1;	   	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(al 高4位 &gt;9  ||  CF&#x3D;1)</span><br><span class="line">&#123;</span><br><span class="line">    al +&#x3D; 60H;</span><br><span class="line">    CF &#x3D; 1;   		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标志寄存器：</p>
<ul>
<li>CF反应BCD码的进/借位；</li>
<li>OF无定义；SF和ZF一般规则。</li>
</ul>
<h4 id="DAS"><a href="#DAS" class="headerlink" title="DAS"></a>DAS</h4><p><font color=red>格式</font></p>
<blockquote>
<p>SUB BCD1,BCD2<br>DAS</p>
</blockquote>
<p><font color=red>算法</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if (al 低4位 &gt;9  ||  AF&#x3D;1) &#x2F;&#x2F;非法的BCD码出现</span><br><span class="line">&#123;</span><br><span class="line">	al －&#x3D; 6;</span><br><span class="line">	AF &#x3D; 1;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if( al 高4位 &gt;9  ||  CF&#x3D;1) &#x2F;&#x2F;非法的BCD码出现</span><br><span class="line">&#123;</span><br><span class="line">	al －&#x3D; 60H;</span><br><span class="line">	CF &#x3D; 1;  	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="压缩BCD码加、减调整指令"><a href="#压缩BCD码加、减调整指令" class="headerlink" title="压缩BCD码加、减调整指令"></a>压缩BCD码加、减调整指令</h4><p>例：压缩BCD加法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al,68h  	 ；al&#x3D;68h，压缩BCD码表示真值68</span><br><span class="line">mov bl,28h 		 ；bl&#x3D;28h，压缩BCD码表示真值28</span><br><span class="line">add al,bl        ；二进制加法：al&#x3D;68h+28h&#x3D;90h</span><br><span class="line">daa              ；十进制调整：al&#x3D;96h</span><br><span class="line">；实现压缩BCD码加法：68＋28＝96</span><br></pre></td></tr></table></figure>

<p>例：压缩BCD减法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al,68h   	  ；al&#x3D;68h，压缩BCD码表示真值68</span><br><span class="line">mov bl,28h   	  ；bl&#x3D;28h，压缩BCD码表示真值28</span><br><span class="line">sub al,bl         ；二进制减法：al&#x3D;68h-28h&#x3D;40h</span><br><span class="line">das               ；十进制调整：al&#x3D;40h</span><br><span class="line">；实现压缩BCD码减法：68-28＝40</span><br></pre></td></tr></table></figure>

<p>例：压缩BCD减法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1234h</span><br><span class="line">mov bx,4612h</span><br><span class="line">sub al,bl					；al&#x3D;34h-12h&#x3D;22h, CF&#x3D;0</span><br><span class="line">das							；al&#x3D;34-12＝22，CF＝0</span><br><span class="line">xchg al,ah                  ；al&#x3D;12 ah&#x3D;22</span><br><span class="line">sbb al,bh                   ；al&#x3D;12-46-0&#x3D;cc(二进制),</span><br><span class="line">Das                			；al&#x3D;12-46＝66, CF&#x3D;1(112-46&#x3D;66，十进制)</span><br><span class="line">xchg al,ah					；ax&#x3D;6622</span><br></pre></td></tr></table></figure>

<p>习题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">设X、Y、Z、V均为16位带符号数，分别存放在X、Y、Z、V存储单元中，阅读如下程序段，得出它的运算公式，并说明运算结果存于何处？</span><br><span class="line">mov ax,X</span><br><span class="line">imul Y			;DX.AX&#x3D;X*Y</span><br><span class="line">mov cx,ax</span><br><span class="line">mov bx,dx		;BX.CX&#x3D;X*Y</span><br><span class="line">mov ax,Z		</span><br><span class="line">cwd				;DX.AX&#x3D;Z</span><br><span class="line">add cx,ax</span><br><span class="line">adc bx,dx		;BX.CX&#x3D;BX.CX+DX.AX，BX.CX&#x3D;X*Y+Z</span><br></pre></td></tr></table></figure>

<p><img src="images/1584414439641.png" alt="1584414439641"></p>
<h2 id="2-3-位操作类指令"><a href="#2-3-位操作类指令" class="headerlink" title="2.3 位操作类指令"></a>2.3 位操作类指令</h2><p>逻辑运算指令<br>AND  OR  XOR  NOT   TEST</p>
<p>移位指令<br>SHL  SHR   SAL  SAR  ROL  ROR  RCL  RCR</p>
<h3 id="1-逻辑运算指令"><a href="#1-逻辑运算指令" class="headerlink" title="1. 逻辑运算指令"></a>1. 逻辑运算指令</h3><p><strong>逻辑与</strong>指令：<strong>AND</strong>  DST, SRC<br>执行操作：    (DST) $\gets$ (DST) ^ (SRC)<br>用途：用于屏蔽一个数的某些位。</p>
<p><strong>逻辑或</strong>指令：<strong>OR</strong>  DST, SRC<br>执行操作：    (DST) $\gets$  (DST) $\lor​$ (SRC)<br>用途：用于置位一个数的某些位。</p>
<p><strong>异或</strong>指令：    <strong>XOR</strong>  DST, SRC<br>执行操作：    (DST) $\gets$  (DST) 异或 (SRC)<br>用途：将一个数的某些位取反。</p>
<p><strong>测试</strong>指令：    <strong>TEST</strong>  OPR1, OPR2<br>执行操作：    (OPR1) ^ (OPR2)<br>用途：用于测试一个数的某些位。</p>
<p><strong>逻辑非</strong>指令：<strong>NOT</strong>  OPR      *  OPR不能为立即数<br>执行操作：    (OPR) $\gets$! (OPR)           *  不影响标志位<br>功能：           按位取反</p>
<h3 id="2-移位指令"><a href="#2-移位指令" class="headerlink" title="2. 移位指令"></a>2. 移位指令</h3><h4 id="逻辑SHL-SHR（Shift-Lift-Right）"><a href="#逻辑SHL-SHR（Shift-Lift-Right）" class="headerlink" title="逻辑SHL/SHR（Shift Lift/Right）"></a>逻辑SHL/SHR（Shift Lift/Right）</h4><blockquote>
<p>格式：SHL Dst,Src</p>
<p>功能：将Dst的内容左移1～n位，右边添0。</p>
<p>说明：Dst—reg，mem；Src—1或CL</p>
<p>注意：逻辑左移1位等价于将一个无符号数乘以2。</p>
</blockquote>
<blockquote>
<p>格式：SHR Dst,Src</p>
<p>功能：将Dst的内容右移1～n位，左边添0。</p>
<p>注意：逻辑右移一位等价于将一个无符号数除以2(整除)</p>
</blockquote>
<h4 id="算术SAL-SAR-Shift-Arithmetic"><a href="#算术SAL-SAR-Shift-Arithmetic" class="headerlink" title="算术SAL/SAR (Shift Arithmetic)"></a>算术SAL/SAR (Shift Arithmetic)</h4><blockquote>
<p>算术左移  SAL  （同逻辑左移SHL）</p>
</blockquote>
<blockquote>
<p>算术右移  SAR</p>
<p>格式：SAR Dst,Src</p>
<p>功能：将Dst的内容右移1～n位，最高位不变\</p>
<p>算术右移一位等价于将一个带符号数除以2 (整除)</p>
<p>注意：当操作数为负数且最低位有1移出时，SAR与IDIV结果不同，如-1右移后为-1，不为0</p>
</blockquote>
<h4 id="循环ROL-ROR-Rotate"><a href="#循环ROL-ROR-Rotate" class="headerlink" title="循环ROL/ROR (Rotate)"></a>循环ROL/ROR (Rotate)</h4><blockquote>
<p>循环左移  ROL  Dst,Src</p>
</blockquote>
<blockquote>
<p>循环右移  ROR  Dst,Src</p>
</blockquote>
<h4 id="带进位循环RCL-RCR-（Rotate-carry）"><a href="#带进位循环RCL-RCR-（Rotate-carry）" class="headerlink" title="带进位循环RCL/RCR （Rotate carry）"></a>带进位循环RCL/RCR （Rotate carry）</h4><blockquote>
<p>带进位循环左移  RCL  Dst,Src</p>
</blockquote>
<blockquote>
<p>带进位循环右移  RCR  Dst,Src</p>
</blockquote>
<img src="images/1584420791061.png" width=50%>

<h4 id="共同特点"><a href="#共同特点" class="headerlink" title="共同特点"></a>共同特点</h4><ul>
<li>都是按位进行</li>
<li>当移动的位数为一位时，用立即数1；</li>
<li>当移动二位或二位以上时，要预先将移动的位数存放在CL中。</li>
<li>SHL AL, 2 $\to$ MOV CL,2     ; SHL AL,CL;</li>
</ul>
<h4 id="移位指令对标志的影响"><a href="#移位指令对标志的影响" class="headerlink" title="移位指令对标志的影响"></a>移位指令对标志的影响</h4><ul>
<li>按照移入的位设置进位标志CF</li>
<li>根据移位后的结果影响SF、ZF、PF</li>
<li>AF：没有定义</li>
<li>如果进行一位移动，则按照操作数的最高符号位是否改变，相应设置溢出标志OF：<ul>
<li>操作数最高位有变化，则OF = 1；否则OF = 0。</li>
</ul>
</li>
<li>当移位次数大于1时，OF不确定</li>
</ul>
<h2 id="2-4-控制转移指令"><a href="#2-4-控制转移指令" class="headerlink" title="2.4 控制转移指令"></a>2.4 控制转移指令</h2><p>无条件转移指令<br>条件转移指令<br>循环指令<br>子程序调用和返回指令<br>中断指令</p>
<h3 id="无条件转移指令（jump）"><a href="#无条件转移指令（jump）" class="headerlink" title="无条件转移指令（jump）"></a>无条件转移指令（jump）</h3><p><strong>格式</strong>：JMP  地址表达式</p>
<p><strong>功能</strong>：使程序的流程<strong>无条件</strong>跳到转移地址所指的地方。</p>
<ul>
<li>转移目的地址＝(CS)×16+(IP)</li>
<li><strong>段内转移</strong>：改变IP的内容，CS的内容不变。<ul>
<li>近转移（near）<ul>
<li>在当前代码段216=64KB范围内转移（ ±32KB范围）</li>
<li>不需要更改CS段地址，只要改变IP偏移地址</li>
</ul>
</li>
<li>短转移（short）<ul>
<li>转移范围可以用一个字节表达，在段内 $2^8$=－128～＋127范围的转移</li>
</ul>
</li>
</ul>
</li>
<li><strong>段间转移</strong>：IP、CS的内容都改变。<ul>
<li>远转移（far）<ul>
<li>从当前代码段跳转到另一个代码段，可以在<strong>1MB</strong>范围</li>
<li>更改CS段地址和IP偏移地址</li>
<li>目标地址必须用一个32位数表达，叫做32位远指针，它就是逻辑地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>实际编程时，MASM汇编程序会根据目标地址的距离，自动处理成短转移、近转移或远转移<br>程序员可用操作符short、near ptr 或far ptr 强制</p>
<p><font color=red>段内转移</font></p>
<p><strong>段内直接转移——相对寻址</strong></p>
<p>JMP label    ；IP←IP+位移量</p>
<p>位移量是紧接着JMP指令后的那条指令的偏移地址，到目标指令的偏移地址的地址位移</p>
<p>向地址增大方向转移时，位移量为正；向地址减小方向转移时，位移量为负</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">again:	dec cx	；标号again的指令</span><br><span class="line">		……</span><br><span class="line">		jmp again	；转移到again处继续执行</span><br><span class="line">		……</span><br><span class="line">		jmp output	；转向output</span><br><span class="line">		……</span><br><span class="line">output:	mov result,al	；标号output的指令</span><br></pre></td></tr></table></figure>

<p><strong>段内间接转移——间接寻址</strong></p>
<p>段内间接转移(间接寻址)：指定某个<strong>寄存器</strong>的内容或<strong>某个内存字单元的内容</strong>作为转移地址的偏移地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">JMP BX               	   ；(BX) --&gt; IP</span><br><span class="line">JMP WORD PTR[1000H]        ；(DS:1000H) --&gt; IP</span><br><span class="line">JMP WORD PTR[SI+2]         ；(DS:SI+2) --&gt; IP</span><br><span class="line">JMP TABLE[BX]              ；(DS:TABLE+(BX)) --&gt; IP</span><br></pre></td></tr></table></figure>

<p><font color=red>段间转移</font></p>
<p><strong>段间直接转移</strong>(直接寻址)：通过<strong>标号</strong>直接给出转移地址</p>
<blockquote>
<p>JMP far ptr NEXTP1       ；NEXTP1的段址–&gt; CS，偏址–&gt; IP</p>
</blockquote>
<p><strong>段间间接转移</strong>(间接寻址)：</p>
<p>指定一个4字节的单元内容作为转移地址，</p>
<p>低二字节内容–&gt;IP，高二字节内容–&gt;CS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr [bx],0</span><br><span class="line">mov word ptr [bx+2],1500h</span><br><span class="line">JMP far ptr [bx]   			 ；转移到1500h:0</span><br></pre></td></tr></table></figure>



<h3 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><p>标志位条件转移指令<br>二个无符号数比较转移指令<br>二个带符号数比较转移指令</p>
<p><img src="images/1584421943735.png" alt="1584421943735"></p>
<p>判断5个状态标志之一</p>
<p>$JZ/JE$ 和 $JNZ/JNE$：利用<strong>零标志ZF</strong>，判断结果是否为零（或相等）</p>
<p>$JS$ 和 $JNS$ ：利用<strong>符号标志SF</strong>，判断结果是正是负</p>
<p>$JO$ 和 $JNO$ ：利用<strong>溢出标志OF</strong>，判断结果是否产生溢出</p>
<p>$JP/JPE$ 和 $JNP/JPO$：利用<strong>奇偶标志PF</strong>，判断结果中“1”的个数是偶是奇</p>
<p>$JC/JB/JNAE$ 和 $JNC/JNB/JAE$：利用<strong>进位标志CF</strong>，判断结果是否进位或借位</p>
<h3 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h3><h3 id="子程序调用和返回指令"><a href="#子程序调用和返回指令" class="headerlink" title="子程序调用和返回指令"></a>子程序调用和返回指令</h3><h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiantian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天天的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/20/%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url">汇编（一）基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-20T16:30:09+08:00">
                2020-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index">
                    <span itemprop="name">汇编</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><span id="目录"></span></p>
<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="1-1数的表示"><a href="#1-1数的表示" class="headerlink" title="1.1数的表示"></a>1.1数的表示</h2><h3 id="数制"><a href="#数制" class="headerlink" title="数制"></a>数制</h3><p>二进制  Binary<br>八进制  Octal<br>十进制  Decimal<br>十六进制  Hexadecimal </p>
<h3 id="数制之间的转换"><a href="#数制之间的转换" class="headerlink" title="数制之间的转换"></a>数制之间的转换</h3><p><img src="/images%5C1582598964262.png" alt="1582598964262"></p>
<p>常用数</p>
<p>0—00H  128—80H  255—FFH  256—100H  32767—7FFFH  65535—FFFFH</p>
<h3 id="二进制运算"><a href="#二进制运算" class="headerlink" title="二进制运算"></a>二进制运算</h3><p><strong>算数运算</strong></p>
<p><img src="/images%5C1582599218562.png" alt="1582599218562"></p>
<p><strong>逻辑运算</strong></p>
<ul>
<li>与</li>
<li>或</li>
<li>非</li>
<li>异或</li>
<li>……</li>
</ul>
<h3 id="计算机中数的表示"><a href="#计算机中数的表示" class="headerlink" title="计算机中数的表示"></a>计算机中数的表示</h3><p>二进制</p>
<ul>
<li><p>无符号数</p>
<ul>
<li>直接用二进制表示</li>
</ul>
</li>
<li><p>有符号数</p>
<p><img src="/images%5C1582599398784.png" alt="1582599398784"></p>
</li>
<li><p>补码的补码就是原码</p>
</li>
<li><p>在计算机中，数据是以补码16进制存储在内存中的</p>
<ul>
<li><p>补码的运算</p>
<ul>
<li>$[N1+N2]_补=[N1]_补＋[N2]_补$</li>
<li>$[N1-N2]_补=[N1]_补＋[-N2]_补$</li>
<li><h5 id="N-补补-N"><a href="#N-补补-N" class="headerlink" title="$[N]_{补补}= [N]$"></a>$[N]_{补补}= [N]$</h5></li>
<li>补码的加、减运算都可以转换成加法运算，运算时符号位参加运算。</li>
<li>符号位进位丢弃，结果为负数再取补码。</li>
<li><img src="/images%5C1582605230251.png" alt="1582605230251"></li>
</ul>
</li>
<li><p>数的范围</p>
<ul>
<li>无符号数：8位(0–255） 16位（0–65535）</li>
<li>有符号数：8位（-128–127） 16位（-32768–32767）</li>
<li>n位补码表示数范围：  $- 2^{n-1} &lt;=  N &lt;=  2^{n-1}-1$</li>
</ul>
</li>
</ul>
</li>
<li><p>浮点数</p>
<ul>
<li>（尾数）规格化+（指数）移码</li>
<li>$a = m \times be$</li>
<li>符号位：尾数的符号，1为负，0为正；</li>
<li>尾数：即m规格化的值；</li>
<li>指数：即指数e的移码，即将其补码的符号位取反；</li>
<li>$(5.0)_{10}=(101.0)_2= (1.01\times 22)_2​$</li>
</ul>
</li>
</ul>
<h3 id="BCD码-Binary-Coded-Data"><a href="#BCD码-Binary-Coded-Data" class="headerlink" title="BCD码(Binary-Coded Data)"></a>BCD码(Binary-Coded Data)</h3><ul>
<li>Packed BCD：用4位二进制表示一个十进制数码<ul>
<li>0000—–0          0001—–1 </li>
<li>0001,0010,0011,0100  = 1234</li>
<li><img src="/images%5C1582600892171.png" alt="1582600892171"></li>
</ul>
</li>
<li>Unpacked BCD：用8位二进制表示一个十进制数码<ul>
<li>$00000000–0   00000001–1$</li>
<li>$00000001,00000010, 00000011, 00000100 = 1234$</li>
</ul>
</li>
</ul>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><ul>
<li>ASCII：英文，7 bits（128个代码）<ul>
<li>数字’0’～’9’：30H～39H</li>
<li>字母’A’～’Z’：41H～5AH</li>
<li>字母’a’～’z’：61H～7AH</li>
<li>空格：20H </li>
<li>回车CR：0DH——控制光标回到当前行的最左端</li>
<li>换行LF：0AH——移动光标到下一行，而所在列不变</li>
<li>空字符：0</li>
<li><img src="/images%5C1582601218816.png" alt="1582601218816"></li>
</ul>
</li>
<li>GB:国标码，是我国于1981年公布的国家标准，作为信息交换用汉字编码的字符(GB2312-80),包括6763个简体字以及其他字符。</li>
<li>GBK: GB的扩展，包括Unicode中的20902个汉字，也称汉字大字符集</li>
<li>BIG5:大五碼，包括13,060個繁體字，也是香港比較多人使用的標準。</li>
<li>UNICODE:  16位二进制 = 65536  汉字：20902个</li>
<li>UTF-8: 用4字节表示，232 = 42亿…</li>
</ul>
<h2 id="1-2-微型计算机（PC）系统"><a href="#1-2-微型计算机（PC）系统" class="headerlink" title="1.2 微型计算机（PC）系统"></a>1.2 微型计算机（PC）系统</h2><p>PC的硬件：主机、键盘、鼠标、显示器<br>主板的组成：CPU、存储器、外围芯片组、扩张插槽等<br>扩张插槽上有：RAM内存+接口卡</p>
<p><img src="/images%5C1582601468185.png" alt="1582601468185"></p>
<p>汇编语言程序员看到的硬件</p>
<ul>
<li>中央处理单元 CPU（Intel 80x86）<ul>
<li>对汇编语言程序员，最关心其中的寄存器组</li>
</ul>
</li>
<li>存储器（主存储器）<ul>
<li>呈现给汇编语言程序员的，是存储器地址</li>
</ul>
</li>
<li>外部设备（接口电路）<ul>
<li>汇编语言程序员看到的是端口（I/O地址）</li>
</ul>
</li>
</ul>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul>
<li><p>组成：</p>
<ul>
<li>算术逻辑部件、控制部件和<strong>寄存器组</strong></li>
</ul>
</li>
<li><p>CPU的作用： </p>
<ul>
<li>控制指令的执行。</li>
<li>执行算术与逻辑运算。</li>
</ul>
</li>
<li><p>对汇编语言程序员来说，CPU通过寄存器完成指令的取指和执行功能</p>
</li>
<li><p>CPU的内部总线实现CPU内部各个器件之间的联系。</p>
</li>
<li><p>外部总线（系统总线）实现CPU和主板上其它器件的联系</p>
</li>
</ul>
<h3 id="I-O-子系统"><a href="#I-O-子系统" class="headerlink" title="I/O 子系统"></a>I/O 子系统</h3><ul>
<li>通过接口电路与微机系统连接</li>
<li>I/O接口电路由若干接口寄存器组成，需要用编号区别各个寄存器：数据寄存器、状态寄存器、命令寄存器</li>
<li>I/O端口是I/O地址的通俗说法，是接口电路中寄存器的编号。<ul>
<li>汇编语言程序员看到的，是端口</li>
</ul>
</li>
<li>8086计算机采用16位表示I/O端口，系统通过这些端口与外设进行通信</li>
<li>Intel 8086支持64K个8位端口</li>
<li>I/O地址可以表示为：0000H ～ FFFFH</li>
</ul>
<h3 id="内存（存储器）"><a href="#内存（存储器）" class="headerlink" title="内存（存储器）"></a>内存（存储器）</h3><p>内存是存放<strong>指令</strong>和<strong>数据</strong>的部件，由若干内存单元构成。</p>
<p>指令和数据是应用上的概念，<strong>在内存中都是二进制数</strong>，没有区别</p>
<ul>
<li><p>存储器用以下单位来计量容量</p>
<ul>
<li>1个二进制位：bit（比特）</li>
<li>8个二进制位：Byte（字节） 1Byte=8bit   $D_7～D_0$</li>
<li>2个字节：Word（字）  1Word=2Byte=16bit  $D_{15}～D_0$</li>
<li>1个双字：DWord = 2 Word   $D_{31}～D_0$</li>
<li>$1KB= 2_{10}=1024B$      （Kilo） </li>
<li>$1MB=1024KB= 2^{20}$  （Mega） </li>
<li>$1GB=1024MB= 2^{30}$   （Giga）</li>
<li>$1TB=1024GB = 2^{40}$   （Tera）</li>
</ul>
</li>
<li><p>与内存储器相关概念：单元，地址，内容，字长</p>
<ul>
<li>把内存储器视为一个存放信息的大仓库，而一个大仓库又分成若干个小的存储间，每一个房间称为一个单元</li>
<li>为了区别这些单元，给每个单元编号，这个编号称为地址；</li>
<li>单元内部存放着信息称为单元的内容。</li>
<li>单元信息的长度成为字长。</li>
</ul>
</li>
<li><p>存储器被划分为若干个存储单元， 每个存储单元从0开始顺序编号；编号＝地址</p>
</li>
<li><p>数据的存储格式</p>
<ul>
<li>80x86的内存以<strong>字节</strong>编址：每个内存单元有唯一的地址，可存放1个字节</li>
<li>内存单元的2个要素：地址（编号）与值（内容）。<ul>
<li>如：（100H）=34H   或者  [0002H]＝34H</li>
<li>地址用<strong>无符号整数</strong>来表示（编程用十六进制表示）</li>
</ul>
</li>
<li>多字节数据在存储器中<strong>占连续的多个存储单元</strong>；<ul>
<li>低字节在低地址单元，高字节在高地址单元；</li>
<li><strong>字的地址由其低地址来表示</strong>。双字也类似。(小端方式)</li>
<li>同一地址可以看作是字节、字或双字单元的地址。</li>
</ul>
</li>
<li><img src="/images%5C1582602414805.png" alt="1582602414805"></li>
</ul>
</li>
<li><p>存储器芯片分类</p>
<ul>
<li>从读写属性上看分为两类：<ul>
<li>随机存储器（RAM）</li>
<li>只读存储器（ROM）</li>
</ul>
</li>
<li>从功能和连接上分类：<ul>
<li>随机存储器RAM</li>
<li>装有BIOS的ROM</li>
<li>接口卡上的RAM</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h3><p>总线是部件之间进行数据（电信号）交换的通道。</p>
<p><img src="/images%5C1582605918976.png" alt="1582605918976"></p>
<p>80x86计算机的系统总线分为3类：</p>
<ul>
<li>地址总线<ul>
<li>地址总线用来指出数据的地址（内存或I/O）。<ul>
<li><strong>CPU是通过地址总线来指定存储单元的</strong></li>
</ul>
</li>
<li>地址总线的位数决定了最大可编址的内存与I/O空间。<ul>
<li>对于N位地址总线，CPU可以提供$2^N$个不同地址：$0～2^N -1$。</li>
<li>也就是说地址总线的宽度决定了CPU的<strong>寻址能力</strong>；</li>
</ul>
</li>
<li>地址总线由内存与I/O子系统共享使用（I/O只用低16位）</li>
<li><img src="/images%5C1582602621563.png" alt="1582602630038"></li>
</ul>
</li>
<li>数据总线<ul>
<li>数据总线是用来<strong>传递数据</strong>的，定义了CPU在每个内存周期所能存取数据的<strong>位数</strong>。</li>
<li>80x86系列CPU的数据总线为8位、16位、32位或64位。这就是“为什么通常的数据存取是以8位、16位、32位或64位进行的”。</li>
<li>数据总线的宽度决定了CPU和外界的数据传送速度。数据总线越宽，处理能力越强。</li>
<li><strong>具有N位数据总线并不意味着CPU只能处理N位数据。</strong></li>
<li><img src="/images%5C1582603136049.png" alt="1582603136049"></li>
</ul>
</li>
<li>控制总线<ul>
<li>控制总线用来控制CPU与内存和I/O设备之间的<strong>数据传送方式</strong>（如传送方向）。</li>
<li>有多少根控制总线，就意味着CPU提供了对外部器件的<strong>多少种控制</strong>。</li>
<li>控制总线的宽度决定了CPU对<strong>外部器件</strong>的<strong>控制能力</strong>。</li>
<li><img src="F:%5C%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%5C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/images%5C1582603166324.png" alt="1582603166324"></li>
</ul>
</li>
</ul>
<h3 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h3><p>读取数据</p>
<ul>
<li>地址线寻找要读取信息地址</li>
<li>控制线发出<code>读</code>的控制指令</li>
<li>数据线在指定地址读取数据</li>
</ul>
<p>写入数据</p>
<ul>
<li>地址线寻找要写入信息地址</li>
<li>控制线发出<code>写</code>的控制指令</li>
<li>数据线在指定地址写入数据</li>
</ul>
<h3 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h3><p>上述存储器在物理上是独立的器件。但以下两点相同：</p>
<ol>
<li>都和CPU的总线相连。</li>
<li>CPU对它们进行读或写的时候都通过控制线发出内存读写命令。</li>
</ol>
<p><strong>CPU操作这些存储器时把它们看作一个逻辑存储器：</strong></p>
<ul>
<li>所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器；</li>
<li>每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间；</li>
<li>CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</li>
<li>最终运行程序的是CPU，我们用汇编编程的时候，必须要从CPU角度考虑问题。<ul>
<li>对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。</li>
<li><strong>这个逻辑存储器即是我们所说的内存地址空间。</strong></li>
<li>一个CPU的地址线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。</li>
</ul>
</li>
</ul>
<p>不同计算机系统的内存地址空间分配情况是不同的</p>
<p><img src="/images%5C1582606418693.png" alt="1582606418693"></p>
<h2 id="1-3-Intel-80x86系列微处理器"><a href="#1-3-Intel-80x86系列微处理器" class="headerlink" title="1.3 Intel 80x86系列微处理器"></a>1.3 Intel 80x86系列微处理器</h2><p><img src="/images%5C1582870128658.png" alt="1582870128658"></p>
<ul>
<li><p>16位80x86处理器</p>
<ul>
<li>8086/8088指令系统提供16位基本指令集</li>
<li>80186/80188增加若干条实用指令 </li>
<li>8086的工作方式是<strong>实方式</strong>（Real Mode）</li>
<li>80286增加保护方式（Protected Mode）</li>
<li>80286引入了系统指令<ul>
<li>为操作系统等核心程序提供处理器控制功能</li>
</ul>
</li>
</ul>
</li>
<li><p>IA-32处理器（Intel Architecture-32）</p>
<ul>
<li>80386引入英特尔32位指令集结构ISA<ul>
<li>兼容原16位80286指令系统</li>
<li>全面升级为32位</li>
<li>提供虚拟8086工作方式（Virtual 8086 Mode）</li>
</ul>
</li>
<li>80486集成浮点处理单元支持浮点指令</li>
<li>Pentium系列<ul>
<li>陆续增加若干整数指令、完善浮点指令</li>
<li>增加一系列多媒体指令（SIMD指令）</li>
</ul>
</li>
</ul>
</li>
<li><p>Intel 64处理器</p>
<ul>
<li>引入64位英特尔指令集结构<ul>
<li>兼容32位指令系统</li>
<li>新增64位工作方式</li>
</ul>
</li>
<li>继续丰富多媒体指令</li>
<li>处理器集成多核（Multi-core）技术</li>
</ul>
</li>
</ul>
<h2 id="1-4-8086微处理器"><a href="#1-4-8086微处理器" class="headerlink" title="1.4 8086微处理器"></a>1.4 8086微处理器</h2><h3 id="1-4-1-内部结构"><a href="#1-4-1-内部结构" class="headerlink" title="1.4.1 内部结构"></a>1.4.1 内部结构</h3><p><img src="/images/1583031408460.png" alt="1583031408460"></p>
<ul>
<li>组成：<ul>
<li>算术逻辑部件、控制部件和<strong>寄存器组</strong></li>
</ul>
</li>
<li>CPU的作用：<ul>
<li>执行算术与逻辑运算</li>
<li>控制指令的执行</li>
</ul>
</li>
</ul>
<p>这些器件靠内部总线相连。内部总线实现CPU内部各个器件之间的联系。</p>
<p>外部总线（系统总线）实现CPU和主板上其它器件的联系。</p>
<ul>
<li>执行单元EU<ul>
<li><strong>左半部分</strong>为执行单元（EU），由算数逻辑单元（ALU）、数据寄存器、地址寄存器、标志寄存器和指令译码的EU控制逻辑等构成</li>
<li>负责指令的译码、执行和数据的运算</li>
</ul>
</li>
<li>总线接口单元BIU<ul>
<li><strong>右半部分</strong>为总线接口单元（BIU），由6字节的指令队列、指令指针（IP）、段寄存器（CS，DS，SS，ES）、地址加法器和总线控制逻辑等构成。</li>
<li>管理8086与外部总线的接口，负责CPU对存储器和外设进行访问。</li>
<li>8086所连接的总线由16位的双向数据线、20位地址线和若干控制线组成。</li>
</ul>
</li>
<li>对汇编语言程序员来说，CPU通过<strong>寄存器</strong>完成指令的<strong>取指（取指令）</strong>和<strong>执行</strong>功能。 <ul>
<li>取指是从主存储器中取出指令代码进入CPU。</li>
<li>执行是将指令代码翻译成它代表的功能（被称为译码），并发出有关控制信号实现这个功能。</li>
</ul>
</li>
</ul>
<h3 id="1-4-2-存储器组织"><a href="#1-4-2-存储器组织" class="headerlink" title="1.4.2 存储器组织"></a>1.4.2 存储器组织</h3><h4 id="1-数据的存储格式"><a href="#1-数据的存储格式" class="headerlink" title="1. 数据的存储格式"></a>1. 数据的存储格式</h4><p>基本单位为一个二进制位：bit</p>
<p>8个bit组成一个字节：Byte，位编号从右向左从0开始递增：$D_7 \sim D_0$</p>
<p>其中最低为称为最低有效位（LSB），最高位称为最高有效位（MSB）</p>
<p>存储器以字节位单位存储信息，为了正确存储，每个存储单元被赋予一个地址。地址编号从0开始，顺序加1，是一个无符号十六进制数。</p>
<p>存储单元中存放的信息为该存储单元的内容。如0002H地址的存储器中存放的信息为34H，即二单元的内容为34H，表示为 $\lbrack 0002H\rbrack =34H$</p>
<p>那么如何存放一个字或双字呢？</p>
<p>字或双字在存储器中占据2或4个存储单元：存放时，低字节存入低地址，高字节存入高地址</p>
<h4 id="2-存储器的分段管理"><a href="#2-存储器的分段管理" class="headerlink" title="2. 存储器的分段管理"></a>2. 存储器的分段管理</h4><p>16位结构描述了一个CPU具有以下特征：</p>
<ol>
<li>运算器一次最多可以处理16位的数据。</li>
<li>寄存器的最大宽度为16位。</li>
<li>寄存器和运算器之间的通路是16位的。</li>
</ol>
<p>8086有20位地址总线，可传送20位地址，寻址能力为1MB = $2^{20}B$，地址范围为00000H~FFFFFH</p>
<p>整个1MB主存空间从地位地址到高位地址可分为四个区段：（实方式主存）</p>
<p><img src="/images/1583031216603.png" alt="1583031216603"></p>
<p>8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K</p>
<h4 id="如何给出20位的物理地址-分段技术"><a href="#如何给出20位的物理地址-分段技术" class="headerlink" title="如何给出20位的物理地址: 分段技术"></a>如何给出20位的物理地址: 分段技术</h4><ul>
<li>地址加法器合成物理地址的方法：用两个16位地址合成一个20位的物理地址。</li>
</ul>
<p><img src="/images%5C1582871573536.png" alt="1582871573536"></p>
<p>默认200后面还有一个0 $\to​$ 段地址×16</p>
<p>将存储器分成若干个逻辑段段首地址必须为：$****0H​$。</p>
<p>其有效地址“$<strong>**H$”存放在</strong>段寄存器<strong>中，称为</strong>段地址**。</p>
<p>段中某一个单元相对于段首的距离称为<strong>偏移地址</strong>，偏移地址存放在<strong>偏移地址寄存器</strong>中。</p>
<p>段的长度不超过$2^{16}=64K$。</p>
<p><img src="/images%5C1582871775533.png" alt="1582871775533"></p>
<p>8086CPU给出物理地址的方法:</p>
<ul>
<li><p>ALU完成加法，地址加法器</p>
</li>
<li><p>段地址一般在程序开始时预定</p>
</li>
<li><p>访问某一个内存单元，程序中只需要给出16位偏移地址</p>
</li>
</ul>
<p><img src="/images%5C1582871963366.png" alt="1582871963366"></p>
<p><strong>分段技术小结</strong></p>
<ul>
<li>内存并没有分段，段的划分来自于CPU，由于8086CPU用<code>（段地址×16）+ 偏移地址 = 物理地址</code>的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存</li>
<li>段地址×16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数；可根据需要，将<strong>地址连续、起始地址为16的倍数的一组内存单元定义为一个段。</strong></li>
<li>偏移地址为16位，16 位地址的寻址能力为 64K，所以一个段的长度最大为64K。也就是说<strong>给定一个段地址</strong>，仅通过变化偏移地址来进行寻址，<strong>最多可以定位64K个内存单元</strong>。 0~FFFFH</li>
<li>CPU访问内存单元时，必须向内存提供内存单元的最终物理地址=段地址+偏移地址</li>
<li>CPU可以用不同的段地址和偏移地址形成同一个物理地址，如下例</li>
<li><img src="/images%5C1582872120205.png" alt="1582872120205"></li>
</ul>
<h3 id="1-4-3-寄存器组"><a href="#1-4-3-寄存器组" class="headerlink" title="1.4.3 寄存器组"></a>1.4.3 寄存器组</h3><p>对汇编语言程序员来说，关心的是<strong>CPU的寄存器</strong></p>
<ul>
<li>8086／8088中共有14个16位寄存器 </li>
<li>寄存器在CPU内部，所以访问速度快。但容量小</li>
</ul>
<p>可编程寄存器可分为：</p>
<ul>
<li>通用寄存器<ul>
<li>在处理器中数量较多，使用频率较高，具有多种用途</li>
<li>比如可用来进行存放指令需要的操作数据</li>
</ul>
</li>
<li>专用寄存器<ul>
<li>只用于特定目的</li>
</ul>
</li>
<li>8086分为<strong>8个通用寄存器，4个段寄存器，1个标志寄存器和1个指令指针寄存器，均为16位</strong></li>
</ul>
<h4 id="寄存器与存储器的比较"><a href="#寄存器与存储器的比较" class="headerlink" title="寄存器与存储器的比较"></a>寄存器与存储器的比较</h4><ul>
<li>寄存器<ul>
<li>在CPU内部</li>
<li>访问速度快</li>
<li>容量小，成本高</li>
<li>用名字表示</li>
<li>没有地址</li>
</ul>
</li>
<li>存储器<ul>
<li>在CPU外部</li>
<li>访问速度慢</li>
<li>容量大，成本低</li>
<li>用地址表示</li>
<li>地址可用各种方式形成</li>
</ul>
</li>
</ul>
<h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><p><img src="/images/1583032445468.png" alt="1583032445468"></p>
<h4 id="1-通用寄存器"><a href="#1-通用寄存器" class="headerlink" title="1. 通用寄存器"></a>1. 通用寄存器</h4><p><img src="/images/1583032547356.png" alt="1583032547356"></p>
<h5 id="数据寄存器：AX-BX-CX-DX"><a href="#数据寄存器：AX-BX-CX-DX" class="headerlink" title="数据寄存器：AX/BX/CX/DX"></a>数据寄存器：AX/BX/CX/DX</h5><p>存放<strong>任何数据信息</strong>。暂存计算的中间结果，数据中转站。</p>
<p>每个寄存器又有它们各自的专用目的：</p>
<ul>
<li>AX (Accumulator)——累加器，使用频度最高，用于算术、逻辑运算以及与外设传送信息等；</li>
<li>BX (Base)——基址寄存器，常用做存放存储器<strong>地址</strong>；</li>
<li>CX (Count)——计数器，作为循环和串操作等指令中的隐含计数器；</li>
<li>DX (Data)——数据寄存器，常用来<strong>存放双字长数据的高16位，或存放外设端口地址。</strong></li>
</ul>
<p>他们还可以进一步的分为高字节H(high)和低字节L(Low)；两部分，这样就有了8个8位通用寄存器，操作互不影响，也可一起使用。</p>
<p><img src="/images/1582875665869.png" alt="1582875665869"></p>
<p><img src="/images/1582875684106.png" alt="1582875684106"></p>
<h5 id="变址寄存器-SI-DI"><a href="#变址寄存器-SI-DI" class="headerlink" title="变址寄存器:SI/DI"></a>变址寄存器:SI/DI</h5><p><img src="/images/1583032955013.png" alt="1583032955013"></p>
<p>变址寄存器常用于存储器寻址时提供<strong>地址</strong>，有两个是因为很多运算是余姚两个操作数才能进行的（加法等）</p>
<p>16位，不可拆分使用</p>
<h4 id="2-段寄存器-CS-DS-SS-ES"><a href="#2-段寄存器-CS-DS-SS-ES" class="headerlink" title="2. 段寄存器:CS/DS/SS/ES"></a>2. 段寄存器:CS/DS/SS/ES</h4><p><img src="/images/1583033208984.png" alt="1583033208984"></p>
<ul>
<li><p>段寄存器用来确定该段在内存中的起始地址</p>
</li>
<li><p>用途特定，不可分开使用</p>
</li>
</ul>
<p>4个<strong>专门存放段地址</strong>的段寄存器（16位）</p>
<ul>
<li><p>代码段  段寄存器 CS</p>
</li>
<li><p>数据段  段寄存器 DS</p>
</li>
<li><p>堆栈段  段寄存器 SS</p>
</li>
<li><p>附加段  段寄存器 ES</p>
<p><strong>物理地址= 10H × (DS) + 偏移</strong></p>
</li>
</ul>
<p>（最大偏移地址为FFFFH）</p>
<p>得到的地址必须是16的倍数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解释为什么必须是16的倍数</span><br><span class="line">这是历史遗留问题.</span><br><span class="line">　　intel 8088时代，计算机的地址总线是20位的,即可以寻址能力可以达到1M字节,但是它的ALU和寄存器都只有16位,也就是表示数的能力只能达64k，再大就逾锅了。那怎么办呢？INTEL想了一个办法，让两个寄存器对来表示一个物理地址，比如说DS：BX，前者叫段寄存器，后者叫偏址寄存器。由于这两个寄存器都是16位，直接相加还是不能匹配20位的地址线的访问能力，因此，INTEL公司变通了一下，人为地将这个组合寻址设计成：在它们组合时，让段寄存器左移四位（假设DS是1234H，左移4位就变成了12340H，至于它内部怎么实现我们不用管它。注意，对于16进制的数来说，乘以16就相当于在原数后面补个0，因为它是逢16进1啊；与10进制数乘10就是后面补0同样道理。）然后与偏址寄存器相加，这样得到的地址最大可以到0FFFFFH。这样行了。</span><br><span class="line">　　现在都32位机了，甚至64位了，所以上面的寻址方法在保护模式下不再用了。</span><br></pre></td></tr></table></figure>

<p>例：(DS)=3000H,  偏移=1234H,  物理地址= 10H × (DS) + 偏移 =31234H</p>
<p><img src="/images%5C1582872562768.png" alt="1582872562768"></p>
<p>CPU几种典型的操作</p>
<ul>
<li>取 指 令：  指令单元地址＝（CS）×10H＋IP(用于存指令的寄存器的偏移地址)</li>
<li>堆栈操作：堆栈数据地址＝（SS）×10H＋偏移（代码中指出即可，下同）</li>
<li>内存数据：内存数据地址＝（DS）×10H＋偏移</li>
</ul>
<h5 id="CS-IP-Instruction-Pointer"><a href="#CS-IP-Instruction-Pointer" class="headerlink" title="CS+IP (Instruction Pointer)"></a>CS+IP (Instruction Pointer)</h5><p><strong>CS+IP</strong>是8086CPU中最关键的寄存器，它们指示了<strong>CPU当前要读取指令的地址</strong>。</p>
<p>指令指针寄存器IP，指示代码段中指令的<strong>偏移地址</strong></p>
<p>它与代码段寄存器CS联用，确定下一条指令的<strong>物理地址</strong></p>
<p>IP寄存器是一个专用寄存器,程序一般不可直接使用</p>
<h5 id="SS-指针寄存器-SP-BP"><a href="#SS-指针寄存器-SP-BP" class="headerlink" title="SS+指针寄存器:SP/BP"></a>SS+指针寄存器:SP/BP</h5><ul>
<li>SP和BP寄存器与SS段寄存器联合使用以确定<strong>堆栈段中的存储单元地址</strong></li>
<li>指针寄存器用于<strong>寻址</strong>内存堆栈内的数据<ul>
<li>SP (Stack Pointer)为堆栈指针寄存器，指示栈顶的<strong>偏移地址</strong></li>
<li>SP 不能再用于其他目的，具有专用目的</li>
<li>BP (Base Pointer)为基址指针寄存器，表示数据在堆栈段中的<strong>基地址</strong></li>
</ul>
</li>
</ul>
<h5 id="堆栈（Stack）"><a href="#堆栈（Stack）" class="headerlink" title="堆栈（Stack）"></a>堆栈（Stack）</h5><p>堆栈是主存中一个特殊的区域</p>
<p>它采用<strong>先进后出</strong>FILO（First In Last Out）或后进先出LIFO（Last In First Out）的原则进行存取操作，而不是随机存取操作方式</p>
<p>堆栈通常由处理器自动维持</p>
<p>在8086中，由堆栈段寄存器<strong>SS</strong>和堆栈指针寄存器<strong>SP</strong>共同指示</p>
<p><img src="F:%5C%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/images%5C1582874817187.png" alt="1582874817187"></p>
<h5 id="数据段（Data-Segment）"><a href="#数据段（Data-Segment）" class="headerlink" title="数据段（Data Segment）"></a>数据段（Data Segment）</h5><ul>
<li>数据段存放运行程序所用的数据<ul>
<li>数据段寄存器<strong>DS</strong>存放数据段的段地址</li>
<li>各种主存寻址方式（有效地址EA）得到存储器中操作数的偏移地址</li>
</ul>
</li>
<li>CPU利用<strong>DS:偏移地址</strong>存取数据段中的数据</li>
</ul>
<h5 id="附加段（Extra-Segment）"><a href="#附加段（Extra-Segment）" class="headerlink" title="附加段（Extra Segment）"></a>附加段（Extra Segment）</h5><ul>
<li>附加段是附加的数据段，也用于数据的保存：<ul>
<li>附加段寄存器ES存放附加段的段地址</li>
<li>各种主存寻址方式（有效地址EA）得到存储器中操作数的偏移地址</li>
</ul>
</li>
<li>处理器利用<strong>ES:偏移地址</strong>存取附加段中的数据</li>
<li>串操作指令将附加段ES作为其目的操作数的存放区域</li>
</ul>
<h5 id="如何分配各个逻辑段"><a href="#如何分配各个逻辑段" class="headerlink" title="如何分配各个逻辑段"></a>如何分配各个逻辑段</h5><ul>
<li>程序的指令序列必须安排在代码段CS</li>
<li>程序使用的堆栈一定在堆栈段SS</li>
<li>程序中的数据默认是安排在数据段DS，也经常安排在附加段ES，尤其是串操作的目的区必须是附加段ES</li>
<li>数据的存放比较灵活，实际上可以存放在任何一种逻辑段中</li>
</ul>
<h5 id="段寄存器的使用规定"><a href="#段寄存器的使用规定" class="headerlink" title="段寄存器的使用规定"></a>段寄存器的使用规定</h5><table>
<thead>
<tr>
<th>访问存储器的方式</th>
<th>默认</th>
<th>可超越</th>
<th>偏移地址</th>
</tr>
</thead>
<tbody><tr>
<td>取指令</td>
<td>CS</td>
<td>无</td>
<td>IP</td>
</tr>
<tr>
<td>堆栈操作</td>
<td>SS</td>
<td>无</td>
<td>SP</td>
</tr>
<tr>
<td>一般数据访问</td>
<td>DS</td>
<td>CS ES SS</td>
<td>有效地址\EA</td>
</tr>
<tr>
<td>BP\基址的寻址方式</td>
<td>SS</td>
<td>CS ES DS</td>
<td>有效地址\EA</td>
</tr>
<tr>
<td>串操作的源操作数</td>
<td>DS</td>
<td>CS ES SS</td>
<td>SI</td>
</tr>
<tr>
<td>串操作的目的操作数</td>
<td>ES</td>
<td>无</td>
<td>DI</td>
</tr>
</tbody></table>
<h4 id="3-标志寄存器"><a href="#3-标志寄存器" class="headerlink" title="3. 标志寄存器"></a>3. 标志寄存器</h4><p>标志寄存器F(FLAGS),又称<strong>程序状态字寄存器</strong>PSW</p>
<p>FLAGS中的各种标志分成了两类：6个状态标志和3个控制标志</p>
<ul>
<li>状态标志位：CF,OF,ZF,SF,PF,AF<ul>
<li>由CPU根据当前程序运行结果的状态自动完成的</li>
<li>一般用作转移指令的转移控制条件</li>
</ul>
</li>
<li>控制标志位DF,IF,TF<ul>
<li>用以存放控制CPU工作方式的标志信息</li>
<li>由程序设置</li>
</ul>
</li>
</ul>
<p><img src="/images/1582875789444.png" alt="1582875789444"></p>
<h5 id="1-状态标志位"><a href="#1-状态标志位" class="headerlink" title="1. 状态标志位"></a>1. 状态标志位</h5><h6 id="进位标志CF（Carry-Flag）"><a href="#进位标志CF（Carry-Flag）" class="headerlink" title="进位标志CF（Carry Flag）"></a>进位标志CF（Carry Flag）</h6><p>进行<strong>无符号数运算</strong>的时候，当运算结果的最高有效位有进位（加法）或借位（减法）时，进位标志置1，即CF = 1；否则CF = 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">  3AH + 7CH＝B6H</span><br><span class="line">  没有进位：CF &#x3D; 0</span><br><span class="line">  </span><br><span class="line">  AAH + 7CH＝（1）26H</span><br><span class="line">  有进位：CF &#x3D; 1</span><br></pre></td></tr></table></figure>

<h6 id="零标志ZF（Zero-Flag）"><a href="#零标志ZF（Zero-Flag）" class="headerlink" title="零标志ZF（Zero Flag）"></a>零标志ZF（Zero Flag）</h6><p>若运算结果为0，则ZF = 1，否则ZF = 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">    3AH + 7CH＝B6H，结果不是零：</span><br><span class="line">    ZF &#x3D; 0</span><br><span class="line">    </span><br><span class="line">    86H + 7AH＝（1）00H，结果是零(为什么？)：</span><br><span class="line">    ZF &#x3D; 1</span><br><span class="line">注意：ZF为1表示的结果是0</span><br></pre></td></tr></table></figure>

<h6 id="符号标志SF（Sign-Flag）"><a href="#符号标志SF（Sign-Flag）" class="headerlink" title="符号标志SF（Sign Flag）"></a>符号标志SF（Sign Flag）</h6><p>CPU对有符号数运算结果的一种记录，记录数据的正负</p>
<ul>
<li>结果为负，SF = 1；</li>
<li>结果为正，SF = 0。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">  mov al,10000001B </span><br><span class="line">  add al,1</span><br><span class="line">  </span><br><span class="line">  执行后，结果为10000010B，SF&#x3D;1，</span><br><span class="line">  表示：如果指令进行的是有符号数运算，那么结果为负；</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。</li>
<li>如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。</li>
</ul>
<h6 id="奇偶标志PF-（Parity-Flag）"><a href="#奇偶标志PF-（Parity-Flag）" class="headerlink" title="奇偶标志PF （Parity Flag）"></a>奇偶标志PF （Parity Flag）</h6><p>当运算结果最低字节中“1”的个数为偶数时，PF = 1；否则PF = 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">    3AH + 7CH＝B6H＝10110110B，</span><br><span class="line"></span><br><span class="line">结果中有5个1，是奇数：PF &#x3D; 0</span><br><span class="line">注意：PF标志仅反映最低8位中“1”的个数是偶或奇，即使是进行16位字操作。</span><br></pre></td></tr></table></figure>

<h6 id="辅助进位标志AF-（Auxiliary-Carry-Flag）"><a href="#辅助进位标志AF-（Auxiliary-Carry-Flag）" class="headerlink" title="辅助进位标志AF （Auxiliary Carry Flag）"></a>辅助进位标志AF （Auxiliary Carry Flag）</h6><p>运算时D3位（低半字节）有进位或借位时，  AF = 1；否则AF = 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">   3AH + 7CH＝B6H</span><br><span class="line">   D3有进位：AF &#x3D; 1</span><br></pre></td></tr></table></figure>

<p>这个标志主要由处理器内部使用，用于十进制算术运算指令中，用户一般不必关心。（<strong>类似于进位标志</strong>）</p>
<h6 id="溢出标志OF（Overflow-Flag）"><a href="#溢出标志OF（Overflow-Flag）" class="headerlink" title="溢出标志OF（Overflow Flag）"></a>溢出标志OF（Overflow Flag）</h6><p>有符号数运算的结果有溢出，则OF=1；否则 OF＝0。<br>只是对有符号数而言。对无符号数而言，OF＝1并不意味着结果出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">    mov al,98</span><br><span class="line">    add al,99</span><br><span class="line">    </span><br><span class="line">执行后将产生溢出。</span><br><span class="line">因为add al,99 进行的有符号数运算是：(al)&#x3D;(al)+99&#x3D;98+99&#x3D;197</span><br><span class="line">而结果197超出了机器所能表示的8位有符号数的范围：</span><br><span class="line">-128~127。</span><br></pre></td></tr></table></figure>

<p><strong>什么是溢出</strong></p>
<ul>
<li>处理器内部以补码表示有符号数<ul>
<li>8个二进制位能够表达的整数范围是：+127 ~ -128</li>
<li>16位表达的范围是：+32767 ~ -32768</li>
</ul>
</li>
<li>如果运算结果超出这个范围，就是产生了溢出</li>
<li>有溢出，说明有符号数的运算结果不正确</li>
<li>无符号数有溢出吗？<ul>
<li>FFH + 01H = 00H, CF = 1, 进位</li>
</ul>
</li>
</ul>
<p><strong>溢出和进位</strong></p>
<ul>
<li>溢出标志OF和进位标志CF是两个意义不同的标志</li>
<li>进位标志CF表示无符号数运算结果是否超出范围，运算结果仍然正确；<ul>
<li>可恢复的错误。</li>
</ul>
</li>
<li>溢出标志OF表示有符号数运算结果是否超出范围，运算结果已经不正确。<ul>
<li>不可恢复错误。</li>
</ul>
</li>
</ul>
<p><strong>溢出和进位的对比</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例1：7FH + 01H＝80H</span><br><span class="line">无符号数运算：127＋1＝128，  范围内，无进位</span><br><span class="line">有符号数运算： 127＋1＝128 ，范围外，有溢出</span><br><span class="line"></span><br><span class="line">例2：FFH + 01H＝（1）00H</span><br><span class="line">无符号数运算：255＋1＝256，范围外，有进位</span><br><span class="line">有符号数运算：－1＋1＝0 ，   范围内，无溢出</span><br></pre></td></tr></table></figure>

<p><strong>如何运用溢出和进位</strong></p>
<ul>
<li>处理器对两个操作数进行运算时，并不知道操作数是有符号数还是无符号数，所以全部设置，按各自规则。<br>应该利用哪个标志，则由程序员来决定。</li>
<li>将参加运算的操作数是无符号数，就注意CF；</li>
<li>将参加运算的操作数是有符号数，则注意OF。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例： MOV  AX, 1</span><br><span class="line">    MOV  BX, 2</span><br><span class="line">    ADD  AX, BX</span><br><span class="line">    指令执行后，(AX)&#x3D;3, OF&#x3D;0, CF&#x3D;0, ZF&#x3D;0, SF&#x3D;0</span><br><span class="line"></span><br><span class="line">例： MOV  AX, FFFFH</span><br><span class="line">    MOV  BX, 1</span><br><span class="line">    ADD  AX, BX</span><br><span class="line">    指令执行后，(AX)&#x3D;0, OF&#x3D;0, CF&#x3D;1, ZF&#x3D;1, SF&#x3D;0</span><br></pre></td></tr></table></figure>

<h5 id="2-控制标志"><a href="#2-控制标志" class="headerlink" title="2. 控制标志"></a>2. 控制标志</h5><h6 id="方向标志DF（Direction-Flag）"><a href="#方向标志DF（Direction-Flag）" class="headerlink" title="方向标志DF（Direction Flag）"></a>方向标志DF（Direction Flag）</h6><ul>
<li>用于串操作指令中，控制地址的变化方向：<ul>
<li>设置DF＝0，串操作的存储器地址自动增加；</li>
<li>设置DF＝1，串操作的存储器地址自动减少。</li>
</ul>
</li>
</ul>
<h6 id="中断允许标志IF（Interrupt-enable-Flag）"><a href="#中断允许标志IF（Interrupt-enable-Flag）" class="headerlink" title="中断允许标志IF（Interrupt-enable Flag）"></a>中断允许标志IF（Interrupt-enable Flag）</h6><ul>
<li>用于控制外部可屏蔽中断是否可以被处理器响应：<ul>
<li>设置IF＝1，则允许中断；</li>
<li>设置IF＝0，则禁止中断。</li>
</ul>
</li>
</ul>
<h6 id="陷阱标志TF（Trap-Flag）"><a href="#陷阱标志TF（Trap-Flag）" class="headerlink" title="陷阱标志TF（Trap Flag）"></a>陷阱标志TF（Trap Flag）</h6><ul>
<li>用于控制处理器是否进入单步操作方式：<ul>
<li>设置TF＝0，处理器正常工作；</li>
<li>设置TF＝1，处理器单步执行指令。</li>
</ul>
</li>
<li>==单步执行指令——处理器在<strong>每条指令执行结束</strong>时，便产生一个编号为1的内部中断。==这种内部中断称为单步中断，所以TF也称为单步标志。<ul>
<li>利用单步中断可对程序进行逐条指令的调试。</li>
<li>这种逐条指令调试程序的方法就是单步调试。</li>
</ul>
</li>
</ul>
<h4 id="4-指针指令寄存器（IP）"><a href="#4-指针指令寄存器（IP）" class="headerlink" title="4. 指针指令寄存器（IP）"></a>4. 指针指令寄存器（IP）</h4><p><img src="/images/1583034422794.png" alt="1583034422794"></p>
<p><img src="/images/1583034434323.png" alt="1583034434323"></p>
<h2 id="1-5-8086的寻址方式"><a href="#1-5-8086的寻址方式" class="headerlink" title="1.5 8086的寻址方式"></a>1.5 8086的寻址方式</h2><p><img src="/images/1583038683934.png" alt="1583038683934"></p>
<p><img src="/images/1583038696339.png" alt="1583038696339"></p>
<p>有些指令不需要操作数，通常的指令都有一个或两个操作数，个别指令有3个甚至4个操作数</p>
<p><img src="/images/1583038867768.png" alt="1583038867768"></p>
<p><img src="/images/1583038878276.png" alt="1583038878276"></p>
<p>标准机器代码示例</p>
<p><img src="/images/1583039157843.png" alt="1583039157843"></p>
<h3 id="1-5-1-8086机器码格式"><a href="#1-5-1-8086机器码格式" class="headerlink" title="1.5.1 8086机器码格式"></a>1.5.1 8086机器码格式</h3><p>机器码格式：将指令以2进制数0和1进行编码的形式，也被称为<strong>指令编码格式</strong></p>
<p><img src="/images/1583567648014.png" alt="1583567648014"></p>
<p><img src="/images/1583567711516.png" alt="1583567711516"></p>
<p>8086机器代码格式如图所示：</p>
<p><img src="/images/1582876709710.png" alt="1582876709710"></p>
<p>操作码占1至两个字节</p>
<p>设计有多种寻址方式，因此操作数的个字段有多种组合：</p>
<p><img src="/images/1583477644581.png" alt="1583039426023"></p>
<h3 id="1-5-2-指令格式"><a href="#1-5-2-指令格式" class="headerlink" title="1.5.2 指令格式"></a>1.5.2 指令格式</h3><ul>
<li>每种指令的<strong>操作码</strong>：<ul>
<li>用一个唯一的助记符表示（指令功能的英文缩写）</li>
<li>对应着机器指令的一个二进制编码</li>
</ul>
</li>
<li>指令中的<strong>操作数</strong>：<ul>
<li>立即操作数：一个具体的数值</li>
<li>寄存器操作数：存放数据的寄存器</li>
<li>内存操作数：指明数据在主存位置的存储器地址<ul>
<li>通常为有效地址EA，段地址在某个段寄存器中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-5-3-寻址方式"><a href="#1-5-3-寻址方式" class="headerlink" title="1.5.3 寻址方式"></a>1.5.3 寻址方式</h3><h4 id="1-立即寻址方式"><a href="#1-立即寻址方式" class="headerlink" title="1. 立即寻址方式"></a>1. 立即寻址方式</h4><p>操作数在指令中给出,作为指令机器码的一部分存储</p>
<p>​     MOV  AL, 34H         ；机器码：B0 34</p>
<p>​     MOV  AX, 0034H     ；机器码：B8 34 00</p>
<p>使用场合：常数，8位和16位。 </p>
<p>立即数寻址方式常用来给寄存器赋值</p>
<p>​    MOV AL,05H        ；AL←[05H]</p>
<p>​    MOV AX,0102H       ； AX←[0102H]</p>
<p>​    <img src="/images/1583210960302.png" alt="1583210960302"></p>
<h4 id="2-寄存器寻址方式"><a href="#2-寄存器寻址方式" class="headerlink" title="2. 寄存器寻址方式"></a>2. 寄存器寻址方式</h4><ul>
<li>操作数在指定的数据寄存器中<ul>
<li>MOV  AX, BX</li>
<li>MOV  AL, BH</li>
</ul>
</li>
<li>注意可用寄存器：<ul>
<li>8位寄存器r8：AH、AL、BH、BL、CH、CL、DH、DL</li>
<li>16位寄存器r16：AX、BX、CX、DX、SI、DI、BP、SP</li>
<li>4个段寄存器seg：CS、DS、SS、ES</li>
<li><strong>CS/IP不能用作目的操作数：</strong><ul>
<li><strong>MOV  CS/IP, AX （X）</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-内存操作数寻址方式"><a href="#3-内存操作数寻址方式" class="headerlink" title="3. 内存操作数寻址方式"></a>3. 内存操作数寻址方式</h4><p>指令中给出操作数的主存地址信息（偏移地址，称之为有效地址EA），而段地址在默认的或用<strong>段超越</strong>前缀指定的段寄存器中</p>
<p><strong>段超越</strong></p>
<p>隐式段地址——8086/8088指令系统对存储单元的访问，其段地址都是从系统事先约定好的段寄存器中获取； </p>
<p><strong>规则为：除串操作指令外，若出现BP（SP），默认在SS中，否则所有的操作都默认在DS中。</strong></p>
<p>（显式段地址）<strong>段超越</strong>不是按照系统的约定，而是在指令中显式指定某一段寄存器作为存储器操作数的段地址</p>
<p>寻址方式分类：</p>
<h5 id="直接寻址方式-direct-addressing"><a href="#直接寻址方式-direct-addressing" class="headerlink" title="直接寻址方式(direct addressing)"></a>直接寻址方式(direct addressing)</h5><ul>
<li>内存操作数的偏移地址由指令直接给出</li>
<li>例如：<code>MOV  AX, [2000H]  ；AX←DS:[2000H]</code></li>
<li>注意：<ul>
<li>隐含的段为数据段 DS</li>
<li>物理地址 = 16 * (DS) +偏移地址</li>
</ul>
</li>
</ul>
<h5 id="寄存器间接寻址方式-register-indirect"><a href="#寄存器间接寻址方式-register-indirect" class="headerlink" title="寄存器间接寻址方式(register indirect)"></a>寄存器间接寻址方式(register indirect)</h5><ul>
<li>指定某个地址寄存器（SI、DI、BX、BP）的内容作为内存操作数的偏移地址</li>
<li>使用场合：表格、字符串、缓冲区处理</li>
<li><code>MOV AX, [BX]    ；AX←DS:[BX]</code></li>
<li>注意段地址规则：<ul>
<li>BX, SI, DI $\to$ (DS)                                          </li>
<li>BP $\to​$ (SS)</li>
</ul>
</li>
</ul>
<h5 id="寄存器相对寻址方式-register-relative"><a href="#寄存器相对寻址方式-register-relative" class="headerlink" title="寄存器相对寻址方式(register relative)"></a>寄存器相对寻址方式(register relative)</h5><ul>
<li>指令中指定地址寄存器（SI、DI、BX、BP）与一个位移量相加作为内存操作数的偏移地址</li>
<li>使用场合：适于表格、字符串、缓冲区的处理；</li>
<li><code>MOV AX,[SI+2]       ；AX←DS:[SI+02H]</code></li>
<li><code>MOV AX,[BP+06H]     ；AX←SS:[BP+06H]</code></li>
<li><img src="/images/1583211794594.png" alt="1583211794594"></li>
</ul>
<h5 id="基址变址寻址方式-based-indexed"><a href="#基址变址寻址方式-based-indexed" class="headerlink" title="基址变址寻址方式(based indexed..)"></a>基址变址寻址方式(based indexed..)</h5><ul>
<li>指定基址寄存器(BX,BP)、变址寄存器(SI,DI)内容相加作为内存操作数的地址。</li>
<li>使用场合：适于数组、字符串、表格的处理，更加灵活</li>
<li><code>MOV [BX+DI],DX</code>      </li>
<li><code>MOV AL, [BP+SI]  ；AL←SS:[BP+SI]</code></li>
<li>注意：必须是一个基址寄存器和一个变址寄存器的<strong>组合</strong></li>
</ul>
<h5 id="相对基址变址方式-relative-based-indexed"><a href="#相对基址变址方式-relative-based-indexed" class="headerlink" title="相对基址变址方式(relative based indexed..)"></a>相对基址变址方式(relative based indexed..)</h5><ul>
<li>指定基址寄存器(BX,BP) 、变址寄存器(SI,DI) 、位移量之和作为内存操作数的地址</li>
<li>使用场合：适于二维数组的寻址<code>Buffer[BX][SI] = [Buffer+BX+SI]</code><img src="../../%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80//images/1583211803837.png" alt="1583211803837"></li>
<li><code>MOV AL, [SI+BX+2]    MOV [BX+DI-16H], DX   MOV AL, 2[SI+BX]   ；AL←DS:[BX+SI+02H]</code></li>
</ul>
<p>寻址方式的多种表示方式</p>
<ul>
<li><p>位移量可用符号表示：</p>
<p>   MOV AX,[SI+<strong>COUNT</strong>]       ；COUNT是事先定义的变量或常量（就是数值）</p>
<p>   MOV AX,[BX+SI+<strong>WNUM</strong>]     ；WNUM是变量或常量</p>
</li>
<li><p>同一寻址方式可以写成不同的形式：</p>
<p>   MOV AX,[BX][SI]          ；MOV AX,[BX+SI]</p>
<p>   MOV AX,COUNT[SI]         ；MOV AX,[SI+COUNT]</p>
<p>   MOV AX,WNUM[BX] [SI]           </p>
<p>；等同于  MOV AX,WNUM[BX+SI]</p>
<p>；等同于  MOV AX,[BX+SI+WNUM]</p>
</li>
</ul>
<p>同时修改CS、IP的内容，可用形如<code>jmp段地址:偏移地址</code>的指令完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp 2AE3:3	;执行后，CS&#x3D;2AE3H，IP&#x3D;0003H，CPU将从2AE33H中读取指令</span><br><span class="line">jmp 3:0B16	;执行后，CS&#x3D;0003H，IP&#x3D;0B16H，CPU将从00B46H中读取指令</span><br></pre></td></tr></table></figure>

<p>仅修改IP的内容，可用形如<code>jmp 某一合法地址</code>的指令完成</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiantian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天天的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/20/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/" itemprop="url">（计算机组成原理）第三章 系统总线</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-20T16:28:09+08:00">
                2020-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index">
                    <span itemprop="name">计算机组成原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第三章-系统总线"><a href="#第三章-系统总线" class="headerlink" title="第三章 系统总线"></a>第三章 系统总线</h1><p>计算机系统的五大部件之间的互连方式有两种：</p>
<ul>
<li><p>一种是各部件之间使用单独的连线，称为分散连接；分散连接方式无法解决I/O设备与主机之间连接的灵活性。</p>
</li>
<li><p>另一种是将各部件连到一组公共信息传输线上，称为总线连接。</p>
</li>
</ul>
<p>为什么要用总线？</p>
<ul>
<li>简化的部件的连接</li>
</ul>
<h2 id="总线的基本概念"><a href="#总线的基本概念" class="headerlink" title="总线的基本概念"></a>总线的基本概念</h2><p>总线（bus）</p>
<p><strong>什么是总线？</strong></p>
<ul>
<li>总线是连接各个部件的信息传输线，是各个部件<strong>共享</strong>的传输介质</li>
</ul>
<p><strong>总线上信息的传送</strong></p>
<ul>
<li>每条总线每次可以传输一位二进制代码</li>
<li>若干条总线可以同时传输若干位二进制代码</li>
</ul>
<p><img src="/images/20190107160531984.png" alt="传输信息的方式"></p>
<h2 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h2><p>按连接部件不同，介绍三类总线：片内总线，系统总线，通信总线</p>
<h3 id="片内总线"><a href="#片内总线" class="headerlink" title="片内总线"></a>片内总线</h3><p><strong>芯片内部</strong>的总线</p>
<p>如在CPU芯片内部，寄存器与寄存器之间、寄存器与算逻单元ALU之间都由片内总线连接。</p>
<h3 id="系统总线（板级总线）"><a href="#系统总线（板级总线）" class="headerlink" title="系统总线（板级总线）"></a>系统总线（板级总线）</h3><p>计算机各个部件之间的信息传输线</p>
<p>由于这些部件通常都安放在主板或各个插件板（插卡）上，故又称板级总线（在一块电路板上各芯片间的连线）或板间总线。</p>
<p><strong>系统总线的分类：</strong></p>
<ul>
<li><strong>数据总线：双向</strong><ul>
<li>位数与机器字长和存储字长有关，一般为8位、16位或32位</li>
<li>数据总线位数称为数据总线的宽度</li>
<li>如果数据总线的宽度为8位，指令字长为16位，那么，CPU在取值阶段必须两次访问主存。</li>
</ul>
</li>
<li><strong>地址总线：单向</strong><ul>
<li>与存储地址、I/O地址有关</li>
<li>主要用来指出数据总线上的源数据或目的数据在主存的地址或者I/O设备的地址</li>
</ul>
</li>
<li><strong>控制总线</strong>：<ul>
<li>用来发出各种控制信号的传输线，还起到监视各部件状态的作用。</li>
<li>有出（存储器读写，总线允许，中断确认），有入（中断请求）</li>
<li>通常对任一控制线而言，它的传输是单向的。但对于控制总线总体来说，又可认为是双向的。</li>
</ul>
</li>
</ul>
<h3 id="通信总线"><a href="#通信总线" class="headerlink" title="通信总线"></a>通信总线</h3><p>用于计算机系统之间或计算机系统与其他系统之间的通信</p>
<p>传输方式</p>
<ul>
<li>串行通信总线<ul>
<li>指数据在单条1位宽的传输线上，一位一位按顺序分时传送</li>
</ul>
</li>
<li>并行通信总线<ul>
<li>指数据在多条并行1位宽的同时由源传送到目的地</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>串行通信</th>
<th>并行通信</th>
</tr>
</thead>
<tbody><tr>
<td>适宜距离</td>
<td>远距离传送（可以从几米达数千公里）</td>
<td>近距离的数据传输（通常小于30m）</td>
</tr>
<tr>
<td>数据传送速率</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>通信线路费用</td>
<td>低（还可利用现有的电话网络来实现远程通信）</td>
<td>高</td>
</tr>
</tbody></table>
<h2 id="总线特性及性能指标"><a href="#总线特性及性能指标" class="headerlink" title="总线特性及性能指标"></a>总线特性及性能指标</h2><h3 id="总线特性"><a href="#总线特性" class="headerlink" title="总线特性"></a>总线特性</h3><p><strong>总线的物理实现</strong></p>
<ul>
<li>从物理角度来看，总线由许多导线直接印制在电路板上</li>
</ul>
<p><strong>总线特性</strong></p>
<ul>
<li>机械特性<ul>
<li>尺寸 形状 管脚数 排列顺序</li>
</ul>
</li>
<li>电气特性<ul>
<li>总线的每一根传输线上的信号的<strong>传递方向</strong>和<strong>有效的电平范围</strong></li>
<li>通常规定由CPU发出的信号称为输出信号，送入CPU的信号称为输入信号</li>
</ul>
</li>
<li>功能特性<ul>
<li>每根传输线的功能<ul>
<li>地址</li>
<li>数据</li>
<li>控制</li>
</ul>
</li>
</ul>
</li>
<li>时间特性<ul>
<li>信号的时序关系</li>
</ul>
</li>
</ul>
<h3 id="总线性能指标"><a href="#总线性能指标" class="headerlink" title="总线性能指标"></a>总线性能指标</h3><ol>
<li>总线宽度          数据线的根数，用bit（位）表示</li>
<li>标准传输率          单位时间内总线上传输数据的位数，通常用每秒传输信息的字节数来衡量，单位可用MBps（兆字节每秒）表示。</li>
<li>时钟同步/异步    同步、异步</li>
<li>总线复用             一条信号线上分时传送两种信号，如地址线与数据线复用（8086）</li>
<li>信号线数             地址线、数据线、控制线的总线数的总和</li>
<li>总线控制方式     包括突发工作、自动配置、仲裁方式、逻辑方式、计数方式等</li>
<li>其他指标             负载能力、电源电压、总线宽度能否扩展等</li>
</ol>
<h3 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h3><p>总线标准，可视为系统与各模块、模块与模块之间的一个互连的标准界面。</p>
<p>这个界面对它两端的模块都是透明的，即界面的任一方只需根据总线标准的要求完成自身一方接口的功能需求，而无须了解对方接口与总线的连接要求。</p>
<p>因此，按总线标准设计的接口可视为通用接口。</p>
<p>目前流行的总线标准有以下几种</p>
<p><img src="/images/1583235993056.png" alt="1583235993056"></p>
<h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><h3 id="单总线结构"><a href="#单总线结构" class="headerlink" title="单总线结构"></a>单总线结构</h3><p>将CPU、主存和I/O设备（通过I/O接口）都挂到一组总线上</p>
<p><img src="/images/20190107155404313.png" alt="单总线结构"></p>
<h3 id="面向CPU的双总线结构"><a href="#面向CPU的双总线结构" class="headerlink" title="面向CPU的双总线结构"></a>面向CPU的双总线结构</h3><p>其中一组总线连接CPU和主存，称为<strong>存储总线（M总线）</strong></p>
<p>另一组用来建立CPU和各I/O设备之间交换信息的通道，称为<strong>输入/输出总线（I/O总线）</strong></p>
<p>各种I/O设备通过I/O设备通过I/O接口挂到I/O总线上，更便于增删设备。</p>
<p>当I/O设备与主存交换信息时，原则上不影响CPU的工作</p>
<p><img src="/images/2019010715580499.png" alt="面向CPU的双总线结构框图"></p>
<h3 id="以存储器为中心的双总线结构"><a href="#以存储器为中心的双总线结构" class="headerlink" title="以存储器为中心的双总线结构"></a>以存储器为中心的双总线结构</h3><p>在单总线基础上又开辟出的一条CPU与主存之间的总线，称为存储总线</p>
<p>这组总线速度高，只供主存与CPU之间和传输信息，这样既提高了效率，又减轻了系统总线的负担，还保留了I/O设备与存储器交换信息时不经过CPU的特点</p>
<p><img src="/images/20190107155939152.png" alt="以存储器为中心的双总线结构框图"></p>
<h3 id="双总线结构"><a href="#双总线结构" class="headerlink" title="双总线结构"></a>双总线结构</h3><p>双总线结构的特点是 将速度较低的I/O设备从单总线上分离出来，形成主存总线与I/O总线分开的结构。</p>
<p><img src="/images/20190107170742318.png" alt="双总线结构"></p>
<h3 id="三总线结构"><a href="#三总线结构" class="headerlink" title="三总线结构"></a>三总线结构</h3><p>将速率不同的I/O设备进行分类，然后将它们连接在不同的通道上，可以进一步提高计算机系统的工作效率。</p>
<p><img src="/images/20190107171002206.png" alt="三总线结构"><br>主存总线用于CPU与主存之间的传输</p>
<p>I/O总线供CPU与各类I/O设备之间传递信息</p>
<p>DMA总线用于高速I/O设备（磁盘、磁带等）与主存之间直接交换信息。</p>
<p><img src="/images/20190107171159474.png" alt="三总线结构的又一形式"></p>
<h3 id="四总线结构"><a href="#四总线结构" class="headerlink" title="四总线结构"></a>四总线结构</h3><p>增加了一条与计算机系统紧密相连的高速总线。</p>
<p>在高速总线上挂接了一些高速I/O设备</p>
<p>它们通过Cache控制机构中的高速总线桥或高速缓冲器与系统总线和局部总线相连</p>
<p>在这种结构中，CPU、高速总线的速度以及各自信号线的定一件完全可以不痛，已知各自改变其结构也不会影响高速总线的正常工作</p>
<p><img src="/images/20190107171557664.png" alt="四总线结构"></p>
<h2 id="总线控制"><a href="#总线控制" class="headerlink" title="总线控制"></a>总线控制</h2><p>它主要包括判优控制（或称仲裁逻辑）和通信控制</p>
<h3 id="总线判优控制"><a href="#总线判优控制" class="headerlink" title="总线判优控制"></a>总线判优控制</h3><p>总线上所连接的各类设备，按照其对总线有无控制功能可分为<strong>主设备（模块）</strong>和<strong>从设备（模块）</strong>两种</p>
<ul>
<li><p>主设备对总线有控制权</p>
</li>
<li><p>从设备只能相应从主设备发来的总线命令，对总线没有控制权</p>
</li>
</ul>
<p>总线上的信息的传送是由主设备启动的，只有获得总线控制权的主设备才能开始传送数据</p>
<p>总线判优控制可分为<strong>集中式</strong>和<strong>分布式</strong>两种</p>
<h4 id="集中控制优先权仲裁方式"><a href="#集中控制优先权仲裁方式" class="headerlink" title="集中控制优先权仲裁方式"></a>集中控制优先权仲裁方式</h4><p>将控制逻辑集中在一处（如在CPU中）</p>
<h5 id="链式查询"><a href="#链式查询" class="headerlink" title="链式查询"></a>链式查询</h5><p><img src="/images/20190107172146699.png" alt="链式查询"></p>
<p>离总线控制部件最近的设备具有最高的优先级</p>
<p>特点：</p>
<ul>
<li>只需很少几根线就能按一定优先次序实现总线控制，很简单</li>
<li>很容易扩充设备</li>
<li>对电路故障很敏感</li>
<li>优先级别低的设备可能很难获得请求</li>
</ul>
<h5 id="计时器定时查询"><a href="#计时器定时查询" class="headerlink" title="计时器定时查询"></a>计时器定时查询</h5><p><img src="/images/20190107172357201.png" alt="计时器定时查询"></p>
<p>此方案比链式查询方式多了一组设备地址线，少了一根总线同意线 BG，设备地址由一个计数器给出，属于控制线</p>
<p>总线请求的设备号与计数值一致时，该设备便获得总线使用权，此时终止计数查询，同时该设备建立总线忙 BS 信号</p>
<p>设备的优先级通过设置不同的计数初始值来改变：</p>
<p>☆ 计数总是从 0 开始，此时设备的优先次序是固定的。</p>
<p>☆ 计数的初值总是上次得到控制权设备的设备号，那么所有设备的优先级是相等的，是循环优先级方式</p>
<p>特点：</p>
<ul>
<li>对电路故障不如链式查询方式敏感</li>
<li>增加了控制线（设备地址）数，控制较为复杂</li>
</ul>
<h5 id="独立请求方式"><a href="#独立请求方式" class="headerlink" title="独立请求方式"></a>独立请求方式</h5><p><img src="/images/20190107172615423.png" alt="独立请求方式"></p>
<p>特点：</p>
<ul>
<li><p>响应速度快</p>
</li>
<li><p>优先次序控制灵活（通过程序改变）</p>
</li>
<li><p>控制线数量多</p>
</li>
<li><p>总线控制更复杂</p>
</li>
</ul>
<p>链式查询中仅用两根线确定总线使用权书序那个设备</p>
<p>在计数器查询中大致用 $log_2n$ 根线</p>
<p>而独立请求方式需采用2n根线</p>
<p>n是允许接纳的最大设备数</p>
<h3 id="总线通信控制"><a href="#总线通信控制" class="headerlink" title="总线通信控制"></a>总线通信控制</h3><p>目的：解决通信双方<strong>协调配合</strong>问题</p>
<p>在通信时间上，应按分时方式来处理，即以获得总线使用权的先后顺序分时占用总线，即哪一个部件获得使用权，此刻就由它传送，下一部件获得使用权，接着下一时刻传送</p>
<p>这样一个接一个轮流交替传送</p>
<h4 id="总线周期"><a href="#总线周期" class="headerlink" title="总线周期"></a>总线周期</h4><p>通常将完成一次总线操作的时间称为总线周期，可分为以下四个阶段</p>
<h5 id="申请分配阶段"><a href="#申请分配阶段" class="headerlink" title="申请分配阶段"></a>申请分配阶段</h5><p>由需要使用总线的<strong>主模块（或主设备）提出申请</strong>，经总线仲裁机构决定下一传输周期的总线使用权授于某一申请者</p>
<h5 id="寻址阶段"><a href="#寻址阶段" class="headerlink" title="寻址阶段"></a>寻址阶段</h5><p>取得了使用权的主模块通过发出本次要访问的从模块（或从设备）的地址及有关命令，启动参与本次传输的从模块</p>
<h5 id="传输阶段"><a href="#传输阶段" class="headerlink" title="传输阶段"></a>传输阶段</h5><p>主模块和从模块进行数据交换，数据由源模块发出，经数据总线流入目的模块</p>
<h5 id="结束阶段"><a href="#结束阶段" class="headerlink" title="结束阶段"></a>结束阶段</h5><p>主模块的有关信息均从系统总线上撤出，让出总线使用权</p>
<p>总线通信主要解决通信双方如何获知传输开始和传输结束，以及通信双方如何协调如何配合。</p>
<h4 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h4><p>通常用四种方式：同步通信、异步通信、半同步通信和分离式通信</p>
<h5 id="3-5-2-2-1-同步通信（同步式数据输入）"><a href="#3-5-2-2-1-同步通信（同步式数据输入）" class="headerlink" title="3.5.2.2.1 同步通信（同步式数据输入）"></a>3.5.2.2.1 同步通信（同步式数据输入）</h5><p>通信双方由统一时标控制数据传送称为同步通信。</p>
<p>时标通常由CPU的总线控制部件发出，送到总线上的所有部件</p>
<p>也可以由每个部件各自的时序发生器发出，但必须由总线控制部件发出的时钟信号对它们进行同步</p>
<p><img src="/images/20190107192413143.png" alt="同步通信：读"></p>
<p><img src="/images/20190107193731704.png" alt="同步通信：写"></p>
<p><strong>优点：</strong>规定明确、统一，模块间的配合简单已知。</p>
<p><strong>缺点：</strong>主、从模块时间配合属于强制性“同步”，必须在限定时间内完成规定的要求。并且对所有从模块都用同一限时，这就势必造成，对各不相同速度的部件而言，必须按最慢速度的部件来设计公共时钟，严重影响总线的工作效率，也给设计带来了局限性，缺乏灵活性。</p>
<p><strong>适用场合：</strong>总线长度较短，各部件存取时间比较统一的场合。</p>
<p>在同步通信的总线系统中，总线传输周期越短，数据线的位数越多，直接影响总线的数据传输率</p>
<h5 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h5><p>异步通信克服了同步通信的缺点，允许各模块速度的不一致性，给设计者充分的灵活性和选择余地。</p>
<p>它没有公共的时钟标准，不要求所有部件严格的统一操作时间，而是采用应答方式（又称握手方式）</p>
<p>即当主模块发出请求（Request）信号时，一直等待从模块反馈回来“响应”（Acknowledge）信号后，才开始通信。</p>
<p>这要求主、从模块之间增加两条应答线（握手交互线 Handshaking）</p>
<p>异步通信的应答方式又可分为不互锁、半互锁和全互锁三种类型</p>
<p><img src="/images/20190107193811251.png" alt="异步通信"><br>异步通信可用于并行通信或串行通信</p>
<p>异步串行通信时约定字符格式为：1个起始位（低电平）、5 ~ 8个数据位、1个奇偶校验位（作检测用）、1或1.5或2个终止位（高电平）</p>
<p>传送时起始位后面紧跟的是要传送字符的最低位，每个字符的结束时一个高电平的终止位。</p>
<p>异步串行通信的数据传送速率用波特率来衡量</p>
<p>波特率是指单位时间内传送二进制数据的位数，单位用bps（位/秒）表示，记作波特</p>
<h6 id="不互锁方式"><a href="#不互锁方式" class="headerlink" title="不互锁方式"></a>不互锁方式</h6><p>主模块发出请求信号后，不必等待街道从模块的会打信号，而是经过一段时间，确定从模块已收到请求信号后，便撤销其请求信号</p>
<p>从模块接到请求信号后，在条件允许时发出回答信号，并且经过一段时间确定主模块已收到回答信号后，自动撤销回答信号</p>
<p>均无互锁关系</p>
<h6 id="半互锁方式"><a href="#半互锁方式" class="headerlink" title="半互锁方式"></a>半互锁方式</h6><p>主模块发出请求信号，必须接到从模块的回答信号后再撤销其请求信号，有互锁关系</p>
<p>从模块在接到请求信号后发出回答信号，但不必等待获知主模块的请求信号已经撤销，而是隔一段时间后自动撤销其回答信号，无互锁关系</p>
<h6 id="全互锁方式"><a href="#全互锁方式" class="headerlink" title="全互锁方式"></a>全互锁方式</h6><p>主模块发出请求信号，必须待从模块回答后在撤销其请求信号</p>
<p>从模块发出回答信号，必须待获知主模块请求信号已撤销后，再撤销其回答信号</p>
<p>双方存在互锁关系</p>
<h4 id="半同步通信"><a href="#半同步通信" class="headerlink" title="半同步通信"></a>半同步通信</h4><p>半同步通信既保留了同步通信的基本特点</p>
<p>同时又像异步通信那样，允许不同速度的模块和谐地工作</p>
<p>为此增设了一条“等待”（WAIT）响应信号线，采用插入时钟（等待）周期的措施来协调通行双方的配合问题</p>
<p><img src="/images/20190107195753683.png" alt="半同步通信"></p>
<p><img src="/images/20190107195902609.png" alt="半同步通信"></p>
<p>半同步通信适用于系统工作速度不高但又包含了由许多工作速度差异较大的各类设备组成的简单系统。</p>
<p>半同步通信控制方式比异步通信简单，在全系统内各模块又在统一的系统时钟控制下同步工作，可靠性高，同步结构较方便</p>
<p>其缺点是对系统时钟频率不能要求太刀，故从整体来看，系统工作的速度还不是很高</p>
<p><img src="/images/20190107200251772.png" alt="共同点"></p>
<h4 id="分离式通信"><a href="#分离式通信" class="headerlink" title="分离式通信"></a>分离式通信</h4><p>对于系统总线而言，从模块内部读数据过程并无实质性的信息传输，总线纯属空闲等待。</p>
<p>为了克服和利用这种消极等待，<strong>充分挖掘系统总线没瞬间的潜力</strong>，对提高系统性能起极大作用。</p>
<p>其基本思想是将一个传输周期（或总线周期）分解为两个子周期。</p>
<p>在第一个字周期中，主模块A在获得总线使用权后将命令、地址以及其他有关信息，包括该主模块编号（当有多个主模块时，此标号尤为重要）发到系统总线上，经总线传输后，由有关的从模块B接收下来。主模块A向系统总线发布这些信息只占用总线很短的时间，一旦发送完，立即放弃总线使用权，以便其他模块使用</p>
<p>在第二个子周期中，当B模块收到A模块发来的有关命令信号后，经选择、译码、读取等一系列内部操作，将A模块所需的数据准备好，便由B模块申请总线使用权，一旦获准，B模块便将A模块的编号、B模块的地址、A模块所需的数据等一系列信息送到总线上，供A接受</p>
<p>上述两个传输子周期都只有单方向的信息流，每个模块都变成了主模块</p>
<p><strong>特点</strong>：</p>
<ol>
<li>各模块欲占用总线使用权都必须提出申请。</li>
<li>在得到总线使用权后，主模块在限定时间内向对方传送信息，采用同步方式传送，不再等待对方的回答信号</li>
<li>各模块在准备数据的过程中都不用占用总线，使总线可接受其他模块的请求</li>
<li>总线被占用时都在做有效工作，不存在空闲等待时间，充分利用了总线的有效占用，从而实现了总线在多个主从模块间进行信息交叉重叠并行式传送，这对大型计算机系统是极为重要的</li>
</ol>
<p>这种方式控制比较复杂，一般在微型计算机系统中很少采用</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%8A%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiantian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天天的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/20/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%8A%E5%BA%94%E7%94%A8/" itemprop="url">（计算机组成原理）第二章 计算机的发展及应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-20T16:25:09+08:00">
                2020-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index">
                    <span itemprop="name">计算机组成原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第二章-计算机的发展及应用"><a href="#第二章-计算机的发展及应用" class="headerlink" title="第二章 计算机的发展及应用"></a>第二章 计算机的发展及应用</h1><h2 id="2-1-计算机的发展史"><a href="#2-1-计算机的发展史" class="headerlink" title="2.1 计算机的发展史"></a>2.1 计算机的发展史</h2><h3 id="2-1-1-计算机的产生和发展"><a href="#2-1-1-计算机的产生和发展" class="headerlink" title="2.1.1 计算机的产生和发展"></a>2.1.1 计算机的产生和发展</h3><ul>
<li>第一代电子管计算机<ul>
<li>ENIAC：1946</li>
</ul>
</li>
<li>第二代晶体管计算机</li>
<li>第三代集成电路计算机</li>
</ul>
<h3 id="2-1-2-微型计算机的出现和发展"><a href="#2-1-2-微型计算机的出现和发展" class="headerlink" title="2.1.2 微型计算机的出现和发展"></a>2.1.2 微型计算机的出现和发展</h3><p>1971年，摩尔定律：当价格不变时，集成电路上可容纳的元器件的数目，约每隔18-24个月便会增加一倍，性能也将提升一倍。换言之，每一美元所能买到的电脑性能，将每隔18-24个月翻一倍以上</p>
<h3 id="2-1-3-软件技术的兴起和发展"><a href="#2-1-3-软件技术的兴起和发展" class="headerlink" title="2.1.3 软件技术的兴起和发展"></a>2.1.3 软件技术的兴起和发展</h3><p><strong>各种语言</strong></p>
<ul>
<li>机器语言<ul>
<li>FORTRAN 科学计算和工程计算</li>
</ul>
</li>
<li>汇编语言<ul>
<li>PASCAL 结构化程序设计</li>
</ul>
</li>
<li>高级语言<ul>
<li>c++ 面向对象</li>
<li>java 适应网络环境</li>
</ul>
</li>
</ul>
<p><strong>系统软件</strong></p>
<ul>
<li>语言处理程序</li>
<li>操作系统</li>
<li>服务器程序</li>
<li>数据库管理系统</li>
<li>网络软件</li>
</ul>
<p><strong>软件发展特点</strong></p>
<ol>
<li>开发周期长</li>
<li>制作成本昂贵</li>
<li>检测软件产品质量的特殊性</li>
<li>开发效率低</li>
</ol>
<h2 id="2-2-计算机的应用"><a href="#2-2-计算机的应用" class="headerlink" title="2.2 计算机的应用"></a>2.2 计算机的应用</h2><h3 id="2-2-1-科学计算和数据处理"><a href="#2-2-1-科学计算和数据处理" class="headerlink" title="2.2.1 科学计算和数据处理"></a>2.2.1 科学计算和数据处理</h3><h3 id="2-2-2-工业控制和实时控制"><a href="#2-2-2-工业控制和实时控制" class="headerlink" title="2.2.2 工业控制和实时控制"></a>2.2.2 工业控制和实时控制</h3><h3 id="2-2-3-网络技术的应用"><a href="#2-2-3-网络技术的应用" class="headerlink" title="2.2.3 网络技术的应用"></a>2.2.3 网络技术的应用</h3><ol>
<li>电子商务</li>
<li>电子教育</li>
<li>敏捷制造</li>
</ol>
<h3 id="2-2-4-虚拟现实"><a href="#2-2-4-虚拟现实" class="headerlink" title="2.2.4 虚拟现实"></a>2.2.4 虚拟现实</h3><h3 id="2-2-5-办公自动化和管理信息系统"><a href="#2-2-5-办公自动化和管理信息系统" class="headerlink" title="2.2.5 办公自动化和管理信息系统"></a>2.2.5 办公自动化和管理信息系统</h3><h3 id="2-2-6-CAD-CAM-CIMS"><a href="#2-2-6-CAD-CAM-CIMS" class="headerlink" title="2.2.6 CAD/CAM/CIMS"></a>2.2.6 CAD/CAM/CIMS</h3><p>CAD：计算机辅助设计</p>
<p>CAM：计算机辅助制造</p>
<p>CIMS：计算机集成制造系统</p>
<h3 id="2-2-7-多媒体技术"><a href="#2-2-7-多媒体技术" class="headerlink" title="2.2.7 多媒体技术"></a>2.2.7 多媒体技术</h3><h3 id="2-2-8-人工智能"><a href="#2-2-8-人工智能" class="headerlink" title="2.2.8 人工智能"></a>2.2.8 人工智能</h3><h2 id="2-3-计算机的展望"><a href="#2-3-计算机的展望" class="headerlink" title="2.3 计算机的展望"></a>2.3 计算机的展望</h2><ol>
<li>计算机具有类似人脑的超级智能功能（计算速度）</li>
<li>芯片集成度的提高受一下三方面的限制<ol>
<li>物理极限</li>
<li>成本</li>
<li>功耗，散热，线延迟</li>
</ol>
</li>
<li>？替代传统硅芯片<ol>
<li>光计算机（已经实现数据传输）</li>
<li>DNA生物计算机</li>
<li>量子计算机（量子密码）</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E8%BF%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiantian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天天的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/20/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E6%A6%82%E8%BF%B0/" itemprop="url">（计算机组成原理）第一章 概述</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-20T16:24:09+08:00">
                2020-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" itemprop="url" rel="index">
                    <span itemprop="name">计算机组成原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第1章-概论"><a href="#第1章-概论" class="headerlink" title="第1章  概论"></a>第1章  概论</h1><h2 id="1-1-计算机系统简介"><a href="#1-1-计算机系统简介" class="headerlink" title="1.1 计算机系统简介"></a>1.1 计算机系统简介</h2><h3 id="软硬件概念"><a href="#软硬件概念" class="headerlink" title="软硬件概念"></a>软硬件概念</h3><p>计算机系统由<strong>硬件</strong>和<strong>软件</strong>两大部分组成：系统软件，软硬件界面</p>
<h3 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a><strong>计算机系统的层次结构</strong></h3><p>五级层次结构</p>
<ul>
<li><img src="/images%5C1582677917230.png" alt="1582677917230"></li>
<li>前三个是软件，后两个是硬件</li>
<li>将高级语言翻译成机器语言的软件称为翻译程序<ul>
<li>编译程序：将用户编写的高级语言程序的全部语句一次性全部翻译成机器语言程序，然后在执行机器语言程序</li>
<li>解释程序：逐条翻译，直至全部翻译完成</li>
</ul>
</li>
</ul>
<h2 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h2><p>计算机体系结构</p>
<ul>
<li>用机器语言（也包括汇编语言）编程的程序员所见到的计算机系统的属性概念性的结构与功能特性</li>
<li>如：是否具备乘法指令功能</li>
</ul>
<p>计算机组成原理</p>
<ul>
<li>实现计算机体系结构所体现的属性</li>
<li>如：实现乘法指令需要什么方式</li>
</ul>
<h2 id="1-2计算机的基本组成"><a href="#1-2计算机的基本组成" class="headerlink" title="1.2计算机的基本组成"></a>1.2计算机的基本组成</h2><h3 id="1-2-1-冯诺依曼计算机的特点"><a href="#1-2-1-冯诺依曼计算机的特点" class="headerlink" title="1.2.1 冯诺依曼计算机的特点"></a>1.2.1 冯诺依曼计算机的特点</h3><p>1945年，数学家冯诺依曼在研究EDVAC机时提出了“存储程序”的概念。一次概念为基础的各类计算机统称为冯诺依曼机。特点如下：</p>
<ul>
<li>计算机有运算器、存储器、控制器、输入设备和输出设备五大部件组成</li>
<li>指令和数据以同等地位存放于存储器内。并可按地址访问。</li>
<li>指令和数据均可用二进制表示</li>
<li>指令由操作码和地址码组成。操作码表示操作的性质、地址码表示操作数在存储器中的位置。</li>
<li>指令在存储器中按顺序存放。通常，指令时顺序执行的。在特殊情况下，可根据运算结果或指定的条件来改变运算顺序。</li>
<li>机器以运算器为中心。输入输出设备和存储器之间的数据传送通过运算器完成、</li>
</ul>
<h3 id="1-2-2-计算机的硬件框图"><a href="#1-2-2-计算机的硬件框图" class="headerlink" title="1.2.2 计算机的硬件框图"></a>1.2.2 计算机的硬件框图</h3><p>经典的冯诺依曼计算机是以运算器为中心的</p>
<p><img src="/images%5C1582679475845.png" alt="1582679475845"></p>
<p>现代计算机已经以存储器为中心</p>
<p><img src="/images%5C1582679523790.png" alt="1582679523790"></p>
<p>图中各部件的功能如下</p>
<p><img src="/images%5C1582680895172.png" alt="1582680895172"></p>
<ul>
<li><p>控制器：计算机的控制系统，控制、指挥程序和数据的输入、运行以及处理运算结果</p>
</li>
<li><p>运算器：计算机的运算系统</p>
<ul>
<li>逻辑运算（判断事物的对与错）</li>
<li>数学运算（1+1）</li>
<li>控制器 + 运算器 = 中央处理器（CPU）</li>
</ul>
</li>
<li><p>存储器：计算机存储系统，用于存放数据和程序</p>
<ul>
<li>内存<ul>
<li>基于电工作的</li>
<li>优点：读取速度快</li>
<li>缺点：断电数据丢失</li>
</ul>
</li>
<li>外存<ul>
<li>优点：可以永久存储数据</li>
<li>缺点：读取速度慢</li>
</ul>
</li>
</ul>
</li>
<li><p>输入设备：将人们所熟悉的信息形式转化为机器能识别的信息形式</p>
<ul>
<li>键盘、鼠标、麦克风、摄像头、触摸屏等</li>
</ul>
</li>
<li><p>输出设备：将机器的运算结果转化为人们所熟悉的信息形式</p>
<ul>
<li>显示器、音响、打印机</li>
</ul>
</li>
</ul>
<p>运算器和控制器常常集合在同一芯片上，即CPU。算数逻辑单元（ALU）完成算数逻辑运算；控制单元（CU）用来解释存储器中的指令，并发出各种操作命令来执行指令</p>
<p>把输入与输出设备简称为I/O设备</p>
<p>这样，现代计算机可认为由三大组成部分组成：CPU，I/O设备，主存储器</p>
<p><img src="/images%5C1582680651138.png" alt="1582680651138"></p>
<h2 id="1-3-计算机的工作步骤"><a href="#1-3-计算机的工作步骤" class="headerlink" title="1.3 计算机的工作步骤"></a>1.3 计算机的工作步骤</h2><h4 id="上机前的准备"><a href="#上机前的准备" class="headerlink" title="上机前的准备"></a>上机前的准备</h4><ol>
<li><p>建立数学模型</p>
</li>
<li><p>确定计算方法</p>
</li>
<li><p>编写解题程序</p>
<ul>
<li><strong>以$ax^2+bx+c$为例</strong></li>
</ul>
<ol>
<li>将$x​$取至运算器中</li>
<li>乘以$x$，得$x^2$，存于运算器中</li>
<li>再乘以$x​$，得$ax^2​$，存于运算器中</li>
<li>将$ax^2$送至存储器中</li>
<li>取$b$送至运算器</li>
<li>乘以$x​$，得$bx​$，存于运算器中</li>
<li>将$ax^2​$从存储器中取出与$bx​$相加，得$ax^2+bx​$，存于运算器中</li>
<li>再取$c$与$ax^2+bx$相加，得$ax^2+bx+c$，存于运算器中</li>
</ol>
<ul>
<li>可见不包含停机，输出打印共需8步</li>
<li>如果将上例改为$(ax+b)x+c​$，步骤可简化为：</li>
</ul>
<ol>
<li>将$x​$取至运算器中</li>
<li>乘以$a​$，得$ax​$，存于运算器中</li>
<li>加$b​$，得$ax+b​$，存于运算器中</li>
<li>再乘以$x​$，得$(ax+b)x​$，存于运算器中</li>
<li>再取$c$与$(ax+b)x$相加，得$(ax+b)x+c$，存于运算器中</li>
</ol>
</li>
</ol>
<ul>
<li><p><img src="/images%5C1582855145138.png" alt="1582855145138"></p>
</li>
<li><p><img src="/images%5C1582855194094.png" alt="1582855194094"></p>
</li>
<li><p>指令和数据都是保存在存储器中</p>
</li>
</ul>
<ol start="4">
<li>上机运行</li>
</ol>
<h4 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h4><h5 id="存储器的基本组成"><a href="#存储器的基本组成" class="headerlink" title="存储器的基本组成"></a>存储器的基本组成</h5><p><img src="/images%5C1582855467472.png" alt="1582855467472"></p>
<h5 id="主存储器（主存-内存）"><a href="#主存储器（主存-内存）" class="headerlink" title="主存储器（主存/内存）"></a>主存储器（主存/内存）</h5><ul>
<li><strong>存储体</strong><ul>
<li>存储体由很多存储单元组成，每个存储单元又包含很多存储元件</li>
<li>存储单元：一个存储单元可存储一串二进制代码</li>
<li>存储字：一个存储单元存储的二进制代码为一个存储字<ul>
<li>可以代表一个二进制数</li>
<li>也可代表一串字符</li>
<li>还可代表一条指令</li>
</ul>
</li>
<li>存储字长：这串二进制代码的位长，可以是8，16，32位等，必须是字节的整数倍（1Byte=8bit）</li>
<li>按地址进行寻址（仿存）</li>
</ul>
</li>
<li><strong>MAR</strong>：存储器地址寄存器<ul>
<li>用于存放欲访问的存储单元的地址</li>
<li><strong>位数对应存储单元的个数</strong>（如MAR为10位，则有$2^{10}=1024​$个存储单元，记为1K）</li>
</ul>
</li>
<li><strong>MDR</strong>：存储器数据寄存器<ul>
<li>存放存储体某单元取出的代码或者准备往某单元存入的代码</li>
<li><strong>位数与存储字长相等</strong></li>
</ul>
</li>
<li>当然想要完成一个完整的取或存操作，CPU还要给主存加以各种控制信号，如读命令、写命令、地址译码驱动信号等。</li>
</ul>
<h5 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a>运算器</h5><ul>
<li>运算器中至少包含3个寄存器和一个算数逻辑单元（AlU）<ul>
<li>ACC为累加器</li>
<li>MQ为乘商寄存器</li>
<li>X为操作数寄存器</li>
<li><img src="/images%5C1582859304863.png" alt="1582859304863"></li>
<li><img src="/images%5C1582857781237.png" alt="1582857781237"></li>
</ul>
</li>
</ul>
<p>M：存储器的任一地址号</p>
<p>[M]：对应M地址号单元中的内容</p>
<p>ACC：累加器</p>
<p>[ACC]：累加器中的内容</p>
<p>其余类似</p>
<p>加法操作</p>
<p><img src="/images%5C1582859523451.png" alt="1582859523451"></p>
<p>减法操作</p>
<p><img src="/images%5C1582859562392.png" alt="1582859562392"></p>
<p>乘法操作</p>
<ul>
<li>ACC中已有被乘数</li>
</ul>
<p><img src="/images%5C1582859576036.png" alt="1582859576036"></p>
<p>除法操作</p>
<p><img src="/images%5C1582859591318.png" alt="1582859591318"></p>
<h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><ul>
<li>操作过程<ul>
<li>取指令</li>
<li>分析</li>
<li>执行指令</li>
</ul>
</li>
<li>组成<ul>
<li>程序计数器（Program Counter， <strong>PC</strong>）<ul>
<li>存放当前欲执行指令的地址</li>
<li>它与主存的MAR之间有一条直接通路，具有自动加1的功能，即可自动形成下一条指令的地址</li>
</ul>
</li>
<li>指令寄存器（Instruction Register， <strong>IR</strong>）<ul>
<li>存放当前的指令</li>
<li>内容来自主存的MDR</li>
<li>IR中的操作码(OP(IR))送至CU，记作$OP(IR)\to CU$，用于分析指令</li>
<li>其地址码(Ad(IR))作为操作数的地址送至存储器的MAR，记作$Ad(IR)\to MAR​$</li>
</ul>
</li>
<li>控制单元（CU）<ul>
<li>用来分析当前所需完成的操作，并发出各种微操作命令序列，用以控制所有被控对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="主机完成一条指令的过程"><a href="#主机完成一条指令的过程" class="headerlink" title="主机完成一条指令的过程"></a>主机完成一条指令的过程</h5><p>取数：</p>
<p><img src="/images%5C1582861924954.png" alt="1582861924954"></p>
<ul>
<li>例读数操作，操作码：000001，地址码：0000001000</li>
</ul>
<ol>
<li>启动机器后，控制器将PC的内用送至主存的MAR中（$PC \to MAR$）</li>
<li>并命令存储器做读操作</li>
<li>此时主存中对应地址的内容被送至MDR中</li>
<li>$MDR\to IR$，完成了一条指令的取指操作</li>
<li>经CU分析（$OP(IR)\to CU​$），操作码为取数指令</li>
<li>于是CU又将IR中的地址码送至MAR（$Ad(IR)\to MAR$）</li>
<li>并命令存储器做读操作</li>
<li>将改地址单元中的操作数x送至MDR</li>
<li>再由MDR送至运算器ACC中（$MDR\to ACC$）</li>
<li>第一条取数指令的全过程已全部结束，PC同时完成自动加1的操作，继续进行操作直至打印出结果，最后执行完停机指令，机器便自动停机。</li>
</ol>
<p>存数：</p>
<p><img src="/images%5C1582861831928.png" alt="1582861831928"></p>
<h5 id="ax-2-bx-c-的过程"><a href="#ax-2-bx-c-的过程" class="headerlink" title="$ax^2+bx+c$的过程"></a>$ax^2+bx+c$的过程</h5><ul>
<li>将程序通过输入设备送至计算机</li>
<li>程序将首地址 $\to​$ PC</li>
<li>启动程序运行</li>
<li>取指令 PC$\to​$ MAR $\to​$ M $\to​$ MDR$\to​$ IR，(PC)+1$\to​$PC</li>
<li>分析指令 OP(IR) $\to​$ CU</li>
<li>执行指令 Ad(IR) $\to$ MAR $\to$ M $\to$ MDR $\to​$ ACC</li>
<li>……</li>
<li>打印结果</li>
<li>停机</li>
</ul>
<h2 id="1-4-计算机硬件的主要技术指标"><a href="#1-4-计算机硬件的主要技术指标" class="headerlink" title="1.4 计算机硬件的主要技术指标"></a>1.4 计算机硬件的主要技术指标</h2><h3 id="1-4-1-机器字长"><a href="#1-4-1-机器字长" class="headerlink" title="1.4.1 机器字长"></a>1.4.1 机器字长</h3><p>CPU一次能处理数据的位数，通常与CPU的<strong>寄存器位数</strong>有关</p>
<p>字长越长，数的表示范围越大，精度也越高。</p>
<p>机器的字长也会影响机器的运行速度</p>
<p>会直接影响加法器（或ALU）、数据总线以及存储字长的位数</p>
<h3 id="1-4-2-存储容量"><a href="#1-4-2-存储容量" class="headerlink" title="1.4.2 存储容量"></a>1.4.2 存储容量</h3><p>包括主存容量和辅存容量</p>
<p>主存容量：主存中存放二进制代码的总位数<br>    <strong>存储容量 = 存储单元个数 * 存储字长</strong></p>
<p>MAR的位数反映了存储单元的个数，MDR反映了存储字长</p>
<p>如MAR为16位，则存储体中有$2^{16}=65536$个存储单元（即64K个存储字）</p>
<p>MDR为32位，表示存储容量为$2^{16}\times 32 = 2M$位（1M=$2^{20}=2^{18}B=256KB$）</p>
<h3 id="1-4-3-运算速度"><a href="#1-4-3-运算速度" class="headerlink" title="1.4.3 运算速度"></a>1.4.3 运算速度</h3><p><strong>普通法</strong>：早期用完成一次加法或乘法所需的时间来衡量运算速度</p>
<p><strong>吉普森法</strong>（Gibson）：综合考虑每条指令的执行时间以及他们在全部操作中所占的百分比$T_M=\sum\limits_{i=1}^nf_it_i$<br>参数分别表示机器运行速度，第i种指令所占百分比数，第i种指令的执行时间</p>
<p><strong>现在的方法</strong>：单位时间内执行指令的平均条数</p>
<ul>
<li>主频</li>
<li>核数，每个核支持的线程数</li>
<li>吉普森法</li>
<li>CPI 执行一条指令所需时钟周期</li>
<li>MITS 每秒能执行百万条指令</li>
<li>FLOPS 每秒浮点运算次数</li>
</ul>
<h2 id="1-5-本书结构"><a href="#1-5-本书结构" class="headerlink" title="1.5 本书结构"></a>1.5 本书结构</h2><p><img src="/images/1583049812502.png" alt="1583049812502"></p>
<p><img src="/images/1583049832011.png" alt="1583049832011"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiantian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天天的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/20/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81/" itemprop="url">第三章 分组密码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-20T16:18:09+08:00">
                2020-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" itemprop="url" rel="index">
                    <span itemprop="name">密码学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第三章-分组密码"><a href="#第三章-分组密码" class="headerlink" title="第三章 分组密码"></a>第三章 分组密码</h2><p>索引</p>
<p><a href="#分组密码的基本概念">分组密码的基本概念</a></p>
<p><a href="#分组密码的基本概念">Feistel密码结构</a></p>
<p><a href="#分组密码的基本概念">SP网络</a></p>
<p><a href="#分组密码的基本概念">DES</a></p>
<p><a href="#分组密码的基本概念">分组密码的工作模式</a></p>
<h3 id="3-1-分组密码的基本概念"><a href="#3-1-分组密码的基本概念" class="headerlink" title="3.1 分组密码的基本概念"></a>3.1 <span id="分组密码的基本概念">分组密码的基本概念</span></h3><h4 id="3-1-1-概念"><a href="#3-1-1-概念" class="headerlink" title="3.1.1 概念"></a>3.1.1 概念</h4><ul>
<li><p><strong>分组密码的应用</strong></p>
<ul>
<li>伪随机数生成器 </li>
<li>流密码 </li>
<li>消息认证码(MAC)和哈希函数 </li>
<li>消息认证技术、数据完整性机制、实体认证协议以及单钥数字签字体制的核心组成部分。</li>
</ul>
</li>
<li><p><strong>应用中对于分组码的要求</strong> </p>
<ul>
<li>安全性 </li>
<li>运行速度 </li>
<li>存储量(程序的长度、数据分组长度、高速缓存大小) </li>
<li>实现平台(硬、软件、芯片) </li>
<li>运行模式</li>
</ul>
</li>
</ul>
<p><img src="/images/1583399087925.png" alt="1583399087925"></p>
<p><img src="/images/1583399124542.png" alt="1583399124542"></p>
<p>通常取n=m。 </p>
<p>若n&lt;m ，则为有数据扩展的分组密码。 </p>
<p>若n&gt;m ，则为有数据压缩的分组密码。</p>
<h5 id="安全性设计原则"><a href="#安全性设计原则" class="headerlink" title="安全性设计原则"></a>安全性设计原则</h5><ol>
<li><h6 id="混淆原则"><a href="#混淆原则" class="headerlink" title="混淆原则"></a>混淆原则</h6></li>
</ol>
<p>混淆原则就是将密文、明文、密钥三者之间的统计关系和代数关系变得尽可能复杂，使得敌手即使获得了密文和明文，也无法求出密钥的任何信息；即使获得了密文和明文的统计规律，也无法求出明文的新的信息。</p>
<ul>
<li>明文不能由已知的明文，密文及少许密钥比特代数地或统计地表示出来。</li>
<li>密钥不能由已知的明文，密文及少许密钥比特代数地或统计地表示出来</li>
</ul>
<ol start="2">
<li><h6 id="扩散原则"><a href="#扩散原则" class="headerlink" title="扩散原则"></a>扩散原则</h6></li>
</ol>
<p>扩散原则就是应将明文的统计规律和结构规律散射到相当长的一段统计中去。(Shannon的原话)。</p>
<ul>
<li><p>也就是说让明文中的每一位影响密文中的尽可能多的位，或者说让密文中的每一位都受到明文中的尽可能多位的影响。</p>
</li>
<li><p>如果当明文变化一个比特时,密文有某些比特不可能发生变化,则这个明文就与那些密文无关,因而在攻击这个明文比比特时就可不利用那些密文比特</p>
</li>
</ul>
<h5 id="分组密码算法应满足的要求"><a href="#分组密码算法应满足的要求" class="headerlink" title="分组密码算法应满足的要求"></a>分组密码算法应满足的要求</h5><ul>
<li>分组长度n要足够大：<ul>
<li>使分组代换字母表的元素个数 $2^n$ 足够大 </li>
<li>防止明文穷举攻击法奏效。 </li>
</ul>
</li>
<li>密钥量要足够大： <ul>
<li>即置换子集中的元素足够多的</li>
<li>尽可能消除弱密钥并使所有密钥同等地好，以防止密钥穷举攻击奏效</li>
<li>但密钥又不能过长，以便于密钥的管理</li>
</ul>
</li>
<li>由密钥确定置换的算法要足够复杂： <ul>
<li>充分实现明文与密钥的扩散和混淆，没有简单的关系可循，要能抗击各种已知的攻击</li>
</ul>
</li>
<li>加密和解密运算简单： <ul>
<li>易于软件和硬件高速实现。 </li>
</ul>
</li>
<li>数据扩展： <ul>
<li>一般无数据扩展，在采用同态置换和随机化加密技术时可引入数据扩展。 </li>
</ul>
</li>
<li>差错传播尽可能地小：<ul>
<li>一个密文分组的错误尽可能少的影响其他密文分组的解密</li>
</ul>
</li>
</ul>
<h5 id="分组密码的实现原则"><a href="#分组密码的实现原则" class="headerlink" title="分组密码的实现原则"></a>分组密码的实现原则</h5><ul>
<li>软件实现的原则： <ul>
<li>使用子块和简单的运算。如将分组n化分为子段，每段长为8、16或32。 </li>
<li>在以软件实现时，应选用简单的运算，使作用于子段上的密码运算易于以标准处理器的基本运算，如加、乘、移位等实现，避免用以软件难于实现的逐比特置换</li>
</ul>
</li>
<li>硬件实现的原则： <ul>
<li>加密解密可用同样的器件来实现</li>
</ul>
</li>
</ul>
<h4 id="设计分组密码时的常用方法"><a href="#设计分组密码时的常用方法" class="headerlink" title="设计分组密码时的常用方法"></a>设计分组密码时的常用方法</h4><h5 id="3-1-2-代换"><a href="#3-1-2-代换" class="headerlink" title="3.1.2 代换"></a>3.1.2 代换</h5><p><img src="/images/1583399909167.png" alt="1583399909167"></p>
<p><img src="/images/1583400204396.png" alt="1583400204396"></p>
<p>上图代表 n=4 的代换密码的一般结构，4 比特输出产生16 个可能输入状态中的一个，由代换结构将这一状态映射为16个可能输出状态中的一个，每一输出状态由4个密文比特表示。</p>
<p>加密映射和解密映射可由代换表来定义：<img src="/images/1583400349427.png" alt="1583400349427"></p>
<p>但是这样的代换结构有一些问题需要考虑：</p>
<ul>
<li>如果分组长度太小，如n=4，系统则等价于古典的代换密码，容易通过对明文的统计分析而被攻破 <ul>
<li>这个弱点不是代换结构固有的，只是因为分组长度太小</li>
<li>如果分组长度n足够大，而且从明文到密文可有任意可逆的代换，那么明文的统计特性将被隐藏而使以上的攻击不能奏效</li>
<li>但是使n很大是不现实的，会导致密钥太大而无法处理</li>
</ul>
</li>
</ul>
<h5 id="3-1-2-扩散和混淆"><a href="#3-1-2-扩散和混淆" class="headerlink" title="3.1.2 扩散和混淆"></a>3.1.2 扩散和混淆</h5><p>扩散和混淆是 Shannon 提出的涉及密码系统的两个基本方法，目的是抗击敌手对密码系统的统计分析</p>
<p><strong>扩散</strong></p>
<ul>
<li>将明文的统计特性散布到密文中</li>
<li>实现的方式是使密文中每一位由明文中的多位产生</li>
<li>在二元分组密码中，可对数据重复执行某个置换再对这一置换作用以一个函数，便可获得扩散</li>
<li>目的是使<strong>明文和密文</strong>之间的统计关系变得复杂</li>
</ul>
<p><strong>混淆</strong></p>
<ul>
<li>目的是使<strong>密文和密文</strong>之间的统计关系变得复杂</li>
<li>复杂的代换函数效果比较理想</li>
</ul>
<h3 id="3-2-Feistel密码结构"><a href="#3-2-Feistel密码结构" class="headerlink" title="3.2 Feistel密码结构"></a>3.2 <span id="Feistel密码结构">Feistel密码结构</span></h3><p>很多的分组密码结构本质上基于 Feistel 网络结构。</p>
<p>Feistel 密码结构提出利用<strong>乘积密码</strong>可获得简单的代换密码，乘积密码简单地说Feistel结构就是顺序地执行两个或多个基本密码系统，使最后结果的密码强度高于每个密码系统的结果</p>
<p>轮函数将中间状态的部分比特不加改变的简单放置到其他位置</p>
<h4 id="Feistel加密结构："><a href="#Feistel加密结构：" class="headerlink" title="Feistel加密结构："></a>Feistel加密结构：</h4><p>假设加密过程的输入为分组长 2w 的明文和一个密钥 K ( K 在运算过程中将分成多个子密钥 Ki），将明文分为两部分，左边记为L0，右边记为R0，这两半数据经过n轮迭代后组合成密文分组。以下是加密过程图：</p>
<p><img src="../../%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6/%E5%AF%86%E7%A0%81%E5%AD%A6//images/1734617-20190905221130355-774380186.jpg" alt="img"></p>
<p>第一轮：R0与子密钥k0进行运算，记为F（R0，k0），得到的结果与L0进行异或运算。</p>
<p>​                最终得到的结果将作为第二轮运算的右半部分记为R1，而R0直接作为第二轮的左半部分记为L1。</p>
<p>第二轮：L1和F(R1，K1)（R1和K1运算的结果）进行异或运算，产生的结果为第三轮的R2，R1直接变为L2</p>
<p>第三轮以后一次类推，n轮迭代之后，左右两边再合并到一起为最后的密文分组</p>
<p>每轮的置换可以由以下函数表示：</p>
<p>$L_i = R_{i-1}$</p>
<p>$R_i = L_{i-1}⊕F(R_{i-1},K_i)$</p>
<h4 id="与Feistel有关的参数："><a href="#与Feistel有关的参数：" class="headerlink" title="与Feistel有关的参数："></a>与Feistel有关的参数：</h4><p>1、分组大小。分组越多安全性越高，加密速度越慢，分组密码中普遍使用的分组大小为64bit。</p>
<p>2、密钥大小。密钥越长安全性越高，加密速度越慢，一般使用128bit的密钥或者更长。</p>
<p>3、轮数。轮数越多安全性越高，一般为16轮。</p>
<p>4、子密钥产生算法。该算法越复杂安全性越高。</p>
<p>5、轮函数。轮函数越复杂安全性越高。</p>
<h4 id="Feistel解密结构："><a href="#Feistel解密结构：" class="headerlink" title="Feistel解密结构："></a>Feistel解密结构：</h4><p>​        本质上与加密过程一样，就是把加密过程反过来</p>
<h3 id="3-3-SP网络"><a href="#3-3-SP网络" class="headerlink" title="3.3 SP网络"></a>3.3 <span id="SP网络">SP网络</span></h3><p>Shannon 1949文章中介绍的<strong>替代-置换网络的思想</strong>即SP网络</p>
<ul>
<li>形成了现代密码的基础</li>
<li>是替代-置换乘积密码的现代形式</li>
</ul>
<p>不想写了，这节看ppt吧，感觉ppt说的乱七八糟，书上没有，老师也不讲，总结不出啥</p>
<h3 id="3-4-DES（数据加密标准）"><a href="#3-4-DES（数据加密标准）" class="headerlink" title="3.4 DES（数据加密标准）"></a>3.4 <span id="DES">DES（数据加密标准）</span></h3><p>DES全称为Data Encryption Standard，即数据加密标准，是一种使用<a href="https://baike.baidu.com/item/%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86/5928903" target="_blank" rel="noopener">密钥加密</a>的块算法，1977年被<a href="https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD%E8%81%94%E9%82%A6%E6%94%BF%E5%BA%9C/8370227" target="_blank" rel="noopener">美国联邦政府</a>的国家标准局确定为<a href="https://baike.baidu.com/item/%E8%81%94%E9%82%A6%E8%B5%84%E6%96%99%E5%A4%84%E7%90%86%E6%A0%87%E5%87%86/3940777" target="_blank" rel="noopener">联邦资料处理标准</a>（FIPS），并授权在非密级政府通信中使用，随后该算法在国际上广泛流传开来。</p>
<p><a href="https://www.cnblogs.com/lixiaoxu/articles/7736917.html" target="_blank" rel="noopener">https://www.cnblogs.com/lixiaoxu/articles/7736917.html</a></p>
<h4 id="3-4-1-DES算法简介"><a href="#3-4-1-DES算法简介" class="headerlink" title="3.4.1 DES算法简介"></a>3.4.1 DES算法简介</h4><p>DES算法是迭代型的分组密码算法</p>
<ul>
<li>分组长度 64bit</li>
<li>密钥长度 64bit</li>
<li>有效密钥长度 56bit（其余的8bit为奇偶校验）</li>
<li>迭代轮数 16</li>
<li>轮密钥长度 48bit</li>
<li>处理长度不足 64 bit 的明文 在尾部加0，凑成64位的整数倍</li>
</ul>
<p><img src="../../%E7%A8%8B%E5%BA%8F/QQ/QQ%E6%96%87%E4%BB%B6/724513626/FileRecv/MobileFile/IMG_0971(20200317-162619).PNG" alt="IMG_0971(/images/IMG_0971(20200317-162619).PNG)"></p>
<p><img src="/images/1584433646047.png" alt="DES.png"></p>
<p><img src="/images/1583730510997.png" alt="1583730510997"></p>
<p>上图是DES加密算法的框图，其中明文分组长64位比特，密钥长为64比特，有效密钥长为56比特。</p>
<p><strong>图的左边</strong>是明文的处理过程，有三个阶段</p>
<ul>
<li>首先是一个初始置换IP，用于重排明文分组的64位比特数据</li>
<li>然后是具有相同功能的16轮变换，每轮中都有置换和代换运算，第16论变换的输出分为左右两半，并被交换次序</li>
<li>最后再经过一个逆初始置换 $IP^{-1}$ ，从而产生64比特的密文</li>
</ul>
<p>除初始置换和逆初始置换外，DES的结构和Feistel密码结构完全相同</p>
<p><strong>图的右边</strong>是使用56比特密钥的方法。</p>
<ul>
<li>密钥首先通过一个置换函数</li>
<li>然后，对加密过程的每一轮，通过一个左循环移位和一个置换产生一个子密钥<ul>
<li>其中的每轮置换都相同，但由于密钥被重复迭代，所以产生的每轮子密钥不相同</li>
</ul>
</li>
</ul>
<h5 id="1-初始置换与逆初始置换"><a href="#1-初始置换与逆初始置换" class="headerlink" title="1. 初始置换与逆初始置换"></a>1. 初始置换与逆初始置换</h5><p>初始置换是将64 bit明文的位置进行置换，得到一个乱序的64 bit明文组。</p>
<p>逆初始置换将16轮迭代后给出的64 bit组进行置换，得到输出的密文组。输出为阵中元素按行读得的结果。 </p>
<p><strong>IP和IP-1在密码意义上作用不大，它们的作用在于打乱原来输入x的ASCII码字划分的关系</strong></p>
<p><img src="/images/1583733412870.png" alt="1583733412870"></p>
<p><img src="/images/1583733370502.png" alt="1583733370502"></p>
<p>下面是64bit 的输入M</p>
<p><img src="/images/1583733385862.png" alt="1583733385862"></p>
<p><img src="/images/1583733397812.png" alt="1583733397812"></p>
<h5 id="2-轮函数的结构"><a href="#2-轮函数的结构" class="headerlink" title="2. 轮函数的结构"></a>2. 轮函数的结构</h5><p><img src="/images/1583733496899.png" alt="1583733496899"></p>
<p>上图是DES加密算法中的轮结构</p>
<p>首先看图的左半部分</p>
<p>将64bit的输入分为各为32bit的左，右两部分，分别记为L和R。和Feistel网络一样，每轮变换可由一下公式表示：<img src="/images/1583733697432.png" alt="1583733697432"></p>
<p>其中<strong>轮密码 $K_i$ 为48bit</strong>，上式中函数 $F(R,K)$ 的计算如下图所示：<img src="/images/1583733783581.png" alt="1583733783581"></p>
<p>轮输入的右半部分R为32bit，R首先被扩展成48bit，扩展过程由表3-2(c)定义，其中将R的16个bit各重复一次。扩展后的48bit在于子密钥 $K_i$ 异或，然后再通过一个S盒，产生32bit的输出。该输出再经由一个由表3-2(d)定义的置换，产生的结构即为函数 $F(R,K)​$ 的输出</p>
<p>F中的代换由8个S盒组成，每个S盒的输入长为6bit，输出长为4bit，其变换关系如下表，每个S盒给出了4个代换<br><img src="/images/1583734183000.png" alt="1583734183000"><br><img src="/images/1583734247049.png" alt="1583734247049"></p>
<p>对每个盒 $S_i​$，其6bit输入中，第1个和第6个比特形成一个2位二进制数，用来选择 $S_i​$ 的4个代换中的一个</p>
<p><img src="/images/1583734473507.png" alt="1583734473507"></p>
<h5 id="3-密钥的产生"><a href="#3-密钥的产生" class="headerlink" title="3. 密钥的产生"></a>3. 密钥的产生</h5><p>在图3-5和3-6中，输入算法的56bit密钥手下经过一个置换运算，该置换由表3-4(a)指出，然后降至换后的56bit分为28bit的左、右两半，分别记为$C_0$ 和 $D_0$。在第i轮分别对 $C_{i-1} 和 D_{i-1}$进行左循环移位，所移位数由表3-4(c)给出。移位后的结果作为下一轮求子密钥的输入，同时也作为置换选择2的输入、通过置换选择2产生的48bit的 $K_i$，即为本轮的子密钥，作为函数 $F(R_{i-1},K_i)$ 的输入。其中置换选择2由下表定义</p>
<p><img src="/images/1583736565677.png" alt="1583736565677"></p>
<p><strong>p盒置换</strong></p>
<p>将S-盒变换后的32比特数据再进行P盒置换，置换后得到的32比特即为 F 函数的输出</p>
<p>基本特点： </p>
<ul>
<li>P盒的各输出块的4个比特都来自不同的输入块</li>
<li>P盒的各输入块的4个比特都分配到不同的输出块之中</li>
<li>P盒的第t输出块的4个比特都不来自第t输入块</li>
<li>P盒输出的第1个元是输入的第16个元</li>
</ul>
<img src="/images/1583742373155.png" width=40%>



<h5 id="4-解密"><a href="#4-解密" class="headerlink" title="4. 解密"></a>4. 解密</h5><p>和Feistel密码一样，DES的解密和加密使用同一算法，但子密钥使用的顺序相反</p>
<h4 id="3-4-2-二重DES"><a href="#3-4-2-二重DES" class="headerlink" title="3.4.2 二重DES"></a>3.4.2 二重DES</h4><p>总结：</p>
<ul>
<li>目的是抵抗穷举搜索攻击，期望密钥长度扩展为112bit</li>
<li>容易受到中间相遇攻击（下图最后部分有提及），这一攻击法所需的存储量为$2^{56}\times8Byte$ ，最大实验的加密次数为 $2\times 2^{56} = 2^{57}$</li>
</ul>
<p>二重DES是多重使用DES时最简单的形式，如下图所示<br><img src="/images/1583739290342.png" alt="1583739290342"><br><img src="/images/1583739326821.png" alt="1583739326821"><br><img src="/images/1583739359679.png" alt="1583739359679"><br><img src="/images/1583739376196.png" alt="1583739376196"></p>
<h4 id="3-4-3-两个密钥的三重DES（EDE）"><a href="#3-4-3-两个密钥的三重DES（EDE）" class="headerlink" title="3.4.3 两个密钥的三重DES（EDE）"></a>3.4.3 两个密钥的三重DES（EDE）</h4><p>破解的穷举搜索量为 $2^P{112} \approx 5\times10^{35}$ 量级</p>
<p>差分分析破解也要超过 $10^{52}$ 量级</p>
<p><img src="/images/1583739423807.png" alt="1583739423807"></p>
<h4 id="3-4-4-3个密钥的三重DES"><a href="#3-4-4-3个密钥的三重DES" class="headerlink" title="3.4.4 3个密钥的三重DES"></a>3.4.4 3个密钥的三重DES</h4><p><img src="/images/1583739452203.png" alt="1583739452203"><br><img src="/images/1583739463734.png" alt="1583739463734"></p>
<h4 id="DES的安全性"><a href="#DES的安全性" class="headerlink" title="DES的安全性"></a>DES的安全性</h4><p><strong>关于DES密钥</strong></p>
<p><strong>互补性：</strong>若明文组x逐位取补，密钥k逐位取补，有 $y=DES_k(x)$，则有 $\bar{y}=DES_{\bar{K}(\bar{x})}$，这会导致DES在选择明文破译时所需的工作量减半</p>
<p><strong>弱密钥和半弱密钥</strong></p>
<p><img src="/images/1583753442892.png" alt="1583753442892"></p>
<p>DES算法在每次迭代是都有一个子密钥供加密用。如果给定初始密钥k，各轮的子密钥都相同，就称给定密钥k为<strong>弱密钥</strong></p>
<p><strong>DES密钥长度的争议</strong></p>
<h3 id="3-5-分组密码的工作模式-以DES为例"><a href="#3-5-分组密码的工作模式-以DES为例" class="headerlink" title="3.5 分组密码的工作模式(以DES为例)"></a>3.5 <span id="分组密码的工作模式">分组密码的工作模式</span>(以DES为例)</h3><p>分组密码在加密时明文分组的长度是固定的，而使用中待加密的数据量是不定的，数据格式可能是多种多样的，为了能在各种场合使用DES，美国在 FIPS PUS 74 和 81 中定义了DES的四种运行模式，如下表所示<br><img src="/images/1583754343824.png" alt="1583754343824"></p>
<h4 id="比较和选用"><a href="#比较和选用" class="headerlink" title="比较和选用"></a>比较和选用</h4><p>ECB模式简单、高速，但最弱，易受重放和替换攻击，一般用于加密长度小于等于分组长度的消息</p>
<p>CBC，CFB，OFB模式的选用取决于实际的特殊需求。 </p>
<ol>
<li><p>明文不易丢信号，对明文的格式没有特殊要求的环境可选用CBC模式。需要完整性认证功能时也可选用该模式。 </p>
</li>
<li><p>容易丢信号的环境，或对明文格式有特殊要求的环境，可选用CFB模式。 </p>
</li>
<li><p>不易丢信号，但信号特别容易错，且明文冗余特别多，可选用OFB模式</p>
</li>
</ol>
<h4 id="3-5-1-电话本模式-ECB"><a href="#3-5-1-电话本模式-ECB" class="headerlink" title="3.5.1 电话本模式 ECB"></a>3.5.1 电话本模式 ECB</h4><p>这是最简单的运行模式，它一次对一个64bit长的明文<strong>块</strong>分组加密，而且每次加密的密钥都相同，如下图所示<br><img src="/images/1583754569542.png" alt="1583754569542"></p>
<p>当密钥取定时，对明文的每一个分组，都有一个唯一的密文与之对应，因此可以形象的认为有一个非常大的电码本</p>
<p><strong>优点：</strong></p>
<ul>
<li>实现简单</li>
<li>不同明文分组的加密可并行实施，尤其是硬件实现时速度很快 </li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>相同明文分组对应相同密文分组</strong> </li>
<li>一旦一个块被破解整体的安全性就遭到彻底破坏</li>
<li>不能隐蔽明文分组的统计规律和结构规律,不能抵抗替换攻击 </li>
</ul>
<p><strong>应用：</strong> </p>
<ul>
<li>用于随机数的加密保护 </li>
<li>用于单分组明文的加密</li>
</ul>
<h4 id="3-5-2-密码分组链接模式-CBC"><a href="#3-5-2-密码分组链接模式-CBC" class="headerlink" title="3.5.2 密码分组链接模式 CBC"></a>3.5.2 密码分组链接模式 CBC</h4><p>为了解决ECB的安全缺陷，可以让重复的明文分组产生不同的密文分组，密码分组链接模式 CBC 就可以满足这一要求，下图为示意图：<br><img src="/images/1583754997872.png" alt="1583754997872"></p>
<p>CBC(Cipher Block Chaining, 密码块链)模式</p>
<p>一次对一个明文分组进行加密，每次加密使用同一密钥，<strong>加密算法的输入是当前明文分组和前一次密文分组(第一个是初始化向量IV)的异或</strong>，这样每个密文块依赖该块之前的所有明文块，因此加密算法的输入不会显示出这次的明文分组之间的固定关系，所以重复的明文分组不会在密文中暴露出这种重复关系</p>
<p><strong>解密</strong>时，每一个密文分组被解密后，再与前一个密文分组异或<br><img src="/images/1584434260989.png" alt="1584434260989"></p>
<p><img src="/images/1583755263438.png" alt="1583755263438"></p>
<ul>
<li>明文块的统计特性得到了隐蔽</li>
<li>具有有限的(两步)错误传播特性<ul>
<li><strong>一个密文块的错误将导致两个密文块不能正确解密</strong></li>
</ul>
</li>
<li>具有自同步功能<ul>
<li>密文出现丢块和错块不影响后续密文块的解密</li>
<li>若从第t块起密文块正确，则第t+1个明文块就能正确求出</li>
</ul>
</li>
</ul>
<p><strong>利用CBC模式实现报文的完整性认证</strong></p>
<p>目的：检查文件在(直接或加密)传输和存储中是否遭到有意或无意的篡改</p>
<p>关键技术：</p>
<ol>
<li>文件的制造者和检验者共享一个密钥</li>
<li>文件的明文必须具有检验者预先知道的冗余度</li>
<li>文件的制造者用共享密钥对具有约定冗余度的明文用CBC模式加密</li>
<li>文件的检验者用共享密钥对密文解密，并检验约定冗余度是否正确</li>
</ol>
<p><strong>具体实现技术</strong></p>
<p><img src="/images/1584434835749.png" alt="1584434835749"></p>
<p>认证码生成</p>
<p><img src="/images/1584434850334.png" alt="1584434850334"></p>
<p>认证码校验</p>
<p><img src="/images/1584434862998.png" alt="1584434862998"></p>
<h4 id="3-5-3-密码反馈模式-CFB"><a href="#3-5-3-密码反馈模式-CFB" class="headerlink" title="3.5.3 密码反馈模式 CFB"></a>3.5.3 密码反馈模式 CFB</h4><p>CFB(Cipher Feedback, 密码反馈)模式和CBC模式比较相似，前一个分组的密文加密后和当前分组的明文XOR异或操作生成当前分组的密文。CFB模式的解密和CBC模式的加密在流程上其实是非常相似的。</p>
<p>如上所述，DES是分组长为64bit的分组密码，但利用CFB或OFB模式可将DES转换为流密码，流密码不需要对消息进行填充，而且运行是实时的。因此如果传送字母流，可使用流密码对每个字母直接加密并传送。</p>
<p>下图是CFB模式示意图，设传送的每一单元（如一个字符）是 j bit长，通常取 j=8，与CBC模式一样，明文单元被链接在一起，使得密文是前面所有明文的函数</p>
<p><img src="/images/1583755500426.png" alt="1583755500426"><br><img src="/images/1583755519949.png" alt="1583755519949"></p>
<p><img src="/images/1583755628150.png" alt="1583755628150"><br><img src="/images/1583755643555.png" alt="1583755643555"></p>
<p>若待加密消息需按字符、字节或比特处理时，可采用CFB模式，并称待加密消息按 r 比特处理的CFB模式为 r 比特CFB模式。 </p>
<p><strong>适用范围:</strong> </p>
<ul>
<li>适用于每次处理 r比特明文块的特定需求的加密情形,能灵活适应数据各格式的需要 </li>
<li>例如,数据库加密要求加密时不能改变明文的字节长度,这时就要以明文字节为单位进行加密</li>
</ul>
<p><strong>CFB模式的特点</strong></p>
<ul>
<li>相同明文：和按CBC模式加密一样，改变IV同样会导致相同的明文输入得到不同的加密输出。IV无需保密（虽在某些应用中IV须是不可预测的）</li>
<li>链接依赖性：类似CBC加密，链接机制致使密文组依赖于当前明文组和其前面的明文组；因此，重排密文组会影响解密</li>
<li>错误的传播：<strong>一个或多个比特错误出现在任一个r比特的密文组中会影响这个组和后继 $\lceil n/r \rceil$ 个密文组的解密</strong></li>
<li>错误恢复：CFB和CBC相似，也是自同步的，但它需有 $\lceil n/r \rceil​$ 个密文组才能还原</li>
</ul>
<h4 id="3-5-4-输出反馈模式-OFB"><a href="#3-5-4-输出反馈模式-OFB" class="headerlink" title="3.5.4 输出反馈模式 OFB"></a>3.5.4 输出反馈模式 OFB</h4><p>OFB(Output Feedback, 输出反馈)模式将分组密码转换为同步流密码，也就是说可以根据明文长度先独立生成相应长度的流密码。</p>
<p>通过流程图可以看出，OFB和CFB非常相似，<strong>CFB是将前一个密文分组反馈到移位寄存器，OFB是将加密算法的输出反馈到移位寄存器</strong>。由于异或操作的对称性，OFB模式的解密和加密完全一样的流程。</p>
<p><img src="/images/1583756068211.png" alt="1583756068211"><br><img src="/images/1583756078527.png" alt="1583756078527"></p>
<p><strong>OFB模式在结构上类似于CFB模式，但反馈的内容是DES的输出而不是密文</strong></p>
<p><strong>OFB工作模式的特点</strong></p>
<ul>
<li>相同明文：和CBC及CFB一样，改变IV同样会导致相同的明文输入得到不同的加密输出。 </li>
<li>链接依赖性：密钥流是独立于明文的。 </li>
<li>错误传播：有一个或多个比特错误的任一密文字符<strong>仅会影响该字符的解密</strong>，密文字符的某比特位置出错将致使还原明文的相应位置也出错。 </li>
<li>错误恢复：OFB模式能从密文比特错误中得以恢复，但在丢失密文比特后就无法实现自同步了，这是因为丢失密文比特会破坏密钥流的编排。</li>
</ul>
<h4 id="3-5-5-计数器模式"><a href="#3-5-5-计数器模式" class="headerlink" title="3.5.5 计数器模式"></a>3.5.5 计数器模式</h4><p>利用固定密钥k对自然数序列1,2,3,…,n, …加密，将得到的密文分组序列看作密钥流序列，按加法密码的方式与明文分组逐位异或的一种方式</p>
<p>利用这种方式可以产生<strong>伪随机数序列</strong>,其伪随机特性远比计算机产生的随机数的性质好</p>
<p><img src="/images/1583756753418.png" alt="1583756753418"></p>
<ul>
<li><p>效率 </p>
<ul>
<li>可并行加密 </li>
<li>预处理 </li>
<li>吞吐量仅受可使用并行数量的限制 </li>
</ul>
</li>
<li><p>加密数据块的随机访问 </p>
</li>
<li><p>可证明安全 </p>
</li>
<li><p>简单性（只要求实现加密算法）</p>
</li>
</ul>
<h3 id="3-7-AES算法—Rijndael"><a href="#3-7-AES算法—Rijndael" class="headerlink" title="3.7 AES算法—Rijndael"></a>3.7 AES算法—Rijndael</h3><p>DES算法由于其密钥较短，难以抵抗现有的攻击，因此不再作为加密标准 </p>
<p>1997年1月，美国NIST向全世界密码学界发出征集21世纪高级加密标准（AES——Advanced Encryption Standard）算法的公告，并成立了AES标准工作研究室，1997年4月15日的例会制定了对AES的评估标准</p>
<h4 id="1-有限域的基本概念"><a href="#1-有限域的基本概念" class="headerlink" title="1. 有限域的基本概念"></a>1. 有限域的基本概念</h4><p>有限域有时也称为伽罗瓦域，它指的是拥有有限个元素的集合。大致来讲， 伽罗瓦域是一个由有限个元素组成的集合，在这个集合内可以执行加、减、乘和逆操作。</p>
<p>F是一个非空集合，定义了加法、乘法两个二元运算，对这两个运算封闭</p>
<ul>
<li><p><strong>加法满足</strong>：对于任意a,b,c∈F </p>
<ul>
<li>a+b=b+a；交换律 </li>
<li>(a+b)+c=a+(b+c)；结合律 </li>
<li>存在0 ∈F，使得a+0=a；有零元 </li>
<li>存在-a ∈F，使得a+(-a)=0；有负元 </li>
</ul>
</li>
<li><p><strong>乘法满足</strong>：对于任意a,b,c∈F </p>
<ul>
<li>$a·b=b·a$；交换律 </li>
<li>$(a·b) ·c=a·(b·c)$；结合律 </li>
<li>存在e ∈F，使得 $a·e=a$；有单位元 </li>
<li>存在$a^{-1} ∈F$，使得 $a·a^{-1} =e$；有逆元 </li>
</ul>
</li>
<li><p><strong>乘法对加法满足分配律</strong> </p>
<ul>
<li>a·(b+c)=a·b+a·c</li>
</ul>
</li>
</ul>
<p><font color=red>例1</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Zn&#x3D;&#123;0,1,2,…，n-1&#125;modn，加法和乘法都是模n的运算，运算封闭 </span><br><span class="line"></span><br><span class="line">加法满足结合律和交换律，有零元0，有负元 </span><br><span class="line"></span><br><span class="line">乘法满足结合律和交换律，有单位元1，不一定有逆元 </span><br><span class="line"></span><br><span class="line">Zn中的数什么时候才有乘法逆元呢？ </span><br><span class="line"></span><br><span class="line">引理：整数a在模n乘法下有逆元，当且仅当a与n互素。 </span><br><span class="line"></span><br><span class="line">所有与n互素的元素在模n乘法下构成乘法交换群 </span><br><span class="line"></span><br><span class="line">1…n-1都与n互素，则n为素数 </span><br><span class="line"></span><br><span class="line">对于任一素数p，Zp为域，其元素个数为p个</span><br></pre></td></tr></table></figure>

<p><font color=red>例2</font></p>
<p><img src="../../%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6/%E5%AF%86%E7%A0%81%E5%AD%A6//images/1583996309522.png" alt="1583996309522"><br><img src="../../%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6/%E5%AF%86%E7%A0%81%E5%AD%A6//images/1583996320968.png" alt="1583996320968"></p>
<h4 id="2-GF-2-8-域"><a href="#2-GF-2-8-域" class="headerlink" title="2. $GF(2^8)$域"></a>2. $GF(2^8)$域</h4><p>$2^8=256$</p>
<p>有限域中的元素可以用多种不同的方式表示，对于任意素数的方幂，都有唯一的一个有限域，但由于不同的表示方法会影响复杂度的原因，本算法采用传统的<strong>多项式表示法</strong></p>
<p>AES加密标准算法中是以字节为处理单元，可以将每一字节看作是有限域 $GF(2^8)$ 上的一个元素，分别对应于一个次数不超过7的多项式。</p>
<p><strong>如$b_7b_6b_5b_4b_3b_2b_1b_0$可表示为多项式 $b_7x^7+b_6x^6+b_5x^5+b_4x^4+b_3x^3+b_2x^2+b_1x^1+b_0$</strong></p>
<p>例如十六进制数57对应的二进制位01010111，看成一个字节，对应的多项式为$x^6+x^4+x^2+x+1$</p>
<p><strong><font color=red>$GF(2^8)$中的运算</font></strong></p>
<p><strong>加法：</strong><img src="/images/1583997457570.png" alt="1583997457570"></p>
<p><strong>乘法：</strong><img src="/images/1583997495588.png" alt="1583997495588"></p>
<p><strong>逆元（广义欧几里得算法）：</strong><img src="/images/1583997630539.png" alt="1583997630539"></p>
<p><strong>x乘法：</strong><br><img src="/images/1583997694713.png" alt="1583997694713"><br><img src="/images/1583997711967.png" alt="1583997711967"><br><img src="/images/1583997732630.png" alt="1583997732630"></p>
<p><strong>$GF(2^8)$上的模多项式运算：</strong></p>
<p><strong>加法</strong></p>
<p>4个字节构成的向量可以表示为系数在 $GF(2^8)​$ 上的次数小于4的多项式</p>
<p>多项式的加法就是对应系数相加；换句话说，多项式的加法就是4字节向量的逐比特异或。 </p>
<p><strong>乘法</strong><br><img src="/images/1583999544190.png" alt="1583999544190"><br><img src="/images/1583999564280.png" alt="1583999564280"><br><img src="/images/1583999594476.png" alt="1583999594476"></p>
<p><img src="/images/1583999625007.png" alt="1583999625007"><br><img src="/images/1583999636519.png" alt="1583999636519"></p>
<h4 id="3-设计思想"><a href="#3-设计思想" class="headerlink" title="3. 设计思想"></a>3. 设计思想</h4><p>Rijndael 密码的设计力求满足一下三条标准：</p>
<ol>
<li>抵抗所有已知的攻击</li>
<li>在多个平台上速度快，编码紧凑</li>
<li>设计简单</li>
</ol>
<p>Rijndael没有采用Feistel结构，轮函数由3个不同的可逆均匀变换构成的，称为<strong>3个层</strong></p>
<ol>
<li>线性混合层：确保多轮之上的高度扩散</li>
<li>非线性层：将具有最有的“最坏形况非线性特性”的S盒并行使用</li>
<li>密钥加层：单轮子密钥简单的异或到中间状态上，实现一次性掩饰</li>
</ol>
<p>在第一轮之前，用了一个<strong>初始密钥加层</strong>，目的是在不知道密钥的情况下，对最后一个密钥加层以后的任一层（或者是进行已知明文攻击的时候，对第一个密钥加层以前的任一层）可简单的剥去，因此初始密码加层对密码的安全性无任何意义</p>
<h4 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h4><p><img src="/images/20141213142652421.png" alt="img"></p>
<h4 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h4><p>Rijndael 是一个迭代性分组密码，其分组长度和密钥长度都可变，各自可以独立的指定为128bit、192bit、256bit</p>
<h5 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h5><p>类似于明文分组和密文分组，算法中间的结果也需要分组，称之为状态，所有的操作都在状态上进行。</p>
<p>状态可以用以字节为元素的<strong>矩阵阵列</strong>表示，该阵列有4行，列数记为 $N_b$，$N_b$ 等于分组长度除以32</p>
<h5 id="种子密钥"><a href="#种子密钥" class="headerlink" title="种子密钥"></a>种子密钥</h5><p>密钥种子类似的用一个以字节为元素的<strong>矩阵阵列</strong>表示，该阵列为4行，列数记为 $N_k$，$N_k$等于密钥长度除以32</p>
<p><strong>例：</strong><br><img src="/images/1584002130232.png" alt="1584002130232"></p>
<h5 id="轮数"><a href="#轮数" class="headerlink" title="轮数"></a>轮数</h5><p>迭代的轮数记为 $N_r​$，$N_r​$ 与 $N_b​$ 和 $N_k​$ 有关，关系如下表：<br><img src="/images/1584002141290.png" alt="1584002141290"></p>
<h5 id="算法输入与输出"><a href="#算法输入与输出" class="headerlink" title="算法输入与输出"></a>算法输入与输出</h5><p>可看成由 8bit 字节构成的一维数组</p>
<p>下标范围为：</p>
<ul>
<li><p>输入输出：$0\sim (4N_b-1)$</p>
</li>
<li><p>密钥种子：$0\sim (4N_k-1)$</p>
</li>
</ul>
<p>放入和读出的顺序都是按照上面矩阵列表的列读取（从上到下，从左到右）</p>
<p>第 n 个元素对应在状态矩阵中的第(i, j)位置上的元素，关系如下：$i=n\ mod\ 4;\ \ j=\lfloor n/4\rfloor;\ \ n=i+4j$</p>
<h4 id="5-轮函数"><a href="#5-轮函数" class="headerlink" title="5. 轮函数"></a>5. 轮函数</h4><p>Rijndael 的轮函数由四个不同的计算部件组成，分别是字节代换，行移位，列混合，密钥加</p>
<h5 id="5-1-字节代换（ByteSub）"><a href="#5-1-字节代换（ByteSub）" class="headerlink" title="5.1 字节代换（ByteSub）"></a>5.1 字节代换（ByteSub）</h5><p>字节代换是非线性代换，独立的对状态的每个字节进行</p>
<p>代换表（S盒）是可逆的，记为 ByteSub(State) 由一下两个变换合成得到：</p>
<ol>
<li>首先，将字节看作 $GF(2^8)$ 上的元素，映射到自己乘法逆元，00 映射到自己</li>
<li>其次，对自己饿做如下的仿射变换： <img src="/images/1584003082770.png" width=50%>

</li>
</ol>
<img src="/images/1584003318547.png" width=80%>

<p><img src="/images/1584003851356.png" alt="S盒"></p>
<p>ByteSub 的逆变换由代换表的逆表做字节代换，可通过如下两步实现：首先进行仿射变换的逆变换，再求每一字节在 $GF(2^8)​$ 上的逆元</p>
<h5 id="5-2-行移位（shiftRow）"><a href="#5-2-行移位（shiftRow）" class="headerlink" title="5.2 行移位（shiftRow）"></a>5.2 行移位（shiftRow）</h5><p>行移位是将状态矩阵的各行进行循环移位，不同状态行的位移量不同。</p>
<ul>
<li>第0行：不动</li>
<li>第1行：循环左移C1字节</li>
<li>第2行：循环左移C2字节</li>
<li>第3行：循环左移C3字节</li>
</ul>
<p><img src="/images/1584003996349.png" alt="1584003996349"></p>
<p>记为：ShiftRow(State)</p>
<p>ShiftRow 的逆变换是对状态矩阵的后3列分别以位移量 $N_b-C_1, N_b-C_2,N_b-C_3$ 进行循环移位</p>
<h5 id="5-3-列混淆（MixColumn）"><a href="#5-3-列混淆（MixColumn）" class="headerlink" title="5.3 列混淆（MixColumn）"></a>5.3 列混淆（MixColumn）</h5><p>将每列视为 $GF(2^8)$ 上的多项式，与固定的多项式 $c(x)$ 进行模 $x^4+1$ 乘法，记为 $\otimes$，要求 $c(x)$模 $x^4+1$ 可逆，$c(x)=03x^3+01x^2+01x+02$，表示为MixColumn(State)，</p>
<p>列混淆运算也可写为矩阵乘法，设 $b(x)=c(x)\otimes a(x)​$，则<img src="/images/1584004422872.png" width=30%></p>
<p><img src="/images/1584004533603.png" alt="1584004533603"></p>
<p>逆运算：<img src="/images/1584004560053.png" alt="1584004560053"><br>或<img src="/images/1584004602160.png" width=50%></p>
<h5 id="5-4-轮密钥加（AddRoundKey）"><a href="#5-4-轮密钥加（AddRoundKey）" class="headerlink" title="5.4 轮密钥加（AddRoundKey）"></a>5.4 轮密钥加（AddRoundKey）</h5><p>轮密钥加是指：轮密钥与状态进行逐比特异或</p>
<p>轮密钥由种子密钥通过密钥编排算法得到，轮密钥长度与分组长度 $N_b​$ 相同</p>
<p>状态State与轮密钥RoundKey的密钥加运算表示为 AddRoundKey(State,RoundKey)</p>
<h4 id="6-AES的密钥编排"><a href="#6-AES的密钥编排" class="headerlink" title="6. AES的密钥编排"></a>6. AES的密钥编排</h4><p>密钥编排是指从种子密钥得到轮密钥的过程，它由密钥扩展和轮密钥选取两部分组成，其基本原理如下：</p>
<ol>
<li>轮密钥的比特数等于分组长度乘以（轮数加1）</li>
<li>种子密钥被扩展成扩展密钥</li>
<li>轮密钥从扩展密钥中取，其中第1轮轮密钥取扩展密钥的前 $N_b​$ 个字，第2轮轮密钥取接下来的 $N_b​$ 个字，如此下去</li>
</ol>
<p>1） 密钥扩展</p>
<p><img src="/images/1584336416593.png" alt="1584336416593"><br><img src="/images/1584336427034.png" alt="1584336427034"><br><img src="/images/1584336446256.png" alt="1584336446256"><br><img src="/images/1584336471991.png" alt="1584336471991"><br><img src="/images/1584336490433.png" alt="1584336490433"></p>
<p>2）轮密钥选取</p>
<p><img src="/images/1584336517885.png" alt="1584336517885"></p>
<h4 id="7-伪代码"><a href="#7-伪代码" class="headerlink" title="7. 伪代码"></a>7. 伪代码</h4><p>加密算法</p>
<p><img src="/images/1584336573568.png" alt="1584336573568"><br><img src="/images/1584336589162.png" alt="1584336589162"></p>
<p>加解密相近程度及解密算法</p>
<p><img src="/images/1584336639692.png" alt="1584336639692"></p>
<p><img src="/images/1584336652292.png" alt="1584336652292"></p>
<p><img src="/images/1584336684134.png" alt="1584336684134">)<img src="/images/1584336698191.png" alt="1584336698191"></p>
<p><img src="/images/1584336726419.png" alt="1584336726419">)<img src="/images/1584336740848.png" alt="1584336740848"></p>
<h3 id="3-8-中国商用密码算法-SM4"><a href="#3-8-中国商用密码算法-SM4" class="headerlink" title="3.8 中国商用密码算法 SM4"></a>3.8 中国商用密码算法 SM4</h3><p>SM4 算法是用于 WAPI 的分组密码算法，是2006年我国国家密码管理局公布的第一个商用密码算法</p>
<p>SM4 算法是分组密码算法，其中数据分组长度为128bit，密钥分组长度也为128bit。<br>加密算法与密钥扩展算法都采用32轮迭代结构，以字节（8bit）和字（32bit）为单位进行数据处理</p>
<h4 id="3-8-1-基本运算"><a href="#3-8-1-基本运算" class="headerlink" title="3.8.1 基本运算"></a>3.8.1 基本运算</h4><img src="/images/1584338029770.png" width=80%>

<h4 id="3-8-2-基本密码部件"><a href="#3-8-2-基本密码部件" class="headerlink" title="3.8.2 基本密码部件"></a>3.8.2 基本密码部件</h4><h5 id="S盒"><a href="#S盒" class="headerlink" title="S盒"></a>S盒</h5><p><img src="/images/1584338133616.png" alt="1584338133616"></p>
<p><img src="/images/1584338179646.png" alt="1584338179646"></p>
<h5 id="非线性变换-tau"><a href="#非线性变换-tau" class="headerlink" title="非线性变换 $\tau$"></a>非线性变换 $\tau$</h5><p><img src="/images/1584338257822.png" alt="1584338257822"></p>
<h5 id="线性变换部件-L"><a href="#线性变换部件-L" class="headerlink" title="线性变换部件 L"></a>线性变换部件 L</h5><p><img src="/images/1584338283467.png" alt="1584338283467"><br><img src="/images/1584338291223.png" alt="1584338291223"></p>
<h5 id="合成变换-T"><a href="#合成变换-T" class="headerlink" title="合成变换 T"></a>合成变换 T</h5><p><img src="/images/1584338312895.png" alt="1584338312895"></p>
<h4 id="3-8-3-轮函数"><a href="#3-8-3-轮函数" class="headerlink" title="3.8.3 轮函数"></a>3.8.3 轮函数</h4><p><img src="/images/1584338364951.png" alt="1584338364951">)<img src="/images/1584338380290.png" alt="1584338380290"></p>
<h4 id="3-8-4-加密算法"><a href="#3-8-4-加密算法" class="headerlink" title="3.8.4 加密算法"></a>3.8.4 加密算法</h4><p><img src="/images/1584338415196.png" alt="1584338415196"></p>
<h4 id="3-8-5-解密算法"><a href="#3-8-5-解密算法" class="headerlink" title="3.8.5 解密算法"></a>3.8.5 解密算法</h4><p><img src="/images/1584338437049.png" alt="1584338437049"><br><img src="/images/1584338449164.png" alt="1584338449164"></p>
<h4 id="3-8-6-密钥扩展算法"><a href="#3-8-6-密钥扩展算法" class="headerlink" title="3.8.6 密钥扩展算法"></a>3.8.6 密钥扩展算法</h4><p><img src="/images/1584338504675.png" alt="1584338504675"><br><img src="/images/1584338530642.png" alt="1584338530642"></p>
<h3 id="IDEA（国际数据加密算法）-算法"><a href="#IDEA（国际数据加密算法）-算法" class="headerlink" title="IDEA（国际数据加密算法） 算法"></a>IDEA（国际数据加密算法） 算法</h3><h4 id="设计原理"><a href="#设计原理" class="headerlink" title="设计原理"></a>设计原理</h4><ul>
<li>分组长度：64bit</li>
<li>密钥长度：128bit</li>
<li>迭代轮数：8轮 + 输出变换（出口处理变换）</li>
<li>轮子密钥：16bit为一个密钥块<ul>
<li>每轮6个密钥块，输出变换有4个</li>
<li>共有52个密钥块</li>
</ul>
</li>
<li>特点<ul>
<li>加密算法与解密算法相同，只是子密钥的使用顺序按一定方式倒序</li>
<li>不再是Feistel模型，而是共处理模型（Lai-Massey模型）</li>
</ul>
</li>
</ul>
<p><strong>算法的密码强度主要通过有效的混淆和扩散特性而得以保证</strong></p>
<p><strong>混淆</strong>是通过使用以下3种运算而获得，3种运算都有两个16bit的输入和一个16bit的输出</p>
<p><img src="/images/1584344193184.png" alt="1584344193184"></p>
<p><img src="/images/1584344293280.png" alt="1584344293280"></p>
<p><img src="/images/1584344236670.png" alt="1584344236670"><br><img src="/images/1584344253644.png" alt="1584344253644"></p>
<p><img src="/images/1584344321097.png" alt="1584344321097"></p>
<p><strong>扩散</strong></p>
<p>扩散是有MA结构（乘加）的基本单元实现的。该结构的输入是链两个16bit的字段和两个16bit的子密钥，输出也为两个16bit的子段</p>
<p>这一结构在算法中重复出现了8次，获得了非常有效的扩散效果</p>
<img src="/images/1584344462314.png" width=30%>

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><img src="/images/1584344532153.png" width=70%>

<h4 id="加解密过程"><a href="#加解密过程" class="headerlink" title="加解密过程"></a>加解密过程</h4><p>加密过程有连续的8轮迭代和一个输出变换组成，算法将64bit的明文分组分成4个16bit的子段，每轮迭代以4个16bit的子段作为输入，输出也为4个16bit的子段。最后的输出变换也产生4个16bit的子段，链接起来后形成64bit的密文分组。每轮迭代还需要6个16bit的子密钥，最后的输出变换需要输出变换需要4个16位子密钥，总数为52</p>
<p>在每一轮中，执行的顺序如下：</p>
<ol>
<li><p>X1和第一个子密钥相乘。</p>
</li>
<li><p>x2和第二个子密钥相加。</p>
</li>
<li><p>X3和第三个子密钥相加。</p>
</li>
<li><p>x4和第四个子密钥相乘。</p>
</li>
<li><p>将第(1)步和第(3)步的结果相异或。 .</p>
</li>
<li><p>将第(2)步和第(4)步的结果相异或。</p>
</li>
<li><p>将第(5)步的结果与第五个子密钥相乘。</p>
</li>
<li><p>将第(6)步和第(7)步的结果相加。</p>
</li>
<li><p>将第(8)步的结果与第六个子密钥相乘。</p>
</li>
<li><p>将第(7)步和第(9)步的结果相加。</p>
</li>
<li><p>将第(1)步和第(9)步的结果相异或。</p>
</li>
<li><p>将第(3)步和第(9)步的结果相异或。</p>
</li>
<li><p>将第(2)步和第(10)步的结果相异或。</p>
</li>
<li><p>将第(4)步和第(10)步的结果相异或。</p>
</li>
</ol>
<p>每一轮的输出是第(11)、(12)、(13)和(14) 步的结果形成的4个子分组。</p>
<p><strong>将中间两个分组分组交换(最后一轮除外)</strong>后，即为下一轮的输入。</p>
<p>经过8轮运算之后，有一个最终的输出变换：</p>
<ol>
<li><p>X1和第一个子密钥相乘。</p>
</li>
<li><p>x2和第二个子密钥相加。</p>
</li>
<li><p>x3和第三个子密钥相加。</p>
</li>
<li><p>x4和第四个子密钥相乘。</p>
</li>
</ol>
<p>最后，这4个子分组重新连接到一起产生密文。</p>
<h5 id="1-轮结构"><a href="#1-轮结构" class="headerlink" title="1. 轮结构"></a>1. 轮结构</h5><img src="/images/1584344918101.png" width=50%>

<img src="/images/1584344928965.png" width=50%>

<p><img src="/images/1584344998771.png" alt="1584344998771"></p>
<p><strong>加解密子密钥表</strong></p>
<p><img src="/images/1584345015658.png" alt="1584345015658"></p>
<p><strong>加密过程图</strong></p>
<p><img src="/images/1584344597019.png" alt="1584344597019"></p>
<p><strong>解密过程图</strong></p>
<p><img src="/images/1584345076028.png" alt="1584345076028"></p>
<h4 id="子密钥生成算法"><a href="#子密钥生成算法" class="headerlink" title="子密钥生成算法"></a>子密钥生成算法</h4><p>算法用了52个子密钥(8轮中的每一轮需要6个，其他4个用与输出变换)。</p>
<p>首先，将128-位密钥分成8个16-位子密钥。这些是算法的第一批8个子密钥（第一轮六个，第二轮的头两个）。然后，密钥向左环移x位后再分成8个子密钥。开始4个用在第二轮，后面4个用在第三轮。密钥再次向左环移25位产生另外8个子密钥，如此进行直到算法结束。</p>
<p>具体是：</p>
<blockquote>
<p>IDEA总共进行8轮迭代操作，每轮需要6个子密钥，另外还需要4个额外子密钥,所以总共需要52个子密钥，这个52个子密钥都是从128位密钥中扩展出来的。</p>
<p>首先把输入的Key分成8个16位的子密钥，1-6号子密钥供第一轮加密使用，7-8号子密钥供第二轮使用，然后把这个128位密钥循环左移25位，这样$Key = k_{26}k_{27}k_{28}k_{24}k_{25}​$</p>
<p>把新生成的Key在分成8个16位的子密钥，1-4号子密钥供第二轮加密使用(前面已经提供了两个)，5-8号子密钥供第三轮加密使用。到此我们已经得到了16个子密钥，如此继续,当循环左移了5次之后已经生成了48个子密钥,还有四个额外的子密钥需要生成，再次把Key循环左移25位,选取划分出来的8个16位子密钥的前4个作为那4个额外的加密密钥.供加密使用的52个子密钥生成完毕。</p>
<p>输入的64位数据分组被分成4个16-位子分组：x1，X2，x3和x4。这4个子分组成为算法的第一轮的输入，总共有8轮。在每一轮中，这4个子分组相互相异或，相加，相乘，且与6个16位子密钥相异或，相加，相乘。在轮与轮间，第二和第三个子分组交换。最后在输出变换中4个子分组与4个子密钥进行运算。</p>
</blockquote>
<h4 id="设计特点"><a href="#设计特点" class="headerlink" title="设计特点"></a>设计特点</h4><ul>
<li>所有运算都面向16位子块进行，因此对于16位处理器特别有效</li>
<li>全部使用计算机指令</li>
<li>没有比特运算</li>
<li>利用三种不同的群运算实现混乱和扩散</li>
</ul>
<p>这个设计思想丰富了混乱和扩散的实现技术，它和尽量使用计算机固有指令的设计思想是对编码理论的两大贡献</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/">&lt;i class&#x3D;&quot;fa fa-angle-left&quot;&gt;&lt;&#x2F;i&gt;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tiantian</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tiantian</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
