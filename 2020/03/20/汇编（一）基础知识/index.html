<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="汇编," />










<meta name="description" content="汇编语言基础知识1.1数的表示数制二进制  Binary八进制  Octal十进制  Decimal十六进制  Hexadecimal  数制之间的转换 常用数 0—00H  128—80H  255—FFH  256—100H  32767—7FFFH  65535—FFFFH 二进制运算算数运算  逻辑运算  与 或 非 异或 ……  计算机中数的表示二进制  无符号数  直接用二进制表示">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编（一）基础知识">
<meta property="og:url" content="http://yoursite.com/2020/03/20/%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="天天的个人博客">
<meta property="og:description" content="汇编语言基础知识1.1数的表示数制二进制  Binary八进制  Octal十进制  Decimal十六进制  Hexadecimal  数制之间的转换 常用数 0—00H  128—80H  255—FFH  256—100H  32767—7FFFH  65535—FFFFH 二进制运算算数运算  逻辑运算  与 或 非 异或 ……  计算机中数的表示二进制  无符号数  直接用二进制表示">
<meta property="og:image" content="http://yoursite.com/images%5C1582598964262.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582599218562.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582599398784.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582605230251.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582600892171.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582601218816.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582601468185.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582602414805.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582605918976.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582602621563.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582603136049.png">
<meta property="og:image" content="f:%5C%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%5C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/images%5C1582603166324.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582606418693.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582870128658.png">
<meta property="og:image" content="http://yoursite.com/images/1583031408460.png">
<meta property="og:image" content="http://yoursite.com/images/1583031216603.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582871573536.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582871775533.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582871963366.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582872120205.png">
<meta property="og:image" content="http://yoursite.com/images/1583032445468.png">
<meta property="og:image" content="http://yoursite.com/images/1583032547356.png">
<meta property="og:image" content="http://yoursite.com/images/1582875665869.png">
<meta property="og:image" content="http://yoursite.com/images/1582875684106.png">
<meta property="og:image" content="http://yoursite.com/images/1583032955013.png">
<meta property="og:image" content="http://yoursite.com/images/1583033208984.png">
<meta property="og:image" content="http://yoursite.com/images%5C1582872562768.png">
<meta property="og:image" content="f:%5C%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/images%5C1582874817187.png">
<meta property="og:image" content="http://yoursite.com/images/1582875789444.png">
<meta property="og:image" content="http://yoursite.com/images/1583034422794.png">
<meta property="og:image" content="http://yoursite.com/images/1583034434323.png">
<meta property="og:image" content="http://yoursite.com/images/1583038683934.png">
<meta property="og:image" content="http://yoursite.com/images/1583038696339.png">
<meta property="og:image" content="http://yoursite.com/images/1583038867768.png">
<meta property="og:image" content="http://yoursite.com/images/1583038878276.png">
<meta property="og:image" content="http://yoursite.com/images/1583039157843.png">
<meta property="og:image" content="http://yoursite.com/images/1583567648014.png">
<meta property="og:image" content="http://yoursite.com/images/1583567711516.png">
<meta property="og:image" content="http://yoursite.com/images/1582876709710.png">
<meta property="og:image" content="http://yoursite.com/images/1583477644581.png">
<meta property="og:image" content="http://yoursite.com/images/1583210960302.png">
<meta property="og:image" content="http://yoursite.com/images/1583211794594.png">
<meta property="og:image" content="http://yoursite.com/2020/03/%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80//images/1583211803837.png">
<meta property="article:published_time" content="2020-03-20T08:30:09.000Z">
<meta property="article:modified_time" content="2020-03-20T08:35:20.591Z">
<meta property="article:author" content="tiantian">
<meta property="article:tag" content="汇编">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images%5C1582598964262.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/03/20/汇编（一）基础知识/"/>





  <title>汇编（一）基础知识 | 天天的个人博客</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">天天的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/20/%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tiantian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="天天的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">汇编（一）基础知识</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-20T16:30:09+08:00">
                2020-03-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%B1%87%E7%BC%96/" itemprop="url" rel="index">
                    <span itemprop="name">汇编</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/20/%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2020/03/20/汇编（一）基础知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><span id="目录"></span></p>
<h1 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h1><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="1-1数的表示"><a href="#1-1数的表示" class="headerlink" title="1.1数的表示"></a>1.1数的表示</h2><h3 id="数制"><a href="#数制" class="headerlink" title="数制"></a>数制</h3><p>二进制  Binary<br>八进制  Octal<br>十进制  Decimal<br>十六进制  Hexadecimal </p>
<h3 id="数制之间的转换"><a href="#数制之间的转换" class="headerlink" title="数制之间的转换"></a>数制之间的转换</h3><p><img src="/images%5C1582598964262.png" alt="1582598964262"></p>
<p>常用数</p>
<p>0—00H  128—80H  255—FFH  256—100H  32767—7FFFH  65535—FFFFH</p>
<h3 id="二进制运算"><a href="#二进制运算" class="headerlink" title="二进制运算"></a>二进制运算</h3><p><strong>算数运算</strong></p>
<p><img src="/images%5C1582599218562.png" alt="1582599218562"></p>
<p><strong>逻辑运算</strong></p>
<ul>
<li>与</li>
<li>或</li>
<li>非</li>
<li>异或</li>
<li>……</li>
</ul>
<h3 id="计算机中数的表示"><a href="#计算机中数的表示" class="headerlink" title="计算机中数的表示"></a>计算机中数的表示</h3><p>二进制</p>
<ul>
<li><p>无符号数</p>
<ul>
<li>直接用二进制表示</li>
</ul>
</li>
<li><p>有符号数</p>
<p><img src="/images%5C1582599398784.png" alt="1582599398784"></p>
</li>
<li><p>补码的补码就是原码</p>
</li>
<li><p>在计算机中，数据是以补码16进制存储在内存中的</p>
<ul>
<li><p>补码的运算</p>
<ul>
<li>$[N1+N2]_补=[N1]_补＋[N2]_补$</li>
<li>$[N1-N2]_补=[N1]_补＋[-N2]_补$</li>
<li><h5 id="N-补补-N"><a href="#N-补补-N" class="headerlink" title="$[N]_{补补}= [N]$"></a>$[N]_{补补}= [N]$</h5></li>
<li>补码的加、减运算都可以转换成加法运算，运算时符号位参加运算。</li>
<li>符号位进位丢弃，结果为负数再取补码。</li>
<li><img src="/images%5C1582605230251.png" alt="1582605230251"></li>
</ul>
</li>
<li><p>数的范围</p>
<ul>
<li>无符号数：8位(0–255） 16位（0–65535）</li>
<li>有符号数：8位（-128–127） 16位（-32768–32767）</li>
<li>n位补码表示数范围：  $- 2^{n-1} &lt;=  N &lt;=  2^{n-1}-1$</li>
</ul>
</li>
</ul>
</li>
<li><p>浮点数</p>
<ul>
<li>（尾数）规格化+（指数）移码</li>
<li>$a = m \times be$</li>
<li>符号位：尾数的符号，1为负，0为正；</li>
<li>尾数：即m规格化的值；</li>
<li>指数：即指数e的移码，即将其补码的符号位取反；</li>
<li>$(5.0)_{10}=(101.0)_2= (1.01\times 22)_2​$</li>
</ul>
</li>
</ul>
<h3 id="BCD码-Binary-Coded-Data"><a href="#BCD码-Binary-Coded-Data" class="headerlink" title="BCD码(Binary-Coded Data)"></a>BCD码(Binary-Coded Data)</h3><ul>
<li>Packed BCD：用4位二进制表示一个十进制数码<ul>
<li>0000—–0          0001—–1 </li>
<li>0001,0010,0011,0100  = 1234</li>
<li><img src="/images%5C1582600892171.png" alt="1582600892171"></li>
</ul>
</li>
<li>Unpacked BCD：用8位二进制表示一个十进制数码<ul>
<li>$00000000–0   00000001–1$</li>
<li>$00000001,00000010, 00000011, 00000100 = 1234$</li>
</ul>
</li>
</ul>
<h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3><ul>
<li>ASCII：英文，7 bits（128个代码）<ul>
<li>数字’0’～’9’：30H～39H</li>
<li>字母’A’～’Z’：41H～5AH</li>
<li>字母’a’～’z’：61H～7AH</li>
<li>空格：20H </li>
<li>回车CR：0DH——控制光标回到当前行的最左端</li>
<li>换行LF：0AH——移动光标到下一行，而所在列不变</li>
<li>空字符：0</li>
<li><img src="/images%5C1582601218816.png" alt="1582601218816"></li>
</ul>
</li>
<li>GB:国标码，是我国于1981年公布的国家标准，作为信息交换用汉字编码的字符(GB2312-80),包括6763个简体字以及其他字符。</li>
<li>GBK: GB的扩展，包括Unicode中的20902个汉字，也称汉字大字符集</li>
<li>BIG5:大五碼，包括13,060個繁體字，也是香港比較多人使用的標準。</li>
<li>UNICODE:  16位二进制 = 65536  汉字：20902个</li>
<li>UTF-8: 用4字节表示，232 = 42亿…</li>
</ul>
<h2 id="1-2-微型计算机（PC）系统"><a href="#1-2-微型计算机（PC）系统" class="headerlink" title="1.2 微型计算机（PC）系统"></a>1.2 微型计算机（PC）系统</h2><p>PC的硬件：主机、键盘、鼠标、显示器<br>主板的组成：CPU、存储器、外围芯片组、扩张插槽等<br>扩张插槽上有：RAM内存+接口卡</p>
<p><img src="/images%5C1582601468185.png" alt="1582601468185"></p>
<p>汇编语言程序员看到的硬件</p>
<ul>
<li>中央处理单元 CPU（Intel 80x86）<ul>
<li>对汇编语言程序员，最关心其中的寄存器组</li>
</ul>
</li>
<li>存储器（主存储器）<ul>
<li>呈现给汇编语言程序员的，是存储器地址</li>
</ul>
</li>
<li>外部设备（接口电路）<ul>
<li>汇编语言程序员看到的是端口（I/O地址）</li>
</ul>
</li>
</ul>
<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul>
<li><p>组成：</p>
<ul>
<li>算术逻辑部件、控制部件和<strong>寄存器组</strong></li>
</ul>
</li>
<li><p>CPU的作用： </p>
<ul>
<li>控制指令的执行。</li>
<li>执行算术与逻辑运算。</li>
</ul>
</li>
<li><p>对汇编语言程序员来说，CPU通过寄存器完成指令的取指和执行功能</p>
</li>
<li><p>CPU的内部总线实现CPU内部各个器件之间的联系。</p>
</li>
<li><p>外部总线（系统总线）实现CPU和主板上其它器件的联系</p>
</li>
</ul>
<h3 id="I-O-子系统"><a href="#I-O-子系统" class="headerlink" title="I/O 子系统"></a>I/O 子系统</h3><ul>
<li>通过接口电路与微机系统连接</li>
<li>I/O接口电路由若干接口寄存器组成，需要用编号区别各个寄存器：数据寄存器、状态寄存器、命令寄存器</li>
<li>I/O端口是I/O地址的通俗说法，是接口电路中寄存器的编号。<ul>
<li>汇编语言程序员看到的，是端口</li>
</ul>
</li>
<li>8086计算机采用16位表示I/O端口，系统通过这些端口与外设进行通信</li>
<li>Intel 8086支持64K个8位端口</li>
<li>I/O地址可以表示为：0000H ～ FFFFH</li>
</ul>
<h3 id="内存（存储器）"><a href="#内存（存储器）" class="headerlink" title="内存（存储器）"></a>内存（存储器）</h3><p>内存是存放<strong>指令</strong>和<strong>数据</strong>的部件，由若干内存单元构成。</p>
<p>指令和数据是应用上的概念，<strong>在内存中都是二进制数</strong>，没有区别</p>
<ul>
<li><p>存储器用以下单位来计量容量</p>
<ul>
<li>1个二进制位：bit（比特）</li>
<li>8个二进制位：Byte（字节） 1Byte=8bit   $D_7～D_0$</li>
<li>2个字节：Word（字）  1Word=2Byte=16bit  $D_{15}～D_0$</li>
<li>1个双字：DWord = 2 Word   $D_{31}～D_0$</li>
<li>$1KB= 2_{10}=1024B$      （Kilo） </li>
<li>$1MB=1024KB= 2^{20}$  （Mega） </li>
<li>$1GB=1024MB= 2^{30}$   （Giga）</li>
<li>$1TB=1024GB = 2^{40}$   （Tera）</li>
</ul>
</li>
<li><p>与内存储器相关概念：单元，地址，内容，字长</p>
<ul>
<li>把内存储器视为一个存放信息的大仓库，而一个大仓库又分成若干个小的存储间，每一个房间称为一个单元</li>
<li>为了区别这些单元，给每个单元编号，这个编号称为地址；</li>
<li>单元内部存放着信息称为单元的内容。</li>
<li>单元信息的长度成为字长。</li>
</ul>
</li>
<li><p>存储器被划分为若干个存储单元， 每个存储单元从0开始顺序编号；编号＝地址</p>
</li>
<li><p>数据的存储格式</p>
<ul>
<li>80x86的内存以<strong>字节</strong>编址：每个内存单元有唯一的地址，可存放1个字节</li>
<li>内存单元的2个要素：地址（编号）与值（内容）。<ul>
<li>如：（100H）=34H   或者  [0002H]＝34H</li>
<li>地址用<strong>无符号整数</strong>来表示（编程用十六进制表示）</li>
</ul>
</li>
<li>多字节数据在存储器中<strong>占连续的多个存储单元</strong>；<ul>
<li>低字节在低地址单元，高字节在高地址单元；</li>
<li><strong>字的地址由其低地址来表示</strong>。双字也类似。(小端方式)</li>
<li>同一地址可以看作是字节、字或双字单元的地址。</li>
</ul>
</li>
<li><img src="/images%5C1582602414805.png" alt="1582602414805"></li>
</ul>
</li>
<li><p>存储器芯片分类</p>
<ul>
<li>从读写属性上看分为两类：<ul>
<li>随机存储器（RAM）</li>
<li>只读存储器（ROM）</li>
</ul>
</li>
<li>从功能和连接上分类：<ul>
<li>随机存储器RAM</li>
<li>装有BIOS的ROM</li>
<li>接口卡上的RAM</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="系统总线"><a href="#系统总线" class="headerlink" title="系统总线"></a>系统总线</h3><p>总线是部件之间进行数据（电信号）交换的通道。</p>
<p><img src="/images%5C1582605918976.png" alt="1582605918976"></p>
<p>80x86计算机的系统总线分为3类：</p>
<ul>
<li>地址总线<ul>
<li>地址总线用来指出数据的地址（内存或I/O）。<ul>
<li><strong>CPU是通过地址总线来指定存储单元的</strong></li>
</ul>
</li>
<li>地址总线的位数决定了最大可编址的内存与I/O空间。<ul>
<li>对于N位地址总线，CPU可以提供$2^N$个不同地址：$0～2^N -1$。</li>
<li>也就是说地址总线的宽度决定了CPU的<strong>寻址能力</strong>；</li>
</ul>
</li>
<li>地址总线由内存与I/O子系统共享使用（I/O只用低16位）</li>
<li><img src="/images%5C1582602621563.png" alt="1582602630038"></li>
</ul>
</li>
<li>数据总线<ul>
<li>数据总线是用来<strong>传递数据</strong>的，定义了CPU在每个内存周期所能存取数据的<strong>位数</strong>。</li>
<li>80x86系列CPU的数据总线为8位、16位、32位或64位。这就是“为什么通常的数据存取是以8位、16位、32位或64位进行的”。</li>
<li>数据总线的宽度决定了CPU和外界的数据传送速度。数据总线越宽，处理能力越强。</li>
<li><strong>具有N位数据总线并不意味着CPU只能处理N位数据。</strong></li>
<li><img src="/images%5C1582603136049.png" alt="1582603136049"></li>
</ul>
</li>
<li>控制总线<ul>
<li>控制总线用来控制CPU与内存和I/O设备之间的<strong>数据传送方式</strong>（如传送方向）。</li>
<li>有多少根控制总线，就意味着CPU提供了对外部器件的<strong>多少种控制</strong>。</li>
<li>控制总线的宽度决定了CPU对<strong>外部器件</strong>的<strong>控制能力</strong>。</li>
<li><img src="F:%5C%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%5C%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/images%5C1582603166324.png" alt="1582603166324"></li>
</ul>
</li>
</ul>
<h3 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h3><p>读取数据</p>
<ul>
<li>地址线寻找要读取信息地址</li>
<li>控制线发出<code>读</code>的控制指令</li>
<li>数据线在指定地址读取数据</li>
</ul>
<p>写入数据</p>
<ul>
<li>地址线寻找要写入信息地址</li>
<li>控制线发出<code>写</code>的控制指令</li>
<li>数据线在指定地址写入数据</li>
</ul>
<h3 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h3><p>上述存储器在物理上是独立的器件。但以下两点相同：</p>
<ol>
<li>都和CPU的总线相连。</li>
<li>CPU对它们进行读或写的时候都通过控制线发出内存读写命令。</li>
</ol>
<p><strong>CPU操作这些存储器时把它们看作一个逻辑存储器：</strong></p>
<ul>
<li>所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器；</li>
<li>每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间；</li>
<li>CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据。</li>
<li>最终运行程序的是CPU，我们用汇编编程的时候，必须要从CPU角度考虑问题。<ul>
<li>对CPU来讲，系统中的所有存储器中的存储单元都处于一个统一的逻辑存储器中，它的容量受CPU寻址能力的限制。</li>
<li><strong>这个逻辑存储器即是我们所说的内存地址空间。</strong></li>
<li>一个CPU的地址线宽度为10，那么可以寻址1024个内存单元，这1024个可寻到的内存单元就构成这个CPU的内存地址空间。</li>
</ul>
</li>
</ul>
<p>不同计算机系统的内存地址空间分配情况是不同的</p>
<p><img src="/images%5C1582606418693.png" alt="1582606418693"></p>
<h2 id="1-3-Intel-80x86系列微处理器"><a href="#1-3-Intel-80x86系列微处理器" class="headerlink" title="1.3 Intel 80x86系列微处理器"></a>1.3 Intel 80x86系列微处理器</h2><p><img src="/images%5C1582870128658.png" alt="1582870128658"></p>
<ul>
<li><p>16位80x86处理器</p>
<ul>
<li>8086/8088指令系统提供16位基本指令集</li>
<li>80186/80188增加若干条实用指令 </li>
<li>8086的工作方式是<strong>实方式</strong>（Real Mode）</li>
<li>80286增加保护方式（Protected Mode）</li>
<li>80286引入了系统指令<ul>
<li>为操作系统等核心程序提供处理器控制功能</li>
</ul>
</li>
</ul>
</li>
<li><p>IA-32处理器（Intel Architecture-32）</p>
<ul>
<li>80386引入英特尔32位指令集结构ISA<ul>
<li>兼容原16位80286指令系统</li>
<li>全面升级为32位</li>
<li>提供虚拟8086工作方式（Virtual 8086 Mode）</li>
</ul>
</li>
<li>80486集成浮点处理单元支持浮点指令</li>
<li>Pentium系列<ul>
<li>陆续增加若干整数指令、完善浮点指令</li>
<li>增加一系列多媒体指令（SIMD指令）</li>
</ul>
</li>
</ul>
</li>
<li><p>Intel 64处理器</p>
<ul>
<li>引入64位英特尔指令集结构<ul>
<li>兼容32位指令系统</li>
<li>新增64位工作方式</li>
</ul>
</li>
<li>继续丰富多媒体指令</li>
<li>处理器集成多核（Multi-core）技术</li>
</ul>
</li>
</ul>
<h2 id="1-4-8086微处理器"><a href="#1-4-8086微处理器" class="headerlink" title="1.4 8086微处理器"></a>1.4 8086微处理器</h2><h3 id="1-4-1-内部结构"><a href="#1-4-1-内部结构" class="headerlink" title="1.4.1 内部结构"></a>1.4.1 内部结构</h3><p><img src="/images/1583031408460.png" alt="1583031408460"></p>
<ul>
<li>组成：<ul>
<li>算术逻辑部件、控制部件和<strong>寄存器组</strong></li>
</ul>
</li>
<li>CPU的作用：<ul>
<li>执行算术与逻辑运算</li>
<li>控制指令的执行</li>
</ul>
</li>
</ul>
<p>这些器件靠内部总线相连。内部总线实现CPU内部各个器件之间的联系。</p>
<p>外部总线（系统总线）实现CPU和主板上其它器件的联系。</p>
<ul>
<li>执行单元EU<ul>
<li><strong>左半部分</strong>为执行单元（EU），由算数逻辑单元（ALU）、数据寄存器、地址寄存器、标志寄存器和指令译码的EU控制逻辑等构成</li>
<li>负责指令的译码、执行和数据的运算</li>
</ul>
</li>
<li>总线接口单元BIU<ul>
<li><strong>右半部分</strong>为总线接口单元（BIU），由6字节的指令队列、指令指针（IP）、段寄存器（CS，DS，SS，ES）、地址加法器和总线控制逻辑等构成。</li>
<li>管理8086与外部总线的接口，负责CPU对存储器和外设进行访问。</li>
<li>8086所连接的总线由16位的双向数据线、20位地址线和若干控制线组成。</li>
</ul>
</li>
<li>对汇编语言程序员来说，CPU通过<strong>寄存器</strong>完成指令的<strong>取指（取指令）</strong>和<strong>执行</strong>功能。 <ul>
<li>取指是从主存储器中取出指令代码进入CPU。</li>
<li>执行是将指令代码翻译成它代表的功能（被称为译码），并发出有关控制信号实现这个功能。</li>
</ul>
</li>
</ul>
<h3 id="1-4-2-存储器组织"><a href="#1-4-2-存储器组织" class="headerlink" title="1.4.2 存储器组织"></a>1.4.2 存储器组织</h3><h4 id="1-数据的存储格式"><a href="#1-数据的存储格式" class="headerlink" title="1. 数据的存储格式"></a>1. 数据的存储格式</h4><p>基本单位为一个二进制位：bit</p>
<p>8个bit组成一个字节：Byte，位编号从右向左从0开始递增：$D_7 \sim D_0$</p>
<p>其中最低为称为最低有效位（LSB），最高位称为最高有效位（MSB）</p>
<p>存储器以字节位单位存储信息，为了正确存储，每个存储单元被赋予一个地址。地址编号从0开始，顺序加1，是一个无符号十六进制数。</p>
<p>存储单元中存放的信息为该存储单元的内容。如0002H地址的存储器中存放的信息为34H，即二单元的内容为34H，表示为 $\lbrack 0002H\rbrack =34H$</p>
<p>那么如何存放一个字或双字呢？</p>
<p>字或双字在存储器中占据2或4个存储单元：存放时，低字节存入低地址，高字节存入高地址</p>
<h4 id="2-存储器的分段管理"><a href="#2-存储器的分段管理" class="headerlink" title="2. 存储器的分段管理"></a>2. 存储器的分段管理</h4><p>16位结构描述了一个CPU具有以下特征：</p>
<ol>
<li>运算器一次最多可以处理16位的数据。</li>
<li>寄存器的最大宽度为16位。</li>
<li>寄存器和运算器之间的通路是16位的。</li>
</ol>
<p>8086有20位地址总线，可传送20位地址，寻址能力为1MB = $2^{20}B$，地址范围为00000H~FFFFFH</p>
<p>整个1MB主存空间从地位地址到高位地址可分为四个区段：（实方式主存）</p>
<p><img src="/images/1583031216603.png" alt="1583031216603"></p>
<p>8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K</p>
<h4 id="如何给出20位的物理地址-分段技术"><a href="#如何给出20位的物理地址-分段技术" class="headerlink" title="如何给出20位的物理地址: 分段技术"></a>如何给出20位的物理地址: 分段技术</h4><ul>
<li>地址加法器合成物理地址的方法：用两个16位地址合成一个20位的物理地址。</li>
</ul>
<p><img src="/images%5C1582871573536.png" alt="1582871573536"></p>
<p>默认200后面还有一个0 $\to​$ 段地址×16</p>
<p>将存储器分成若干个逻辑段段首地址必须为：$****0H​$。</p>
<p>其有效地址“$<strong>**H$”存放在</strong>段寄存器<strong>中，称为</strong>段地址**。</p>
<p>段中某一个单元相对于段首的距离称为<strong>偏移地址</strong>，偏移地址存放在<strong>偏移地址寄存器</strong>中。</p>
<p>段的长度不超过$2^{16}=64K$。</p>
<p><img src="/images%5C1582871775533.png" alt="1582871775533"></p>
<p>8086CPU给出物理地址的方法:</p>
<ul>
<li><p>ALU完成加法，地址加法器</p>
</li>
<li><p>段地址一般在程序开始时预定</p>
</li>
<li><p>访问某一个内存单元，程序中只需要给出16位偏移地址</p>
</li>
</ul>
<p><img src="/images%5C1582871963366.png" alt="1582871963366"></p>
<p><strong>分段技术小结</strong></p>
<ul>
<li>内存并没有分段，段的划分来自于CPU，由于8086CPU用<code>（段地址×16）+ 偏移地址 = 物理地址</code>的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存</li>
<li>段地址×16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数；可根据需要，将<strong>地址连续、起始地址为16的倍数的一组内存单元定义为一个段。</strong></li>
<li>偏移地址为16位，16 位地址的寻址能力为 64K，所以一个段的长度最大为64K。也就是说<strong>给定一个段地址</strong>，仅通过变化偏移地址来进行寻址，<strong>最多可以定位64K个内存单元</strong>。 0~FFFFH</li>
<li>CPU访问内存单元时，必须向内存提供内存单元的最终物理地址=段地址+偏移地址</li>
<li>CPU可以用不同的段地址和偏移地址形成同一个物理地址，如下例</li>
<li><img src="/images%5C1582872120205.png" alt="1582872120205"></li>
</ul>
<h3 id="1-4-3-寄存器组"><a href="#1-4-3-寄存器组" class="headerlink" title="1.4.3 寄存器组"></a>1.4.3 寄存器组</h3><p>对汇编语言程序员来说，关心的是<strong>CPU的寄存器</strong></p>
<ul>
<li>8086／8088中共有14个16位寄存器 </li>
<li>寄存器在CPU内部，所以访问速度快。但容量小</li>
</ul>
<p>可编程寄存器可分为：</p>
<ul>
<li>通用寄存器<ul>
<li>在处理器中数量较多，使用频率较高，具有多种用途</li>
<li>比如可用来进行存放指令需要的操作数据</li>
</ul>
</li>
<li>专用寄存器<ul>
<li>只用于特定目的</li>
</ul>
</li>
<li>8086分为<strong>8个通用寄存器，4个段寄存器，1个标志寄存器和1个指令指针寄存器，均为16位</strong></li>
</ul>
<h4 id="寄存器与存储器的比较"><a href="#寄存器与存储器的比较" class="headerlink" title="寄存器与存储器的比较"></a>寄存器与存储器的比较</h4><ul>
<li>寄存器<ul>
<li>在CPU内部</li>
<li>访问速度快</li>
<li>容量小，成本高</li>
<li>用名字表示</li>
<li>没有地址</li>
</ul>
</li>
<li>存储器<ul>
<li>在CPU外部</li>
<li>访问速度慢</li>
<li>容量大，成本低</li>
<li>用地址表示</li>
<li>地址可用各种方式形成</li>
</ul>
</li>
</ul>
<h4 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h4><p><img src="/images/1583032445468.png" alt="1583032445468"></p>
<h4 id="1-通用寄存器"><a href="#1-通用寄存器" class="headerlink" title="1. 通用寄存器"></a>1. 通用寄存器</h4><p><img src="/images/1583032547356.png" alt="1583032547356"></p>
<h5 id="数据寄存器：AX-BX-CX-DX"><a href="#数据寄存器：AX-BX-CX-DX" class="headerlink" title="数据寄存器：AX/BX/CX/DX"></a>数据寄存器：AX/BX/CX/DX</h5><p>存放<strong>任何数据信息</strong>。暂存计算的中间结果，数据中转站。</p>
<p>每个寄存器又有它们各自的专用目的：</p>
<ul>
<li>AX (Accumulator)——累加器，使用频度最高，用于算术、逻辑运算以及与外设传送信息等；</li>
<li>BX (Base)——基址寄存器，常用做存放存储器<strong>地址</strong>；</li>
<li>CX (Count)——计数器，作为循环和串操作等指令中的隐含计数器；</li>
<li>DX (Data)——数据寄存器，常用来<strong>存放双字长数据的高16位，或存放外设端口地址。</strong></li>
</ul>
<p>他们还可以进一步的分为高字节H(high)和低字节L(Low)；两部分，这样就有了8个8位通用寄存器，操作互不影响，也可一起使用。</p>
<p><img src="/images/1582875665869.png" alt="1582875665869"></p>
<p><img src="/images/1582875684106.png" alt="1582875684106"></p>
<h5 id="变址寄存器-SI-DI"><a href="#变址寄存器-SI-DI" class="headerlink" title="变址寄存器:SI/DI"></a>变址寄存器:SI/DI</h5><p><img src="/images/1583032955013.png" alt="1583032955013"></p>
<p>变址寄存器常用于存储器寻址时提供<strong>地址</strong>，有两个是因为很多运算是余姚两个操作数才能进行的（加法等）</p>
<p>16位，不可拆分使用</p>
<h4 id="2-段寄存器-CS-DS-SS-ES"><a href="#2-段寄存器-CS-DS-SS-ES" class="headerlink" title="2. 段寄存器:CS/DS/SS/ES"></a>2. 段寄存器:CS/DS/SS/ES</h4><p><img src="/images/1583033208984.png" alt="1583033208984"></p>
<ul>
<li><p>段寄存器用来确定该段在内存中的起始地址</p>
</li>
<li><p>用途特定，不可分开使用</p>
</li>
</ul>
<p>4个<strong>专门存放段地址</strong>的段寄存器（16位）</p>
<ul>
<li><p>代码段  段寄存器 CS</p>
</li>
<li><p>数据段  段寄存器 DS</p>
</li>
<li><p>堆栈段  段寄存器 SS</p>
</li>
<li><p>附加段  段寄存器 ES</p>
<p><strong>物理地址= 10H × (DS) + 偏移</strong></p>
</li>
</ul>
<p>（最大偏移地址为FFFFH）</p>
<p>得到的地址必须是16的倍数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">解释为什么必须是16的倍数</span><br><span class="line">这是历史遗留问题.</span><br><span class="line">　　intel 8088时代，计算机的地址总线是20位的,即可以寻址能力可以达到1M字节,但是它的ALU和寄存器都只有16位,也就是表示数的能力只能达64k，再大就逾锅了。那怎么办呢？INTEL想了一个办法，让两个寄存器对来表示一个物理地址，比如说DS：BX，前者叫段寄存器，后者叫偏址寄存器。由于这两个寄存器都是16位，直接相加还是不能匹配20位的地址线的访问能力，因此，INTEL公司变通了一下，人为地将这个组合寻址设计成：在它们组合时，让段寄存器左移四位（假设DS是1234H，左移4位就变成了12340H，至于它内部怎么实现我们不用管它。注意，对于16进制的数来说，乘以16就相当于在原数后面补个0，因为它是逢16进1啊；与10进制数乘10就是后面补0同样道理。）然后与偏址寄存器相加，这样得到的地址最大可以到0FFFFFH。这样行了。</span><br><span class="line">　　现在都32位机了，甚至64位了，所以上面的寻址方法在保护模式下不再用了。</span><br></pre></td></tr></table></figure>

<p>例：(DS)=3000H,  偏移=1234H,  物理地址= 10H × (DS) + 偏移 =31234H</p>
<p><img src="/images%5C1582872562768.png" alt="1582872562768"></p>
<p>CPU几种典型的操作</p>
<ul>
<li>取 指 令：  指令单元地址＝（CS）×10H＋IP(用于存指令的寄存器的偏移地址)</li>
<li>堆栈操作：堆栈数据地址＝（SS）×10H＋偏移（代码中指出即可，下同）</li>
<li>内存数据：内存数据地址＝（DS）×10H＋偏移</li>
</ul>
<h5 id="CS-IP-Instruction-Pointer"><a href="#CS-IP-Instruction-Pointer" class="headerlink" title="CS+IP (Instruction Pointer)"></a>CS+IP (Instruction Pointer)</h5><p><strong>CS+IP</strong>是8086CPU中最关键的寄存器，它们指示了<strong>CPU当前要读取指令的地址</strong>。</p>
<p>指令指针寄存器IP，指示代码段中指令的<strong>偏移地址</strong></p>
<p>它与代码段寄存器CS联用，确定下一条指令的<strong>物理地址</strong></p>
<p>IP寄存器是一个专用寄存器,程序一般不可直接使用</p>
<h5 id="SS-指针寄存器-SP-BP"><a href="#SS-指针寄存器-SP-BP" class="headerlink" title="SS+指针寄存器:SP/BP"></a>SS+指针寄存器:SP/BP</h5><ul>
<li>SP和BP寄存器与SS段寄存器联合使用以确定<strong>堆栈段中的存储单元地址</strong></li>
<li>指针寄存器用于<strong>寻址</strong>内存堆栈内的数据<ul>
<li>SP (Stack Pointer)为堆栈指针寄存器，指示栈顶的<strong>偏移地址</strong></li>
<li>SP 不能再用于其他目的，具有专用目的</li>
<li>BP (Base Pointer)为基址指针寄存器，表示数据在堆栈段中的<strong>基地址</strong></li>
</ul>
</li>
</ul>
<h5 id="堆栈（Stack）"><a href="#堆栈（Stack）" class="headerlink" title="堆栈（Stack）"></a>堆栈（Stack）</h5><p>堆栈是主存中一个特殊的区域</p>
<p>它采用<strong>先进后出</strong>FILO（First In Last Out）或后进先出LIFO（Last In First Out）的原则进行存取操作，而不是随机存取操作方式</p>
<p>堆栈通常由处理器自动维持</p>
<p>在8086中，由堆栈段寄存器<strong>SS</strong>和堆栈指针寄存器<strong>SP</strong>共同指示</p>
<p><img src="F:%5C%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6%5C%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/images%5C1582874817187.png" alt="1582874817187"></p>
<h5 id="数据段（Data-Segment）"><a href="#数据段（Data-Segment）" class="headerlink" title="数据段（Data Segment）"></a>数据段（Data Segment）</h5><ul>
<li>数据段存放运行程序所用的数据<ul>
<li>数据段寄存器<strong>DS</strong>存放数据段的段地址</li>
<li>各种主存寻址方式（有效地址EA）得到存储器中操作数的偏移地址</li>
</ul>
</li>
<li>CPU利用<strong>DS:偏移地址</strong>存取数据段中的数据</li>
</ul>
<h5 id="附加段（Extra-Segment）"><a href="#附加段（Extra-Segment）" class="headerlink" title="附加段（Extra Segment）"></a>附加段（Extra Segment）</h5><ul>
<li>附加段是附加的数据段，也用于数据的保存：<ul>
<li>附加段寄存器ES存放附加段的段地址</li>
<li>各种主存寻址方式（有效地址EA）得到存储器中操作数的偏移地址</li>
</ul>
</li>
<li>处理器利用<strong>ES:偏移地址</strong>存取附加段中的数据</li>
<li>串操作指令将附加段ES作为其目的操作数的存放区域</li>
</ul>
<h5 id="如何分配各个逻辑段"><a href="#如何分配各个逻辑段" class="headerlink" title="如何分配各个逻辑段"></a>如何分配各个逻辑段</h5><ul>
<li>程序的指令序列必须安排在代码段CS</li>
<li>程序使用的堆栈一定在堆栈段SS</li>
<li>程序中的数据默认是安排在数据段DS，也经常安排在附加段ES，尤其是串操作的目的区必须是附加段ES</li>
<li>数据的存放比较灵活，实际上可以存放在任何一种逻辑段中</li>
</ul>
<h5 id="段寄存器的使用规定"><a href="#段寄存器的使用规定" class="headerlink" title="段寄存器的使用规定"></a>段寄存器的使用规定</h5><table>
<thead>
<tr>
<th>访问存储器的方式</th>
<th>默认</th>
<th>可超越</th>
<th>偏移地址</th>
</tr>
</thead>
<tbody><tr>
<td>取指令</td>
<td>CS</td>
<td>无</td>
<td>IP</td>
</tr>
<tr>
<td>堆栈操作</td>
<td>SS</td>
<td>无</td>
<td>SP</td>
</tr>
<tr>
<td>一般数据访问</td>
<td>DS</td>
<td>CS ES SS</td>
<td>有效地址\EA</td>
</tr>
<tr>
<td>BP\基址的寻址方式</td>
<td>SS</td>
<td>CS ES DS</td>
<td>有效地址\EA</td>
</tr>
<tr>
<td>串操作的源操作数</td>
<td>DS</td>
<td>CS ES SS</td>
<td>SI</td>
</tr>
<tr>
<td>串操作的目的操作数</td>
<td>ES</td>
<td>无</td>
<td>DI</td>
</tr>
</tbody></table>
<h4 id="3-标志寄存器"><a href="#3-标志寄存器" class="headerlink" title="3. 标志寄存器"></a>3. 标志寄存器</h4><p>标志寄存器F(FLAGS),又称<strong>程序状态字寄存器</strong>PSW</p>
<p>FLAGS中的各种标志分成了两类：6个状态标志和3个控制标志</p>
<ul>
<li>状态标志位：CF,OF,ZF,SF,PF,AF<ul>
<li>由CPU根据当前程序运行结果的状态自动完成的</li>
<li>一般用作转移指令的转移控制条件</li>
</ul>
</li>
<li>控制标志位DF,IF,TF<ul>
<li>用以存放控制CPU工作方式的标志信息</li>
<li>由程序设置</li>
</ul>
</li>
</ul>
<p><img src="/images/1582875789444.png" alt="1582875789444"></p>
<h5 id="1-状态标志位"><a href="#1-状态标志位" class="headerlink" title="1. 状态标志位"></a>1. 状态标志位</h5><h6 id="进位标志CF（Carry-Flag）"><a href="#进位标志CF（Carry-Flag）" class="headerlink" title="进位标志CF（Carry Flag）"></a>进位标志CF（Carry Flag）</h6><p>进行<strong>无符号数运算</strong>的时候，当运算结果的最高有效位有进位（加法）或借位（减法）时，进位标志置1，即CF = 1；否则CF = 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">  3AH + 7CH＝B6H</span><br><span class="line">  没有进位：CF &#x3D; 0</span><br><span class="line">  </span><br><span class="line">  AAH + 7CH＝（1）26H</span><br><span class="line">  有进位：CF &#x3D; 1</span><br></pre></td></tr></table></figure>

<h6 id="零标志ZF（Zero-Flag）"><a href="#零标志ZF（Zero-Flag）" class="headerlink" title="零标志ZF（Zero Flag）"></a>零标志ZF（Zero Flag）</h6><p>若运算结果为0，则ZF = 1，否则ZF = 0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">    3AH + 7CH＝B6H，结果不是零：</span><br><span class="line">    ZF &#x3D; 0</span><br><span class="line">    </span><br><span class="line">    86H + 7AH＝（1）00H，结果是零(为什么？)：</span><br><span class="line">    ZF &#x3D; 1</span><br><span class="line">注意：ZF为1表示的结果是0</span><br></pre></td></tr></table></figure>

<h6 id="符号标志SF（Sign-Flag）"><a href="#符号标志SF（Sign-Flag）" class="headerlink" title="符号标志SF（Sign Flag）"></a>符号标志SF（Sign Flag）</h6><p>CPU对有符号数运算结果的一种记录，记录数据的正负</p>
<ul>
<li>结果为负，SF = 1；</li>
<li>结果为正，SF = 0。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">  mov al,10000001B </span><br><span class="line">  add al,1</span><br><span class="line">  </span><br><span class="line">  执行后，结果为10000010B，SF&#x3D;1，</span><br><span class="line">  表示：如果指令进行的是有符号数运算，那么结果为负；</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。</li>
<li>如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。</li>
</ul>
<h6 id="奇偶标志PF-（Parity-Flag）"><a href="#奇偶标志PF-（Parity-Flag）" class="headerlink" title="奇偶标志PF （Parity Flag）"></a>奇偶标志PF （Parity Flag）</h6><p>当运算结果最低字节中“1”的个数为偶数时，PF = 1；否则PF = 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">    3AH + 7CH＝B6H＝10110110B，</span><br><span class="line"></span><br><span class="line">结果中有5个1，是奇数：PF &#x3D; 0</span><br><span class="line">注意：PF标志仅反映最低8位中“1”的个数是偶或奇，即使是进行16位字操作。</span><br></pre></td></tr></table></figure>

<h6 id="辅助进位标志AF-（Auxiliary-Carry-Flag）"><a href="#辅助进位标志AF-（Auxiliary-Carry-Flag）" class="headerlink" title="辅助进位标志AF （Auxiliary Carry Flag）"></a>辅助进位标志AF （Auxiliary Carry Flag）</h6><p>运算时D3位（低半字节）有进位或借位时，  AF = 1；否则AF = 0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">   3AH + 7CH＝B6H</span><br><span class="line">   D3有进位：AF &#x3D; 1</span><br></pre></td></tr></table></figure>

<p>这个标志主要由处理器内部使用，用于十进制算术运算指令中，用户一般不必关心。（<strong>类似于进位标志</strong>）</p>
<h6 id="溢出标志OF（Overflow-Flag）"><a href="#溢出标志OF（Overflow-Flag）" class="headerlink" title="溢出标志OF（Overflow Flag）"></a>溢出标志OF（Overflow Flag）</h6><p>有符号数运算的结果有溢出，则OF=1；否则 OF＝0。<br>只是对有符号数而言。对无符号数而言，OF＝1并不意味着结果出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">    mov al,98</span><br><span class="line">    add al,99</span><br><span class="line">    </span><br><span class="line">执行后将产生溢出。</span><br><span class="line">因为add al,99 进行的有符号数运算是：(al)&#x3D;(al)+99&#x3D;98+99&#x3D;197</span><br><span class="line">而结果197超出了机器所能表示的8位有符号数的范围：</span><br><span class="line">-128~127。</span><br></pre></td></tr></table></figure>

<p><strong>什么是溢出</strong></p>
<ul>
<li>处理器内部以补码表示有符号数<ul>
<li>8个二进制位能够表达的整数范围是：+127 ~ -128</li>
<li>16位表达的范围是：+32767 ~ -32768</li>
</ul>
</li>
<li>如果运算结果超出这个范围，就是产生了溢出</li>
<li>有溢出，说明有符号数的运算结果不正确</li>
<li>无符号数有溢出吗？<ul>
<li>FFH + 01H = 00H, CF = 1, 进位</li>
</ul>
</li>
</ul>
<p><strong>溢出和进位</strong></p>
<ul>
<li>溢出标志OF和进位标志CF是两个意义不同的标志</li>
<li>进位标志CF表示无符号数运算结果是否超出范围，运算结果仍然正确；<ul>
<li>可恢复的错误。</li>
</ul>
</li>
<li>溢出标志OF表示有符号数运算结果是否超出范围，运算结果已经不正确。<ul>
<li>不可恢复错误。</li>
</ul>
</li>
</ul>
<p><strong>溢出和进位的对比</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例1：7FH + 01H＝80H</span><br><span class="line">无符号数运算：127＋1＝128，  范围内，无进位</span><br><span class="line">有符号数运算： 127＋1＝128 ，范围外，有溢出</span><br><span class="line"></span><br><span class="line">例2：FFH + 01H＝（1）00H</span><br><span class="line">无符号数运算：255＋1＝256，范围外，有进位</span><br><span class="line">有符号数运算：－1＋1＝0 ，   范围内，无溢出</span><br></pre></td></tr></table></figure>

<p><strong>如何运用溢出和进位</strong></p>
<ul>
<li>处理器对两个操作数进行运算时，并不知道操作数是有符号数还是无符号数，所以全部设置，按各自规则。<br>应该利用哪个标志，则由程序员来决定。</li>
<li>将参加运算的操作数是无符号数，就注意CF；</li>
<li>将参加运算的操作数是有符号数，则注意OF。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例： MOV  AX, 1</span><br><span class="line">    MOV  BX, 2</span><br><span class="line">    ADD  AX, BX</span><br><span class="line">    指令执行后，(AX)&#x3D;3, OF&#x3D;0, CF&#x3D;0, ZF&#x3D;0, SF&#x3D;0</span><br><span class="line"></span><br><span class="line">例： MOV  AX, FFFFH</span><br><span class="line">    MOV  BX, 1</span><br><span class="line">    ADD  AX, BX</span><br><span class="line">    指令执行后，(AX)&#x3D;0, OF&#x3D;0, CF&#x3D;1, ZF&#x3D;1, SF&#x3D;0</span><br></pre></td></tr></table></figure>

<h5 id="2-控制标志"><a href="#2-控制标志" class="headerlink" title="2. 控制标志"></a>2. 控制标志</h5><h6 id="方向标志DF（Direction-Flag）"><a href="#方向标志DF（Direction-Flag）" class="headerlink" title="方向标志DF（Direction Flag）"></a>方向标志DF（Direction Flag）</h6><ul>
<li>用于串操作指令中，控制地址的变化方向：<ul>
<li>设置DF＝0，串操作的存储器地址自动增加；</li>
<li>设置DF＝1，串操作的存储器地址自动减少。</li>
</ul>
</li>
</ul>
<h6 id="中断允许标志IF（Interrupt-enable-Flag）"><a href="#中断允许标志IF（Interrupt-enable-Flag）" class="headerlink" title="中断允许标志IF（Interrupt-enable Flag）"></a>中断允许标志IF（Interrupt-enable Flag）</h6><ul>
<li>用于控制外部可屏蔽中断是否可以被处理器响应：<ul>
<li>设置IF＝1，则允许中断；</li>
<li>设置IF＝0，则禁止中断。</li>
</ul>
</li>
</ul>
<h6 id="陷阱标志TF（Trap-Flag）"><a href="#陷阱标志TF（Trap-Flag）" class="headerlink" title="陷阱标志TF（Trap Flag）"></a>陷阱标志TF（Trap Flag）</h6><ul>
<li>用于控制处理器是否进入单步操作方式：<ul>
<li>设置TF＝0，处理器正常工作；</li>
<li>设置TF＝1，处理器单步执行指令。</li>
</ul>
</li>
<li>==单步执行指令——处理器在<strong>每条指令执行结束</strong>时，便产生一个编号为1的内部中断。==这种内部中断称为单步中断，所以TF也称为单步标志。<ul>
<li>利用单步中断可对程序进行逐条指令的调试。</li>
<li>这种逐条指令调试程序的方法就是单步调试。</li>
</ul>
</li>
</ul>
<h4 id="4-指针指令寄存器（IP）"><a href="#4-指针指令寄存器（IP）" class="headerlink" title="4. 指针指令寄存器（IP）"></a>4. 指针指令寄存器（IP）</h4><p><img src="/images/1583034422794.png" alt="1583034422794"></p>
<p><img src="/images/1583034434323.png" alt="1583034434323"></p>
<h2 id="1-5-8086的寻址方式"><a href="#1-5-8086的寻址方式" class="headerlink" title="1.5 8086的寻址方式"></a>1.5 8086的寻址方式</h2><p><img src="/images/1583038683934.png" alt="1583038683934"></p>
<p><img src="/images/1583038696339.png" alt="1583038696339"></p>
<p>有些指令不需要操作数，通常的指令都有一个或两个操作数，个别指令有3个甚至4个操作数</p>
<p><img src="/images/1583038867768.png" alt="1583038867768"></p>
<p><img src="/images/1583038878276.png" alt="1583038878276"></p>
<p>标准机器代码示例</p>
<p><img src="/images/1583039157843.png" alt="1583039157843"></p>
<h3 id="1-5-1-8086机器码格式"><a href="#1-5-1-8086机器码格式" class="headerlink" title="1.5.1 8086机器码格式"></a>1.5.1 8086机器码格式</h3><p>机器码格式：将指令以2进制数0和1进行编码的形式，也被称为<strong>指令编码格式</strong></p>
<p><img src="/images/1583567648014.png" alt="1583567648014"></p>
<p><img src="/images/1583567711516.png" alt="1583567711516"></p>
<p>8086机器代码格式如图所示：</p>
<p><img src="/images/1582876709710.png" alt="1582876709710"></p>
<p>操作码占1至两个字节</p>
<p>设计有多种寻址方式，因此操作数的个字段有多种组合：</p>
<p><img src="/images/1583477644581.png" alt="1583039426023"></p>
<h3 id="1-5-2-指令格式"><a href="#1-5-2-指令格式" class="headerlink" title="1.5.2 指令格式"></a>1.5.2 指令格式</h3><ul>
<li>每种指令的<strong>操作码</strong>：<ul>
<li>用一个唯一的助记符表示（指令功能的英文缩写）</li>
<li>对应着机器指令的一个二进制编码</li>
</ul>
</li>
<li>指令中的<strong>操作数</strong>：<ul>
<li>立即操作数：一个具体的数值</li>
<li>寄存器操作数：存放数据的寄存器</li>
<li>内存操作数：指明数据在主存位置的存储器地址<ul>
<li>通常为有效地址EA，段地址在某个段寄存器中</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-5-3-寻址方式"><a href="#1-5-3-寻址方式" class="headerlink" title="1.5.3 寻址方式"></a>1.5.3 寻址方式</h3><h4 id="1-立即寻址方式"><a href="#1-立即寻址方式" class="headerlink" title="1. 立即寻址方式"></a>1. 立即寻址方式</h4><p>操作数在指令中给出,作为指令机器码的一部分存储</p>
<p>​     MOV  AL, 34H         ；机器码：B0 34</p>
<p>​     MOV  AX, 0034H     ；机器码：B8 34 00</p>
<p>使用场合：常数，8位和16位。 </p>
<p>立即数寻址方式常用来给寄存器赋值</p>
<p>​    MOV AL,05H        ；AL←[05H]</p>
<p>​    MOV AX,0102H       ； AX←[0102H]</p>
<p>​    <img src="/images/1583210960302.png" alt="1583210960302"></p>
<h4 id="2-寄存器寻址方式"><a href="#2-寄存器寻址方式" class="headerlink" title="2. 寄存器寻址方式"></a>2. 寄存器寻址方式</h4><ul>
<li>操作数在指定的数据寄存器中<ul>
<li>MOV  AX, BX</li>
<li>MOV  AL, BH</li>
</ul>
</li>
<li>注意可用寄存器：<ul>
<li>8位寄存器r8：AH、AL、BH、BL、CH、CL、DH、DL</li>
<li>16位寄存器r16：AX、BX、CX、DX、SI、DI、BP、SP</li>
<li>4个段寄存器seg：CS、DS、SS、ES</li>
<li><strong>CS/IP不能用作目的操作数：</strong><ul>
<li><strong>MOV  CS/IP, AX （X）</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-内存操作数寻址方式"><a href="#3-内存操作数寻址方式" class="headerlink" title="3. 内存操作数寻址方式"></a>3. 内存操作数寻址方式</h4><p>指令中给出操作数的主存地址信息（偏移地址，称之为有效地址EA），而段地址在默认的或用<strong>段超越</strong>前缀指定的段寄存器中</p>
<p><strong>段超越</strong></p>
<p>隐式段地址——8086/8088指令系统对存储单元的访问，其段地址都是从系统事先约定好的段寄存器中获取； </p>
<p><strong>规则为：除串操作指令外，若出现BP（SP），默认在SS中，否则所有的操作都默认在DS中。</strong></p>
<p>（显式段地址）<strong>段超越</strong>不是按照系统的约定，而是在指令中显式指定某一段寄存器作为存储器操作数的段地址</p>
<p>寻址方式分类：</p>
<h5 id="直接寻址方式-direct-addressing"><a href="#直接寻址方式-direct-addressing" class="headerlink" title="直接寻址方式(direct addressing)"></a>直接寻址方式(direct addressing)</h5><ul>
<li>内存操作数的偏移地址由指令直接给出</li>
<li>例如：<code>MOV  AX, [2000H]  ；AX←DS:[2000H]</code></li>
<li>注意：<ul>
<li>隐含的段为数据段 DS</li>
<li>物理地址 = 16 * (DS) +偏移地址</li>
</ul>
</li>
</ul>
<h5 id="寄存器间接寻址方式-register-indirect"><a href="#寄存器间接寻址方式-register-indirect" class="headerlink" title="寄存器间接寻址方式(register indirect)"></a>寄存器间接寻址方式(register indirect)</h5><ul>
<li>指定某个地址寄存器（SI、DI、BX、BP）的内容作为内存操作数的偏移地址</li>
<li>使用场合：表格、字符串、缓冲区处理</li>
<li><code>MOV AX, [BX]    ；AX←DS:[BX]</code></li>
<li>注意段地址规则：<ul>
<li>BX, SI, DI $\to$ (DS)                                          </li>
<li>BP $\to​$ (SS)</li>
</ul>
</li>
</ul>
<h5 id="寄存器相对寻址方式-register-relative"><a href="#寄存器相对寻址方式-register-relative" class="headerlink" title="寄存器相对寻址方式(register relative)"></a>寄存器相对寻址方式(register relative)</h5><ul>
<li>指令中指定地址寄存器（SI、DI、BX、BP）与一个位移量相加作为内存操作数的偏移地址</li>
<li>使用场合：适于表格、字符串、缓冲区的处理；</li>
<li><code>MOV AX,[SI+2]       ；AX←DS:[SI+02H]</code></li>
<li><code>MOV AX,[BP+06H]     ；AX←SS:[BP+06H]</code></li>
<li><img src="/images/1583211794594.png" alt="1583211794594"></li>
</ul>
<h5 id="基址变址寻址方式-based-indexed"><a href="#基址变址寻址方式-based-indexed" class="headerlink" title="基址变址寻址方式(based indexed..)"></a>基址变址寻址方式(based indexed..)</h5><ul>
<li>指定基址寄存器(BX,BP)、变址寄存器(SI,DI)内容相加作为内存操作数的地址。</li>
<li>使用场合：适于数组、字符串、表格的处理，更加灵活</li>
<li><code>MOV [BX+DI],DX</code>      </li>
<li><code>MOV AL, [BP+SI]  ；AL←SS:[BP+SI]</code></li>
<li>注意：必须是一个基址寄存器和一个变址寄存器的<strong>组合</strong></li>
</ul>
<h5 id="相对基址变址方式-relative-based-indexed"><a href="#相对基址变址方式-relative-based-indexed" class="headerlink" title="相对基址变址方式(relative based indexed..)"></a>相对基址变址方式(relative based indexed..)</h5><ul>
<li>指定基址寄存器(BX,BP) 、变址寄存器(SI,DI) 、位移量之和作为内存操作数的地址</li>
<li>使用场合：适于二维数组的寻址<code>Buffer[BX][SI] = [Buffer+BX+SI]</code><img src="../../%E5%AD%A6%E4%B9%A0%E6%96%87%E4%BB%B6/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80//images/1583211803837.png" alt="1583211803837"></li>
<li><code>MOV AL, [SI+BX+2]    MOV [BX+DI-16H], DX   MOV AL, 2[SI+BX]   ；AL←DS:[BX+SI+02H]</code></li>
</ul>
<p>寻址方式的多种表示方式</p>
<ul>
<li><p>位移量可用符号表示：</p>
<p>   MOV AX,[SI+<strong>COUNT</strong>]       ；COUNT是事先定义的变量或常量（就是数值）</p>
<p>   MOV AX,[BX+SI+<strong>WNUM</strong>]     ；WNUM是变量或常量</p>
</li>
<li><p>同一寻址方式可以写成不同的形式：</p>
<p>   MOV AX,[BX][SI]          ；MOV AX,[BX+SI]</p>
<p>   MOV AX,COUNT[SI]         ；MOV AX,[SI+COUNT]</p>
<p>   MOV AX,WNUM[BX] [SI]           </p>
<p>；等同于  MOV AX,WNUM[BX+SI]</p>
<p>；等同于  MOV AX,[BX+SI+WNUM]</p>
</li>
</ul>
<p>同时修改CS、IP的内容，可用形如<code>jmp段地址:偏移地址</code>的指令完成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmp 2AE3:3	;执行后，CS&#x3D;2AE3H，IP&#x3D;0003H，CPU将从2AE33H中读取指令</span><br><span class="line">jmp 3:0B16	;执行后，CS&#x3D;0003H，IP&#x3D;0B16H，CPU将从00B46H中读取指令</span><br></pre></td></tr></table></figure>

<p>仅修改IP的内容，可用形如<code>jmp 某一合法地址</code>的指令完成</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E6%B1%87%E7%BC%96/" rel="tag"># 汇编</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/20/%E8%AE%A1%E7%BB%84%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BA%BF/" rel="next" title="（计算机组成原理）第三章 系统总线">
                <i class="fa fa-chevron-left"></i> （计算机组成原理）第三章 系统总线
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/20/%E6%B1%87%E7%BC%96%EF%BC%88%E4%BA%8C%EF%BC%898086%E7%9A%84%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F/" rel="prev" title="汇编（二）8086的指令系统">
                汇编（二）8086的指令系统 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tiantian</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">23</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#汇编语言"><span class="nav-text">汇编语言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基础知识"><span class="nav-text">基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1数的表示"><span class="nav-text">1.1数的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数制"><span class="nav-text">数制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数制之间的转换"><span class="nav-text">数制之间的转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制运算"><span class="nav-text">二进制运算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机中数的表示"><span class="nav-text">计算机中数的表示</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#N-补补-N"><span class="nav-text">$[N]_{补补}&#x3D; [N]$</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BCD码-Binary-Coded-Data"><span class="nav-text">BCD码(Binary-Coded Data)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符编码"><span class="nav-text">字符编码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-微型计算机（PC）系统"><span class="nav-text">1.2 微型计算机（PC）系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU"><span class="nav-text">CPU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O-子系统"><span class="nav-text">I&#x2F;O 子系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存（存储器）"><span class="nav-text">内存（存储器）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统总线"><span class="nav-text">系统总线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU对存储器的读写"><span class="nav-text">CPU对存储器的读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存地址空间"><span class="nav-text">内存地址空间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Intel-80x86系列微处理器"><span class="nav-text">1.3 Intel 80x86系列微处理器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-8086微处理器"><span class="nav-text">1.4 8086微处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-内部结构"><span class="nav-text">1.4.1 内部结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-存储器组织"><span class="nav-text">1.4.2 存储器组织</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数据的存储格式"><span class="nav-text">1. 数据的存储格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-存储器的分段管理"><span class="nav-text">2. 存储器的分段管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何给出20位的物理地址-分段技术"><span class="nav-text">如何给出20位的物理地址: 分段技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-3-寄存器组"><span class="nav-text">1.4.3 寄存器组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#寄存器与存储器的比较"><span class="nav-text">寄存器与存储器的比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总览"><span class="nav-text">总览</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-通用寄存器"><span class="nav-text">1. 通用寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#数据寄存器：AX-BX-CX-DX"><span class="nav-text">数据寄存器：AX&#x2F;BX&#x2F;CX&#x2F;DX</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#变址寄存器-SI-DI"><span class="nav-text">变址寄存器:SI&#x2F;DI</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-段寄存器-CS-DS-SS-ES"><span class="nav-text">2. 段寄存器:CS&#x2F;DS&#x2F;SS&#x2F;ES</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CS-IP-Instruction-Pointer"><span class="nav-text">CS+IP (Instruction Pointer)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#SS-指针寄存器-SP-BP"><span class="nav-text">SS+指针寄存器:SP&#x2F;BP</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#堆栈（Stack）"><span class="nav-text">堆栈（Stack）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数据段（Data-Segment）"><span class="nav-text">数据段（Data Segment）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#附加段（Extra-Segment）"><span class="nav-text">附加段（Extra Segment）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如何分配各个逻辑段"><span class="nav-text">如何分配各个逻辑段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#段寄存器的使用规定"><span class="nav-text">段寄存器的使用规定</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-标志寄存器"><span class="nav-text">3. 标志寄存器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-状态标志位"><span class="nav-text">1. 状态标志位</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#进位标志CF（Carry-Flag）"><span class="nav-text">进位标志CF（Carry Flag）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#零标志ZF（Zero-Flag）"><span class="nav-text">零标志ZF（Zero Flag）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#符号标志SF（Sign-Flag）"><span class="nav-text">符号标志SF（Sign Flag）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#奇偶标志PF-（Parity-Flag）"><span class="nav-text">奇偶标志PF （Parity Flag）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#辅助进位标志AF-（Auxiliary-Carry-Flag）"><span class="nav-text">辅助进位标志AF （Auxiliary Carry Flag）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#溢出标志OF（Overflow-Flag）"><span class="nav-text">溢出标志OF（Overflow Flag）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-控制标志"><span class="nav-text">2. 控制标志</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#方向标志DF（Direction-Flag）"><span class="nav-text">方向标志DF（Direction Flag）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#中断允许标志IF（Interrupt-enable-Flag）"><span class="nav-text">中断允许标志IF（Interrupt-enable Flag）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#陷阱标志TF（Trap-Flag）"><span class="nav-text">陷阱标志TF（Trap Flag）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-指针指令寄存器（IP）"><span class="nav-text">4. 指针指令寄存器（IP）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-8086的寻址方式"><span class="nav-text">1.5 8086的寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-1-8086机器码格式"><span class="nav-text">1.5.1 8086机器码格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-2-指令格式"><span class="nav-text">1.5.2 指令格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-3-寻址方式"><span class="nav-text">1.5.3 寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-立即寻址方式"><span class="nav-text">1. 立即寻址方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-寄存器寻址方式"><span class="nav-text">2. 寄存器寻址方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-内存操作数寻址方式"><span class="nav-text">3. 内存操作数寻址方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#直接寻址方式-direct-addressing"><span class="nav-text">直接寻址方式(direct addressing)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#寄存器间接寻址方式-register-indirect"><span class="nav-text">寄存器间接寻址方式(register indirect)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#寄存器相对寻址方式-register-relative"><span class="nav-text">寄存器相对寻址方式(register relative)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#基址变址寻址方式-based-indexed"><span class="nav-text">基址变址寻址方式(based indexed..)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#相对基址变址方式-relative-based-indexed"><span class="nav-text">相对基址变址方式(relative based indexed..)</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tiantian</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2020/03/20/%E6%B1%87%E7%BC%96%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/';
          this.page.identifier = '2020/03/20/汇编（一）基础知识/';
          this.page.title = '汇编（一）基础知识';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
